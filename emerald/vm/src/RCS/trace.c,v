head	1.11;
access;
symbols
	105alpha:1.10
	104alpha:1.9
	103alpha:1.7
	102alpha:1.6
	101alpha:1.6
	100alpha:1.5;
locks; strict;
comment	@ * @;


1.11
date	2007.06.11.02.35.58;	author norm;	state Exp;
branches;
next	1.10;

1.10
date	99.02.22.22.22.42;	author norm;	state Exp;
branches;
next	1.9;

1.9
date	98.05.08.19.38.21;	author norm;	state Exp;
branches;
next	1.8;

1.8
date	98.05.04.19.21.36;	author norm;	state Exp;
branches;
next	1.7;

1.7
date	98.04.30.20.45.12;	author norm;	state Exp;
branches;
next	1.6;

1.6
date	98.04.08.21.45.27;	author norm;	state Exp;
branches;
next	1.5;

1.5
date	98.03.24.16.25.58;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	98.03.02.16.37.40;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	98.02.23.16.20.39;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	98.02.09.17.55.17;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	97.01.21.23.59.53;	author norm;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Check in current version
@
text
@/* comment me!
 */

#define E_NEEDS_VARARGS
#define E_NEEDS_STRING
#include "system.h"

#include "assert.h"
#include "trace.h"
#include "misc.h"

int
  traceallocate,
  traceassign,
  traceatctsort,
  tracebuiltins,
  tracecall,
  traceccalls,
  tracecheckpoint,
  traceconform,
  traceconformfailure,
  tracecopy,
  tracectinfo,
  tracedbm,
  tracedebug,
  tracedebuginfo,
  tracedelay,
  tracedoto,
  traceemit,
  traceemitmove,
  traceenvironment,
  tracefindct,
  tracefold,
  tracegraph,
  tracehandler,
  tracehelp,
  traceimports,
  traceindex,
  traceinitiallies,
  traceinterpret,
  traceinvoccache,
  tracekernel,
  traceknowct,
  traceknowlocal,
  traceknowmanifest,
  tracegenerate,
  tracelinenumber,
  tracelocals,
  tracemanifest,
  tracemap,
  tracematchat,
  tracememory,
  tracemessage,
  traceoid,
  tracepasses,
  traceprimitive,
  traceprocess,
  tracerelocation,
  tracescc,
  tracesys,
  tracetempl,
  tracetempreg,
  tracetempstack,
  tracetrans,
  tracetypecheck,
  tracestreams,
  tracerinvoke,
  tracegaggle,
  tracedistgc,
  tracelocate,
  tracedist,
  traceunavailable,
  tracefailure = 1,
  tracex,
  traceT
;

typedef struct {
  char *name;
  int  *flag;
} flagTable, *flagTablePtr;

flagTable table [] = {
  { "help", &tracehelp },
  { "index", &traceindex },
  { "templ", &tracetempl },
  { "trans", &tracetrans },
  { "map", &tracemap },
  { "passes", &tracepasses },
  { "interpret", &traceinterpret },
  { "call", &tracecall },
  { "fold", &tracefold },
  { "sys", &tracesys },
  { "memory", &tracememory },
  { "process", &traceprocess },
  { "initiallies", &traceinitiallies },
  { "checkpoint", &tracecheckpoint },
  { "ctinfo", &tracectinfo },
  { "debug", &tracedebug },
  { "conform", &traceconform },
  { "relocation", &tracerelocation },
  { "oid", &traceoid },
  { "ccalls", &traceccalls },
  { "streams", &tracestreams },
  { "rinvoke", &tracerinvoke },
  { "gaggle", &tracegaggle },
  { "distgc", &tracedistgc },
  { "locate", &tracelocate },
  { "dist", &tracedist },
  { "unavailable", &traceunavailable },
  { "failure", &tracefailure },
  { "x", &tracex },
  { "t", &traceT },
  { NULL, 0 },
};

static FILE *tracefile;
static char *tracebuffer, *tracebufferpointer;
static int tracebuffersize;

static void updatetracebufferpointer(void)
{
  while (*tracebufferpointer) tracebufferpointer++;
  if (tracebufferpointer >= tracebuffer + tracebuffersize) {
    memmove(tracebuffer, tracebuffer + tracebuffersize, tracebufferpointer - (tracebuffer + tracebuffersize));
    tracebufferpointer -= tracebuffersize;
  }
}

void toLower(char *s)
{
  register char c;
  while ((c = *s)) {
    if (c >= 'A' && c <= 'Z') *s += ('a' - 'A');
    s++;
  }
}

char *find(char *s, char c)
{
  register char theC;
  while ((theC = *s) && theC != c) s++;
  return(theC == c ? s : NULL);
}

void setTrace(char *name, int value)
{
  register flagTablePtr tp;
  for (tp = &table[0]; tp->name; tp++) {
    if (!strcmp(name, tp->name)) {
      *tp->flag = value;
      break;
    }
  }
  if (tp->name == NULL) {
    ftrace("Unknown trace name \"%s\"", name);
  }
}

int parseTraceFlag(char *f)
{
  char *comma, *equals;
  int value;

  if (f[0] == '-' && f[1] == 'T') f += 2;
  toLower(f);
  while (f && *f) {
    comma = find(f, ',');
    if (comma != NULL) *comma = '\0';
    equals = find(f, '=');
    if (equals == NULL) equals = find(f, '-');
    if (equals == NULL) {
      value = 1;
    } else {
      value = mstrtol(equals+1, 0, 0);
      *equals = '\0';
    }
    setTrace(f, value);
    f = (comma == NULL ? NULL : comma + 1);
  }
  return(1);
}

void SetTraceFile(char *filename)
{
  FILE *f;
  if ((f = fopen(filename, "wb"))) {
    tracefile = f;
  } else {
    ftrace("Can't open the trace file \"%s\" for writing", filename);
  }
}

void SetTraceBufferSize(int size)
{
  tracebuffersize = size;
  tracebuffer = malloc(tracebuffersize + 256);
  memset(tracebuffer, 0, tracebuffersize);
  tracebufferpointer = tracebuffer;
}

void TraceFin(void)
{
  char *head;
  if (tracebuffer) {
    for (head = tracebufferpointer; head < tracebuffer + tracebuffersize && *head == '\0'; head++) ;
    if (head < tracebuffer + tracebuffersize) {
      fwrite(head, 1, tracebuffer + tracebuffersize - head, tracefile);
    }
    fwrite(tracebuffer, 1, tracebufferpointer - tracebuffer, tracefile);
    fflush(tracefile);
    free(tracebuffer);
    tracebuffer = tracebufferpointer = 0;
    tracebuffersize = 0;
  }
}

static struct timeval original;

void TraceInit(void)
{
  gettimeofday(&original, 0);
  tracefile = stdout;
}

void traceTS(int level)
{
  extern struct timeval TimeMinus(struct timeval, struct timeval);
  struct timeval print, now;

  gettimeofday(&now, 0);
  print = TimeMinus(now, original);

  if (traceT) {
    if (tracebufferpointer) {
      sprintf(tracebufferpointer, "%5d.%06d: ", (int)print.tv_sec%100000, (int)print.tv_usec);
      updatetracebufferpointer();
    } else {
      fprintf(tracefile, "%5d.%06d: ", (int)print.tv_sec%100000, (int)print.tv_usec);
    }
  }
  while (--level > 0) {
    if (tracebufferpointer) {
      tracebufferpointer[0] = ' ';
      tracebufferpointer[1] = '\0';
      updatetracebufferpointer();
    } else {
      putc(' ', tracefile);
    }
  }
}
  
/*VARARGS2*/
#ifdef STDARG_WORKS
void ftrace(char *format, ...)
#else
void ftrace(char *format, int a, int b, int c, int d, int e, int f)
#endif
{
#ifdef STDARG_WORKS
  va_list ap;
  va_start(ap, format);
  if (tracebufferpointer) {
    vsprintf(tracebufferpointer, format, ap);
    updatetracebufferpointer();
  } else {
    vfprintf(tracefile, format, ap);
  }
  va_end(ap);
#else
  if (tracebufferpointer) {
    sprintf(tracebufferpointer, format, a, b, c, d, e, f);
    updatetracebufferpointer();
  } else {
    printf(format, a, b, c, d, e, f);
  }
#endif
  if (tracebufferpointer) {
    tracebufferpointer[0] = '\n';
    tracebufferpointer[1] = '\0';
    updatetracebufferpointer();
  } else {
    putc('\n', tracefile);
    fflush(tracefile);
  }
}
@


1.10
log
@Added a failure trace which is enabled by default
@
text
@d73 3
a75 1
  tracefailure = 1
d112 2
a175 1
      if (value <= 0) value = 1;
a217 2
#define USEDIFFS
#ifdef USEDIFFS
d219 1
a219 1
#endif
a221 1
#ifdef USEDIFFS
a222 1
#endif
a227 1
#ifdef USEDIFFS
a228 1
#endif
a231 1
#ifdef USEDIFFS
d233 8
a240 8
#else
  print = now;
#endif
  if (tracebufferpointer) {
    sprintf(tracebufferpointer, "%5d.%06d: ", (int)print.tv_sec%100000, (int)print.tv_usec);
    updatetracebufferpointer();
  } else {
    fprintf(tracefile, "%5d.%06d: ", (int)print.tv_sec%100000, (int)print.tv_usec);
@


1.9
log
@Cleanups to remove useless leftover drivel found by cxref
@
text
@d72 2
a73 1
  traceunavailable
d109 1
@


1.8
log
@Reimplemented the object table
@
text
@d150 1
a150 1
    fprintf(stderr, "Unknown trace name \"%s\"\n", name);
d185 1
a185 1
    fprintf(stderr, "Can't open the trace file \"%s\" for writing\n", filename);
a224 12
void initializeTrace(void)
{
  register flagTablePtr tp;
  
  IFTRACE(help, 1) {
    fprintf(stdout, "Trace\t\tValue\n");
    for (tp = &table[0]; tp->name; tp++) {
      fprintf(stdout, "\"%s\" -->\t%d\n", tp->name, *tp->flag);
    }
  }
}

a254 33
/*VARARGS2*/
#ifdef STDARG_WORKS
void etrace(int level, char *format, ...)
#else
void etrace(int level, char *format, int a, int b, int c, int d, int e, int f)
#endif
{
#ifdef STDARG_WORKS
  va_list ap;
  va_start(ap, format);
#endif
  traceTS(level);
#ifdef STDARG_WORKS
  if (tracebufferpointer) {
    sprintf(tracebufferpointer, format, ap);
    updatetracebufferpointer();
  } else {
    vfprintf(tracefile, format, ap);
  }
  va_end(ap);
#else
  printf(format, a, b, c, d, e, f);
#endif
  if (tracebufferpointer) {
    tracebufferpointer[0] = '\n';
    tracebufferpointer[1] = '\0';
    updatetracebufferpointer();
  } else {
    putc('\n', tracefile);
    fflush(tracefile);
  }
}

@


1.7
log
@Added deferred tracing support
@
text
@a333 9

#include "oisc.h"
extern OISc OIDToObjectTable;

void TracePrintObjectTable(void)
{
  OIScPrintF(OIDToObjectTable);
}

@


1.6
log
@More reliable process management, got xforms working
@
text
@d5 1
d112 11
d189 24
d250 15
a264 2
  fprintf(tracefile, "%3d.%06d: ", (int)print.tv_sec%1000, (int)print.tv_usec);
  while (--level > 0) putc(' ', tracefile);
d280 6
a285 1
  vfprintf(tracefile, format, ap);
d290 8
a297 2
  putc('\n', tracefile);
  fflush(tracefile);
d310 6
a315 1
  vfprintf(tracefile, format, ap);
d318 6
a323 1
  printf(format, a, b, c, d, e, f);
d325 16
a340 2
  putc('\n', tracefile);
  fflush(tracefile);
d342 1
@


1.5
log
@'.'
@
text
@d177 4
d183 3
a203 1
  static struct timeval last;
d206 1
a206 1
  struct timeval now;
d210 3
a212 6
  if (last.tv_sec == 0) {
    now = last;
  } else {
    now = TimeMinus(now, last);
  }
  last = now;
d214 1
a214 1
  fprintf(tracefile, "%3d.%06d: ", (int)now.tv_sec % 1000, (int)now.tv_usec);
@


1.4
log
@'./vm/src'
@
text
@d70 2
a71 1
  tracedist
d106 1
d110 2
d138 1
a138 1
    fprintf(stdout, "Unknown trace name \"%s\"\n", name);
d167 10
d179 1
d194 21
d226 1
a226 1
  while (--level > 0) putc(' ', stdout);
d228 1
a228 1
  vfprintf(stdout, format, ap);
d233 2
a234 2
  putc('\n', stdout);
  fflush(stdout);
d247 1
a247 1
  vfprintf(stdout, format, ap);
d252 2
a253 2
  putc('\n', stdout);
  fflush(stdout);
@


1.3
log
@'./vm/src'
@
text
@d4 3
a6 4
#include <stdlib.h>
#ifdef STDARG_WORKS
#include <stdarg.h>
#endif
d69 2
a70 1
  tracelocate
d104 1
@


1.2
log
@Checkpoint
@
text
@d68 3
a70 1
  tracegaggle
d102 2
@


1.1
log
@Initial revision
@
text
@d67 2
a68 1
  tracerinvoke
d99 1
@
