head	1.12;
access;
symbols
	105alpha:1.11
	104alpha:1.9
	103alpha:1.7
	102alpha:1.6
	101alpha:1.6
	100alpha:1.5;
locks; strict;
comment	@ * @;


1.12
date	2007.06.11.02.35.58;	author norm;	state Exp;
branches;
next	1.11;

1.11
date	99.02.22.22.21.24;	author norm;	state Exp;
branches;
next	1.10;

1.10
date	98.08.11.19.26.10;	author norm;	state Exp;
branches;
next	1.9;

1.9
date	98.05.08.19.38.21;	author norm;	state Exp;
branches;
next	1.8;

1.8
date	98.05.04.19.21.36;	author norm;	state Exp;
branches;
next	1.7;

1.7
date	98.05.01.04.47.38;	author norm;	state Exp;
branches;
next	1.6;

1.6
date	98.04.08.21.45.27;	author norm;	state Exp;
branches;
next	1.5;

1.5
date	98.03.24.16.25.58;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	98.03.02.16.37.40;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	98.02.23.16.20.39;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	98.02.09.17.55.17;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	97.01.21.23.59.53;	author norm;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Check in current version
@
text
@/****************************************************************************
 File     : oidtoobject.c 
 Date     : 08-11-92
 Author   : Mark Immel

 Contents : Routines to obtain objects from OIDs and vice versa

 Modifications
 -------------

*****************************************************************************/

#include "system.h"

#include "vm_exp.h"
#include "iset.h"
#include "oidtoobj.h"
#include "ooisc.h"
#include "globals.h"
#include "trace.h"
#include "read.h"
#include "assert.h"

/*
 * The initial size of the object table.  If it is too small, it gets
 * increased, but due to malloc's behaviour it costs a lot of data space.
 */
#define OBJECTTABLESIZE (24 * 1024)

OTable ObjectTable;

static Bits16        NextOIDepoch = 0;
static Bits32        NextOIDSeq = 1;
OID nooid = { 0, 0, 0, 0 };
static void resolveRelocations(OID, Object);
OID MyBaseOID;


/*
 * Initialize the ObjectTable
 */

void OIDToObjectInit() {
  ObjectTable = OTableCreateN(OBJECTTABLESIZE);
}

/*
 * Add entries to the ObjectTable
 */

void UpdateOIDTables(OID oid, Object o) {
  if (!wasGCMalloced(o)) {
    TRACE(oid, 8, ("Inserting non gcmalloced object %#x with oid %s", o, OIDString(oid)));
  }
  TRACE(oid, 3, ("Inserting %#x with OID %s", o, OIDString(oid)));
  SETHASOID(o->flags);
  OTableInsert(ObjectTable, oid, o);
  resolveRelocations(oid, o);
}

void OIDRemove(OID oid, Object o)
{
#ifndef NDEBUG
  Object old = OIDFetch(oid);
  if (old != o) {
    ftrace("OIDRemove botch:  %#x != %#x", (u32)old , (u32)o);
  }
#endif
  TRACE(oid, 3, ("Removing id from %#x %s", o, OIDString(oid)));

  CLEARHASOID(o->flags);
  OTableDeleteByObject(ObjectTable, o);
}

void OIDRemoveAny(Object o)
{
  OID hisoid = OTableLookupByObject(ObjectTable, o);
  if (!isNoOID(hisoid)) {
    CLEARHASOID(o->flags);
    OTableDeleteByObject(ObjectTable, o);
    TRACE(oid, 2, ("Removing oid %s from %#x", OIDString(hisoid), o));
  }
}

void OIDInsert(OID oid, Object o)
{
  Object old;
 
  old = OIDFetch(oid);
  if (!ISNIL(old)) {
    if (old != o) {
      TRACE(oid, 0, ("Defining an id that already exists %s -> %#x, a %.*s",
		     OIDString(oid), old,
		     CODEPTR(old->flags)->d.name->d.items,
		     CODEPTR(old->flags)->d.name->d.data));
    }
    OTableDeleteByObject(ObjectTable, old);
  }
  UpdateOIDTables(oid, o);
}

void UpdateObjectLocation(Object oldo, Object newo)
{
  OID oid;

  assert(HASOID(newo->flags));
  oid = OIDOf(oldo);
  TRACE(oid, 2, ("Moving oid %s from %#x to %#x", OIDString(oid), oldo, newo));
  OTableUpdateValue(ObjectTable, oldo, newo);
}
    
/* 
 * Add an OID to the table, using only its sequence value.  This routine
 * provides compatibility for the old data structures, which used only the
 * sequence value as significant.
 */

void OIDInsertFromSeq(unsigned seq, Object o)
{
  OID oid;

  oid = nooid;
  oid.Seq = seq;
  OIDInsert(oid, o);
}

static void resolveRelocations(OID id, Object o)
{
  ISet relocations;
  Relocation *r;

  relocations = (ISet) OIScLookup(relocationMap, id);
  if (OIScIsNIL(relocations)) return;
  TRACE(relocation, 1, ("Found object %#x for which %d relocations exist",
			id.Seq, ISetSize(relocations)));
  ISetForEach(relocations, r) {
    TRACE(relocation, 2, ("Setting location %#x+%#x",
			  r->o, r->offset));
    *(Object *)((char *)r->o + r->offset) = o;
    stoCheck(r->o, o);
    vmFree((char *) r);
  } ISetNext();
  ISetDestroy(relocations);
  OIScDelete(relocationMap, id);
}

/*
 * Generate a new oid
 */
void NewOID(OID *theOID)
{
  theOID->ipaddress = MyBaseOID.ipaddress;
  theOID->port = MyBaseOID.port;
  theOID->epoch = MyBaseOID.epoch;
  theOID->Seq = NextOIDSeq++;
  if (!theOID->Seq) {
    NextOIDepoch++;
    assert(0);
    theOID->epoch = NextOIDepoch;
  }
}

/*
 * Compare two OID's for equality
 */
int EqOID(OID oid1, OID oid2)
{
  return ((oid1.ipaddress == oid2.ipaddress) &&
         (oid1.port == oid2.port) &&
	 (oid1.epoch == oid2.epoch) && (oid1.Seq == oid2.Seq));
}

Bits32 OIDSeqOf(Object o)
{
  OID oid = OIDOf(o);
  if (!isNoOID(oid)) return oid.Seq;
  else return JNIL;
}

int findOpByName(ConcreteType ct, char *name)
{
  int i, nops, len = strlen(name);
  nops = ct->d.opVector->d.items;
  for (i = 3; i < nops; i++) {
    OpVectorElement e = ct->d.opVector->d.data[i];
    if (e->d.name->d.items == len && !memcmp(e->d.name->d.data, name, len))
      return i;
  }
  return -999999;
}

#ifdef USEABCONS
OOISc abConMap = NULL;

OpVectorElement findOp(ConcreteType ct, unsigned id)
{
  int i, nops;
  nops = ct->d.opVector->d.items;
  for (i = 3; i < nops; i++) {
    OpVectorElement e = ct->d.opVector->d.data[i];
    if (e->d.id == id)
      return e;
  }
  return (OpVectorElement)JNIL;
}

AbCon findAbCon(OID abOID, OID conOID)
{
  AbCon abcon;
  ConcreteType con;
  AbstractType ab;
  int i, nops;

  if (abConMap == NULL) abConMap = OOIScCreate();
  abcon = (AbCon)OOIScLookup(abConMap, abOID, conOID);
  if (OOIScIsNIL(abcon)) {
    ab = (AbstractType) OIDFetch( abOID);
    con= (ConcreteType) OIDFetch(conOID);
    nops = ab->d.ops->d.items;
    abcon = (AbCon) vmMalloc(sizeofAbCon + nops * sizeof(OpVectorElement));
    abcon->d.abOID = abOID;
    abcon->d.conOID = conOID;
    abcon->d.ab = ab;
    abcon->d.con = con;
    abcon->d.nops = nops;
    for (i = 0; i < nops; i++) {
      abcon->d.ops[i] = findOp(con, ab->d.ops->d.data[i]->d.id);
    }
    OOIScInsert(abConMap, abOID, conOID, (int)abcon);
  }
  return abcon;
}

AbCon findConCon(ConcreteType con)
{
  AbCon abcon;
  int i, nops;

  if (abConMap == NULL) abConMap = OOIScCreate();
  abcon = (AbCon)OOIScLookup(abConMap, OIDOf(con), OIDOf(con));
  if (OOIScIsNIL(abcon)) {
    nops = con->d.opVector->d.items;
    abcon = (AbCon) vmMalloc(sizeofAbCon + nops * sizeof(OpVectorElement));
    abcon->d.abOID = OIDOf(con);
    abcon->d.conOID = OIDOf(con);
    abcon->d.ab = (AbstractType) con;		/* TODO: this is broken */
    abcon->d.con = con;
    abcon->d.nops = nops;
    for (i = 0; i < nops; i++) {
      abcon->d.ops[i] = con->d.opVector->d.data[i];
    }
    OOIScInsert(abConMap, OIDOf(con), OIDOf(con), (int)abcon);
  }
  return abcon;
}

void verifyAbCon(AbCon *abcon, AbstractType ab)
{
  OID abOID = OIDOf(ab);
  if (!sameOID(abOID, (*abcon)->d.abOID)) {
    *abcon = findAbCon(abOID, (*abcon)->d.conOID);
  }
}
#endif

char *OIDString( OID o )
{
  static char buf[5][60];
  static int i = 0;
  char *rval;

  rval = buf[i]; i = (i+1) % 5;
  sprintf( rval, "%08x.%04x.%04x.%08x", o.ipaddress, o.port,
                                        o.epoch, o.Seq );
  return rval;
}

OID FOIDOf(Object o)
{
  OID r = OIDOf(o);
  if (isNoOID(r)) {
    NewOID(&r);
    OIDInsert(r, o);
  }
  return r;
}
@


1.11
log
@Re-sized the object table yet again.
@
text
@d24 5
a28 1
#define OBJECTTABLESIZE 101
d44 1
a44 1
  ObjectTable = OTableCreateN(4*1024);
d66 1
a66 2
    ftrace("Botch:  %#x != %#x", (u32)old , (u32)o);
    assert(0);
a91 1
      ConcreteType oldct = CODEPTR(old->flags);
d94 2
a95 1
		     oldct->d.name->d.items, oldct->d.name->d.data));
@


1.10
log
@Change the default size of the object table
@
text
@d40 1
a40 1
  ObjectTable = OTableCreateN(2*1024);
@


1.9
log
@Cleanups to remove useless leftover drivel found by cxref
@
text
@d40 1
a40 1
  ObjectTable = OTableCreateN(10240 * 2);
@


1.8
log
@Reimplemented the object table
@
text
@d62 1
a62 1
    fprintf(stderr, "Botch:  %#x != %#x\n", (u32)old , (u32)o);
a144 16
 * Get an object, given its sequence offset.  Callers of this routine should
 * be modified to use the entire OID.
 */

Object OIDFetchSeq(unsigned id)
{
  OID oid;
  Object o;

  oid = nooid;
  oid.Seq = id;
  o = OIDFetch(oid);
  return o;
}

/*
a146 1

d177 13
a203 12
int findOpByName(ConcreteType ct, char *name)
{
  int i, nops, len = strlen(name);
  nops = ct->d.opVector->d.items;
  for (i = 3; i < nops; i++) {
    OpVectorElement e = ct->d.opVector->d.data[i];
    if (e->d.name->d.items == len && !memcmp(e->d.name->d.data, name, len))
      return i;
  }
  return -999999;
}

d261 1
@


1.7
log
@Eradicated all vestiges of the old TRACE0-7 macros
@
text
@d24 1
a24 2
#define OIDTOOBJECTTABLESIZE 101
#define OBJECTTOOIDTABLESIZE OIDTOOBJECTTABLESIZE
d26 1
a26 2
OISc OIDToObjectTable;
IOSc ObjectToOIDTable;
d36 1
a36 1
 * Initialize the OIDToObjectTable and the ObjectToOIDTable
d40 1
a40 2
  OIDToObjectTable = OIScCreateN(10240 * 2);
  ObjectToOIDTable = IOScCreateN(10240 * 2);
d44 1
a44 1
 * Add entries to both OIDToObjectTable and ObjectToOIDTable
a51 1
  assert(OIDToObjectTable->count == ObjectToOIDTable->count);
d53 1
a53 2
  OIScInsert(OIDToObjectTable, oid, (int)o);
  IOScInsert(ObjectToOIDTable, (int)o, oid);
a54 1
  assert(OIDToObjectTable->count == ObjectToOIDTable->count);
d59 1
d65 1
d69 1
a69 3
  IOScDelete(ObjectToOIDTable, (int)o);
  OIScDelete(OIDToObjectTable, oid);
  assert(OIDToObjectTable->count == ObjectToOIDTable->count);
d74 1
a74 1
  OID hisoid = IOScLookup(ObjectToOIDTable, (int)o);
d77 1
a77 2
    IOScDelete(ObjectToOIDTable, (int)o);
    OIScDelete(OIDToObjectTable, hisoid);
d87 8
a94 6
  if (!ISNIL(old) && old != o) {
    ConcreteType oldct = CODEPTR(old->flags);
    TRACE(oid, 0, ("Defining an id that already exists %s -> %#x, a %.*s",
	  OIDString(oid), old, oldct->d.name->d.items, oldct->d.name->d.data));
    IOScDelete(ObjectToOIDTable, (int)old);
    OIScDelete(OIDToObjectTable, oid);
d106 1
a106 2
  IOScDelete(ObjectToOIDTable, (int)oldo);
  IOScInsert(ObjectToOIDTable, (int)newo, oid);
@


1.6
log
@More reliable process management, got xforms working
@
text
@d137 2
a138 2
  TRACE2(relocation, 1, "Found object %#x for which %d relocations exist",
	 id.Seq, ISetSize(relocations));
@


1.5
log
@'.'
@
text
@d42 2
a43 2
  OIDToObjectTable = OIScCreateN(10240);
  ObjectToOIDTable = IOScCreateN(10240);
@


1.4
log
@'./vm/src'
@
text
@d42 2
a43 2
  OIDToObjectTable = OIScCreate();
  ObjectToOIDTable = IOScCreate();
@


1.3
log
@'./vm/src'
@
text
@d13 2
a14 4
#pragma warning(disable: 4068)
#pragma pointer_size long
#include <stdio.h>
#pragma pointer_size short
d30 1
a30 1
static Bits16        NextOIDEpoch = 0;
d54 3
a56 1
  TRACE(oid, 5, ("Inserting %#x with OID %s", o, OIDString(oid)));
d70 1
a70 1
  TRACE(oid, 5, ("Removing id from %#x %s", o, OIDString(oid)));
d85 1
d94 1
a94 1
  if (!ISNIL(old)) {
d96 1
a96 1
    TRACE(oid, 2, ("Defining an id that already exists %s -> %#x, a %.*s",
d99 1
a100 3

  TRACE2(oid, 1, "Defining object %#x with OID %s", o, OIDString(oid));
  SETHASOID(o->flags);
d172 3
a174 3
  theOID->IPAddress = MyBaseOID.IPAddress;
  theOID->EmeraldInstance = MyBaseOID.EmeraldInstance;
  theOID->Epoch = MyBaseOID.Epoch;
d177 1
a177 1
    NextOIDEpoch++;
d179 1
a179 1
    theOID->Epoch = NextOIDEpoch;
d188 3
a190 3
  return ((oid1.IPAddress == oid2.IPAddress) &&
         (oid1.EmeraldInstance == oid2.EmeraldInstance) &&
	 (oid1.Epoch == oid2.Epoch) && (oid1.Seq == oid2.Seq));
d291 2
a292 2
  sprintf( rval, "%08x.%04x.%04x.%08x", o.IPAddress, o.EmeraldInstance,
                                        o.Epoch, o.Seq );
@


1.2
log
@Checkpoint
@
text
@d13 1
d53 3
d60 1
d70 1
a70 1
  TRACE(oid, 5, ("Removing id %s from %#x", OIDString(oid), o));
d75 1
@


1.1
log
@Initial revision
@
text
@d65 1
a65 1
  TRACE(oid, 5, ("Removing id from %#x %s", o, OIDString(oid)));
d105 1
@
