head	1.17;
access;
symbols
	105alpha:1.16
	104alpha:1.13
	103alpha:1.10
	102alpha:1.9
	101alpha:1.8
	100alpha:1.7;
locks; strict;
comment	@ * @;


1.17
date	2007.06.11.02.35.58;	author norm;	state Exp;
branches;
next	1.16;

1.16
date	99.02.22.22.20.56;	author norm;	state Exp;
branches;
next	1.15;

1.15
date	98.06.24.16.14.00;	author norm;	state Exp;
branches;
next	1.14;

1.14
date	98.06.09.15.33.03;	author norm;	state Exp;
branches;
next	1.13;

1.13
date	98.05.22.15.49.12;	author norm;	state Exp;
branches;
next	1.12;

1.12
date	98.05.08.19.38.21;	author norm;	state Exp;
branches;
next	1.11;

1.11
date	98.05.04.19.19.45;	author norm;	state Exp;
branches;
next	1.10;

1.10
date	98.05.01.07.21.05;	author norm;	state Exp;
branches;
next	1.9;

1.9
date	98.04.20.13.19.44;	author norm;	state Exp;
branches;
next	1.8;

1.8
date	98.04.08.21.45.27;	author norm;	state Exp;
branches;
next	1.7;

1.7
date	98.04.04.20.08.38;	author norm;	state Exp;
branches;
next	1.6;

1.6
date	98.03.24.16.25.58;	author norm;	state Exp;
branches;
next	1.5;

1.5
date	98.03.02.16.37.40;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	98.02.23.16.20.39;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	98.02.13.19.53.20;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	98.02.09.17.55.17;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	97.01.21.23.59.53;	author norm;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Check in current version
@
text
@/* move.c - support for method invocation on remote objects
 * $Id: move.c,v 1.18 1999/05/06 12:47:06 norm Exp $
 */

#define E_NEEDS_STRING
#define E_NEEDS_IOV
#include "system.h"

#include "assert.h"
#include "bufstr.h"
#include "builtins.h"
#include "creation.h"
#include "dist.h"
#include "gc.h"
#include "globals.h"
#include "move.h"
#include "oidtoobj.h"
#include "read.h"
#include "remote.h"
#include "streams.h"
#include "trace.h"
#include "vm_exp.h"
#include "write.h"

IISc fixedMap;

static int misdigit(int c)
{
  return ('0' <= c && c <= '9');
}

int sizeFromTemplate(Template t)
{
  int count, size = 0, totalsize = 0;
  char c, *brands;

  if (ISNIL(t)) return 0;

  brands = (char *)t->d.data;
  while(*brands != '\0') {
    switch (*brands++) {
    case '%':
      count = 0;
      while (misdigit(c = *brands++)) {
	count = count * 10 + c-'0';
      }
      if (!count) count = 1;
      assert(c != '*');
      switch(c) {
      case 'm':
	assert(count == 1);
	size = 8;
	break;
      case 'X':
      case 'x':
      case 'D':
      case 'd':
      case 'F':
      case 'f':
	size = 4;
	break;
      case 'C':
      case 'c':
      case 'B':
      case 'b':
	size = 4;
	break;
      case 'V':
      case 'v':
	size = 8;
	break;
      case 'l':
      case 'L':
      case 'q':
	TRACE(rinvoke, 0, ("Brand %c can't appear in an activation record", c));
	assert(0);
	break;
      default:
	TRACE(rinvoke, 0, ("can't figure brand %c", c));
	assert(0);
      }
      totalsize += count * size;
      break;
    default:
      TRACE(rinvoke, 0, ("What is '%c' doing in a template?", brands[-1]));
      assert(0);
      break;
    }
  }
  return totalsize;
}

#ifdef DISTRIBUTED

extern int receivingObjects;
extern Object createStub(ConcreteType ct, void *stub, OID oid);

void handleMove3rdPartyRequest(RemoteOpHeader *h, Node srv, Stream str)
{
  Object o;
  Node newsrv;
  Stream newstr;

  TRACE(rinvoke, 3, ("Move3rdPartyRequest received"));
  o = OIDFetch(h->target);
  ReadNode(&newsrv, str);
  TRACE(rinvoke, 5, ("Move3rd: move %s to %s", OIDString(h->target),
		     NodeString(newsrv)));
  if (!ISNIL(o) && RESDNT(o->flags)) {
    if (SameNode(newsrv, getMyLoc())) {
      TRACE(rinvoke, 4, ("The object is already here, keeping it"));
      if (h->option1) fixHere(o);
      moveDone(stateFetch(h->ss, h->sslocation), h, 0);
    } else if (isFixedHere(o) && h->option1 != 2) {
      TRACE(rinvoke, 4, ("The object is fixed here, failing"));
      moveDone(stateFetch(h->ss, h->sslocation), h, 1);
    } else {
      TRACE(rinvoke, 4, ("The object is here, sending it to %s", NodeString(newsrv)));
      move(h->option1, o, newsrv, stateFetch(h->ss, h->sslocation));
    }
  } else if (!ISNIL(o)) {
    Node forwardto = getLocFromObj(o);
    TRACE(rinvoke, 4, ("Forwarding request to %s", NodeString(forwardto)));
    if (forwardMsg(forwardto, h, str) < 0) {
      RewindStream(str);
      newstr = StealStream(str);
      findAndSendTo(h->target, newstr);
    }
  } else {
    /*
     * First generate a stub, and then try to find the object and send this on.
     */
    ConcreteType ct = (ConcreteType)doObjectRequest(srv, &h->targetct, ctct);
    o = createStub(ct, limbonode, h->target);
    RewindStream(str);
    newstr = StealStream(str);
    findAndSendTo(h->target, newstr);
  }
}

State *extractActivation(Object, ConcreteType, Stream, Node);

void handleMoveRequest(RemoteOpHeader *h, Node srv, Stream str)
{
  ConcreteType ct;
  RemoteOpHeader replyh;
  Stream reply;  StreamByte *buf;
  Object o;
  int wasPresent;

  anticipateGC(64 * 1024 + 2 * StreamLength(str));
  TRACE(rinvoke, 3, ("MoveRequest received"));

  TRACE(rinvoke, 6, ("Checking for CT for incoming object"));
  ct = (ConcreteType) doObjectRequest(srv, &h->targetct, ctct);
  assert(! ISNIL(ct));

  TRACE(rinvoke, 4, ("Received object with ID %s", OIDString(h->target)));
  wasPresent = !ISNIL(OIDFetch(h->target));

  o = ExtractObjects(str, srv);

  assert(o == OIDFetch(h->target));
  TRACE(rinvoke, 6, ("Received object is at address %#x", o));
  if (h->option2) freeze(o, RInitially);
  if (wasPresent) { 
    /* We already had this object, make sure it gets marked as resident */
    TRACE(rinvoke, 6, ("Thawing %#x", o));
    thaw(o, RRemote);
  }
  if (h->option1) {
    TRACE(rinvoke, 3, ("Fixing %#x, %s here", o, OIDString(OIDOf(o))));
    fixHere(o);
  }
  
  while (1) {
    buf = ReadStream(str, 4);
    if (!memcmp(buf, "ACT!", 4)) {
      /* Suck out an activation record - argh! */
      TRACE(rinvoke, 6, ("Incoming activation record!!"));
      (void)extractActivation(o, ct, str, srv);
    } else if (!memcmp(buf, "DONE", 4)) {
      break;
    } else {
      assert(0);
    }
  }
  if (!isNoOID(h->ss)) {
    State *state;
    state = stateFetch(h->ss, h->sslocation);
    if (!RESDNT(state->firstThing)) {
      replyh = *h;
      replyh.kind = MoveReply;
      replyh.status = 0;
      reply = StartMsg(&replyh);
      TRACE(rinvoke, 4, ("Send successful move reply to %s @@ %s",
			 OIDString(h->ss), NodeString(h->sslocation)));
      sendMsgTo(replyh.sslocation, reply, replyh.ss);
    } else {
      state->nstoid = nooid;
      TRACE(rinvoke, 4, ("Move done, informing state %s",
			 OIDString(h->ss)));
      assert(ISetMember(allProcesses, (int)state));
      makeReady(state);
    }
  }
  TRACE(rinvoke, 4, ("Move request done"));
  inhibit_gc--;
}
  
void findActivationsInObject(Object, Stream);

void movecpcallback(Object o)
{
  TRACE(rinvoke, 6, ("Moving %#x a %.*s, too",
		     o, CODEPTR(o->flags)->d.name->d.items,
		     CODEPTR(o->flags)->d.name->d.data));
  becomeStub(o, CODEPTR(o->flags), getNodeRecordFromSrv(ctsrv));
}

int move(int option1, Object obj, Node srv, State *state)
{
  Stream str;
  ConcreteType ct;
  RemoteOpHeader h;
  Node currentloc;
  noderecord *nr = getNodeRecordFromSrv(srv);

  if (!nr->up) {
    RemoteOpHeader h;
    TRACE(rinvoke, 2, ("Not moving %s to dead node %s", OIDString(OIDOf(obj)), NodeString(srv)));
    h.target = OIDOf(obj);
    h.targetct = OIDOf(CODEPTR(obj->flags));
    moveDone(state, &h, 1);
    return 0;
  }
  regRoot(obj);
  regRoot(state);
  anticipateGC(64 * 1024);
  unregRoot();
  unregRoot();
  ct = CODEPTR(obj->flags);

  
  h.kind = MoveRequest;
  h.option1 = option1;
  h.option2 = duringInitialization(obj);
  h.target = FOIDOf(obj);
  h.targetct = OIDOf(ct);
  if (state->op == obj) {
    h.ss = nooid;
    h.sslocation = myid;
  } else {
    h.ss = FOIDOf((Object)state);
    h.sslocation = getLocFromObj((Object)state);
    state->nstoid = h.target;
  }

  if (RESDNT(obj->flags)) {
    TRACE(rinvoke, 3, ("Moving %#x %s a %.*s from here to %s", obj,
		       OIDString(h.target),
		       ct->d.name->d.items, ct->d.name->d.data,
		       NodeString(srv));)
    str = StartMsg(&h);

    checkpointCallback = movecpcallback;
    checkpointCTCallback = ctcallback;
    checkpointCTIntermediateCallback = cticallback;
    ctstr = str;
    ctsrv = srv;
    Checkpoint(obj, ct, str);
    checkpointCallback = 0;
    ctstr = 0;
    memset(&ctsrv, 0, sizeof(ctsrv));
    memmove(WriteStream(str, 4), "DONE", 4);

    becomeStub(obj, ct, getNodeRecordFromSrv(srv));
    findActivationsInObject(obj, str);
    if (duringInitialization(obj)) thaw(obj, RInitially);

    sendMsg(srv, str);
  } else {
    /*
     * Send a message to the node holding the object, asking it to send
     * the object to the destination.  We'll do this like with invocations,
     * where we may get redirections.
     */
    h.kind = Move3rdPartyRequest;
    currentloc = getLocFromObj(obj);
    TRACE(rinvoke, 3, ("Asking %s to move %s a %.*s to %s",
		       NodeString(currentloc), OIDString(h.target),
		       ct->d.name->d.items, ct->d.name->d.data,
		       NodeString(srv)));
    str = StartMsg(&h);
    WriteNode(&srv, str);
    sendMsgTo(currentloc, str, h.target);
  }
  inhibit_gc--;
  return 0;
}

void handleMoveReply(RemoteOpHeader *h, Node srv, Stream str)
{
  Object obj = OIDFetch(h->target);
  State *state;

  TRACE(rinvoke, 4, ("Move done"));
  updateLocation(obj, srv);
  if (isNoOID(h->ss)) {
    /* This is for me, but there is no state waiting for the result */
  } else {
    state = stateFetch(h->ss, h->sslocation);
    if (!RESDNT(state->firstThing)) {
      TRACE(rinvoke, 4, ("Forwarding move done to new ss location %s", 
			 NodeString(getLocFromObj((Object)state))));
      if (forwardMsg(getLocFromObj((Object)state), h, str) < 0) {
	Stream newstr;
	RewindStream(str);
	newstr = StealStream(str);
	findAndSendTo(h->ss, newstr);
      }
    } else {
      assert(ISetMember(allProcesses, (int)state));
      state->nstoid = nooid;
      if (!h->status || !debug(state, "Move failure")) {
	makeReady(state);
      }
    }
  }
}

ConcreteType buildSpoofCT(Template t, int size)
{
  ConcreteType ct;
  ConcreteType covct = BuiltinInstCT(COPVECTORI);

  ct = gc_malloc(sizeof *ct);
  SETRESDNT(ct->flags);
  SETCODEPTR(ct->flags, ctct);
  if (inDistGC()) SETDISTGC(ct->flags);
  ct->d.name = TrueString;
  ct->d.filename = TrueString;
  ct->d.template = t;
  ct->d.instanceSize = size;
  ct->d.instanceFlags = HASODPBIT;
  ct->d.opVector = (OpVector)CreateVector(covct, 3);
  return ct;
}

void sendNVars(Stream str, int n, int *args, Object ep, ConcreteType et)
{
  ConcreteType spoofvCT = BuiltinInstCT(VECTOROFANYI);
  Vector spoofv;
  OID oido;

  spoofv = (Vector) gc_malloc(sizeof(FirstThing) + sizeof(u32) + 8 * (n + 1));
  spoofv->d.items = n + 1;
  SETRESDNT(spoofv->flags);
  SETCODEPTR(spoofv->flags, spoofvCT);
  if (inDistGC()) SETDISTGC(spoofv->flags);

  *(Object *)spoofv->d.data = ep;
  *(ConcreteType *)(spoofv->d.data + 4) = et;
  memcpy(spoofv->d.data + 8, args, 8 * n);

  NewOID(&oido); OIDInsert(oido, (Object) spoofv);
  WriteOID(&oido, str);
  ctstr = str;
  checkpointCTCallback = ctcallback;
  checkpointCTIntermediateCallback = cticallback;
  Checkpoint((Object)spoofv, spoofvCT, str);
  ctstr = 0;
  memmove(WriteStream(str, 4), "DONE", 4);
  OIDRemove(oido, (Object)spoofv);
}

void extractNVars(Stream str, int n, int *args, Object *epp, ConcreteType *etp,
		  Node srv)
{
  Vector spoofv;
  OID oido;

  ReadOID(&oido, str);
  spoofv = (Vector) ExtractObjects(str, srv);
  spoofv = (Vector) OIDFetch(oido);

  OIDRemove(oido, (Object)spoofv);

  *epp = *(Object *)spoofv->d.data;
  *etp = *(ConcreteType *)(spoofv->d.data + 4);
  if (n >= 0) {
    assert(spoofv->d.items == n + 1);
    memcpy(args, spoofv->d.data + 8, 8 * n);
  } else {
    /* The caller didn't know how many there are, but they should be placed
     * before args
     */
    args -= (spoofv->d.items - 1) * 2;
    memcpy(args, spoofv->d.data + 8, (spoofv->d.items - 1) * 8);
  }
}

void sendNVarsAlone(Stream str, int n, int *args)
{
  ConcreteType spoofvCT = BuiltinInstCT(VECTOROFANYI);
  Vector spoofv;
  OID oido;

  spoofv = (Vector) gc_malloc(sizeof(FirstThing) + sizeof(u32) + 8 * n);
  spoofv->d.items = n;
  SETRESDNT(spoofv->flags);
  SETCODEPTR(spoofv->flags, spoofvCT);
  if (inDistGC()) SETDISTGC(spoofv->flags);

  memcpy(spoofv->d.data, args, 8 * n);

  NewOID(&oido); OIDInsert(oido, (Object) spoofv);
  WriteOID(&oido, str);
  ctstr = str;
  checkpointCTCallback = ctcallback;
  checkpointCTIntermediateCallback = cticallback;
  Checkpoint((Object)spoofv, spoofvCT, str);
  ctstr = 0;
  memmove(WriteStream(str, 4), "DONE", 4);
  OIDRemove(oido, (Object)spoofv);
}

void extractNVarsAlone(Stream str, int n, int *args, Node srv)
{
  Vector spoofv;
  OID oido;

  ReadOID(&oido, str);
  spoofv = (Vector) ExtractObjects(str, srv);
  spoofv = (Vector) OIDFetch(oido);

  OIDRemove(oido, (Object)spoofv);

  if (n >= 0) {
    assert(spoofv->d.items == n);
    memcpy(args, spoofv->d.data, 8 * n);
  } else {
    /* The caller didn't know how many there are, but they should be placed
     * before args
     */
    args -= spoofv->d.items * 2;
    memcpy(args, spoofv->d.data, spoofv->d.items * 8);
  }
}

void getPreviousState(State *state, OID *oidp, Node *locp)
{

  *oidp = state->psoid;
  if (!isNoOID(state->psoid)) {
    *locp = getLocFromObj((Object)stateFetch(state->psoid, limbo));
  } else {
    *locp = getMyLoc();
  }
}

/*
 * Return true if we added all of the activations (so we don't need the stack)
 * any more.
 */
int addActivations(State *state, Stream str, int ready)
{
  ConcreteType spoofCT = 0;
  int opindex = findOpVectorIndex(state->cp, state->pc);
  OpVectorElement ove = state->cp->d.opVector->d.data[opindex];
  int templateSize = sizeFromTemplate(ove->d.template);
  int nargsandress;
  Object spoof = 0;
  OID oido, oidct, prevstateoid, newstateoid;
  Node prevstatesrv;
  int result, howmany, pcoffset;
  
  pcoffset = state->pc - (u32)ove->d.code->d.data;
  if (pcoffset) {
    spoofCT = buildSpoofCT(ove->d.template, templateSize);
    spoof = gc_malloc(templateSize + sizeof(FirstThing));
    SETRESDNT(spoof->flags);
    SETCODEPTR(spoof->flags, spoofCT);
    if (inDistGC()) SETDISTGC(spoof->flags);
    memcpy(spoof->d, (void *)state->fp, templateSize);
  }
  memmove(WriteStream(str, 4), "ACT!", 4);
  WriteInt(ready, str);
  TRACE(rinvoke, 5, ("Adding activation for op %d in object %#x a %.*s",
		     opindex, state->op,
		     state->cp->d.name->d.items, state->cp->d.name->d.data));

  newstateoid = OIDOf(state);
  WriteOID(&state->nsoid, str);
  WriteOID(&state->nstoid, str);
  if (bottomStackFrame(state)) {
    /*
     * Don't bother coming back here, go to the previous one instead
     * Also, no need to allocate a new oid for the part of the stack 
     * left behind.
     */
    TRACE(rinvoke, 7, ("Nothing to come back to"));
    getPreviousState(state, &prevstateoid, &prevstatesrv);
    state->nsoid = nooid;
    state->nstoid = nooid;
    result = 1;
  } else {
    OIDRemoveAny((Object)state);
    /* Allocate an oid for the left over piece of the stack */
    NewOID(&prevstateoid);
    OIDInsert(prevstateoid, (Object)state);
    TRACE(rinvoke, 5, ("Splitting a stack created a state with OID %s", OIDString(prevstateoid)));
    state->nstoid = OIDOf(state->op);
    TRACE(process, 5, ("Setting nsoid in state %#x to %s", state, OIDString(newstateoid)));

    state->nsoid = newstateoid;
    prevstatesrv = getMyLoc();
    result = 0;
  }
  TRACE(rinvoke, 6, ("Return to state %s on %s", OIDString(prevstateoid),
	NodeString(prevstatesrv)));

  WriteOID(&newstateoid, str);
  WriteInt(opindex, str);
  WriteInt(pcoffset, str);

  WriteOID(&prevstateoid, str);
  WriteNode(&prevstatesrv, str);

  if (pcoffset) {
    howmany = !state->fp ? 0 :
      state->pc == (u32)ove->d.code->d.data ? 0 :
      (state->sp - state->fp - templateSize) / 8;
    WriteInt(howmany, str);
    if (howmany) sendNVarsAlone(str, howmany, (int *)(state->fp + templateSize));
    NewOID(&oidct); OIDInsert(oidct, (Object) spoofCT);
    NewOID(&oido); OIDInsert(oido, (Object) spoof);
    WriteOID(&oidct, str);
    WriteOID(&oido, str);

    ctstr = str;
    checkpointCTCallback = ctcallback;
    checkpointCTIntermediateCallback = cticallback;
    Checkpoint(spoof, spoofCT, str);
    ctstr = 0;
    memmove(WriteStream(str, 4), "DONE", 4);

    OIDRemove(oidct, (Object)spoofCT);
    OIDRemove(oido, spoof);
    recordSize(spoof, (templateSize + sizeof(FirstThing)) / 4);
  }
  nargsandress = ove->d.nargs + ove->d.nress;
  sendNVars(str, nargsandress, (int *)state->fp - 4 - 2 * nargsandress, state->ep, state->et);
  if (!result) performReturn(state);
  return result;
}

State *extractActivation(Object obj, ConcreteType ct, Stream str, Node srv)
{
  ConcreteType spoofCT;
  u32 opindex, pcoffset;
  OpVectorElement ove;
  int templateSize = 0, nargsandress, i, howmany, sp;
  Object spoof = 0;
  OID oido, oidct, prevstateoid, newstateoid, nsoid, nstoid;
  Node prevstatesrv;
  State *state, *prevstate;
  int *topress = 0, ready;

  ReadInt((u32 *)&ready, str);
  ReadOID(&nsoid, str);
  ReadOID(&nstoid, str);
  ReadOID(&newstateoid, str);
  ReadInt(&opindex, str);
  ReadInt(&pcoffset, str);
  ReadOID(&prevstateoid, str);
  ReadNode(&prevstatesrv, str);
  ove = ct->d.opVector->d.data[opindex];
  if (pcoffset) {
    templateSize = sizeFromTemplate(ove->d.template);

    spoofCT = buildSpoofCT(ove->d.template, templateSize);

    ReadInt((u32 *)&howmany, str);
    if (howmany) {
      topress = vmMalloc(howmany * 8);
      extractNVarsAlone(str, howmany, topress, srv);
    }

    ReadOID(&oidct, str);
    ReadOID(&oido, str);
    OIDInsert(oidct, (Object) spoofCT);

    spoof = ExtractObjects(str, srv);
    assert(spoof == OIDFetch(oido));
    OIDRemove(oidct, (Object)spoofCT);
    OIDRemove(oido, spoof);
  }
  nargsandress = ove->d.nargs + ove->d.nress;
  state = (State *)OIDFetch(newstateoid);
  if (ISNIL(state)) {
    /*
     * States get allocated ids, this one will get its real id 30 lines
     * from now.
     */
    state = newState(obj, ct);
    OIDRemoveAny((Object)state);
  } else {
    assert(!RESDNT(state->firstThing));
    setupState(state, obj, ct);
    if (!isNoOID(state->nsoid)) {
      TRACE(process, 0, ("Non resident state %#x %s with a nsoid",
			 state, OIDString(newstateoid)));
    }
  }
  state->nsoid = nsoid;
  state->nstoid = nstoid;

  extractNVars(str, nargsandress, (int *)state->sb, &state->ep, &state->et, srv);
  state->sp = state->sb + 2 * nargsandress * sizeof(int);

  pushBottomAR(state);

  sp = state->sp;
  if (pcoffset) {
    if (templateSize > 0) {
      int *args = (int *)spoof->d;
      for(i=0 ; i < templateSize / 4; i++) {
	PUSH(int, args[i]);
      }
    }
    recordSize(spoof, (templateSize + sizeof(FirstThing)) / 4);
  }

  /* set up the interpreter state */
  state->opp = ove;
  state->pc = (u32)ove->d.code->d.data + pcoffset;
  if (pcoffset && howmany) {
    for (i = 0; i < howmany * 2; i++) {
      PUSH(int, topress[i]);
    }
    vmFree(topress);
  }
  state->sp = (u32) sp;

  TRACE(rinvoke, 5, ("Got an activation %#x %s", state, OIDString(newstateoid)));
  OIDInsert(newstateoid, (Object)state);
  ISetInsert(allProcesses, (int)state);
  if (!isNoOID(prevstateoid)) {
    prevstate = stateFetch(prevstateoid, prevstatesrv);
    dependsOn(state, prevstate, ove->d.nress);
    prevstate->nstoid = OIDOf(obj);
  }
  if (ready) {
    TRACE(rinvoke, 5, ("Making the activation ready"));
    makeReady(state);
  } else {
    TRACE(rinvoke, 5, ("The activation is not runnable"));
  }
  return state;
}

void findActivationsInObject(Object obj, Stream str)
{
  State *state;
  ConcreteType ct = CODEPTR(obj->flags);
  extern ISet running;

  TRACE(rinvoke, 7, ("Looking for activations in %#x a %.*s", obj,
		     ct->d.name->d.items, ct->d.name->d.data));
  ISetForEach(allProcesses, state) {
    TRACE(rinvoke, 5, ("Looking at %x %s in %x", state,
		       OIDString(OIDOf((Object)state)), state->op));
    if (HASODP(state->cp->d.instanceFlags) && state->op == obj) {
      TRACE(rinvoke, 8, ("Found one"));
      if (addActivations(state, str, SQueueYank(ready, state) || ISetMember(running, (int)state))) {
	processMovedOut(state);
	/* Because processMovedOut removes the state from allProcesss
	 * we have to fudge with the index
	 */
	ISetxx_index --;
      }
    }
  } ISetNext();
  TRACE(rinvoke, 5, ("That is all"));
  memmove(WriteStream(str, 4), "DONE", 4);
}

void doIsFixed(Object obj, State *state, int option)
{
  Node srv;
  Stream str;
  RemoteOpHeader h;
  ConcreteType ct = CODEPTR(obj->flags);

  state->nstoid = OIDOf(obj);
  h.kind = IsFixedRequest;
  h.ss = FOIDOf((Object)state);
  h.sslocation = myid;
  h.target = OIDOf(obj);
  h.targetct = OIDOf(CODEPTR(obj->flags));
  h.option1 = option;
  srv = getLocFromObj(obj);

  /* push the header information */
  str = StartMsg(&h);
  TRACE(rinvoke, 3, ("Asking %s about fixedness of %#x %s a %.*s", obj,
		     NodeString(srv), OIDString(h.target),
		     ct->d.name->d.items, ct->d.name->d.data));

  sendMsgTo(srv, str, h.target);
}

void handleIsFixedRequest(RemoteOpHeader *h, Node srv, Stream str)
{
  int answer;
  Object op;
  State *state;

  op = OIDFetch(h->target);
  if (!ISNIL(op) && RESDNT(op->flags)) {
    if (h->option1 == 1) {
      unfixHere(op);
      answer = JNIL;
    } else {
      answer = isFixedHere(op);
    }
    state = stateFetch(h->ss, h->sslocation);
    isFixedDone(h, state, answer);
  } else {
    Node forwardto = getLocFromObj(op);
    TRACE(rinvoke, 4, ("Forwarding isfixed request to %s", NodeString(forwardto)));
    if (forwardMsg(forwardto, h, str) < 0) {
      Stream newstr;
      RewindStream(str);
      newstr = StealStream(str);
      findAndSendTo(h->target, newstr);
    }
  }
}

void handleIsFixedReply(RemoteOpHeader *h, Node srv, Stream str)
{
  unsigned int answer;
  State *state = (State *)OIDFetch(h->ss);
  ReadInt(&answer, str);
  if (RESDNT(state->firstThing)) {
    assert(ISetMember(allProcesses, (int)state));
    if (RESDNT(state->op->flags)) {
      if (!h->option1 && !ISNIL(answer)) {
#define sp state->sp
	PUSH(int, answer);
	PUSH(ConcreteType, BuiltinInstCT(BOOLEANI));
      }
      makeReady(state);
#undef sp
    } else {
      returnToForeignObject(state, answer);
    }
  } else {
    Node forwardto = getLocFromObj((Object)state);
    TRACE(rinvoke, 4, ("Forwarding isfixed request to %s", NodeString(forwardto)));
    if (forwardMsg(forwardto, h, str) < 0) {
      Stream newstr;
      RewindStream(str);
      newstr = StealStream(str);
      findAndSendTo(h->ss, newstr);
    }
  }
}

/*
 * The indicated node has failed, investigate the state of the any pending
 * remote requests that may be proceeding on that node.  
 */
void moveHandleDown(struct noderecord *nd)
{

}
#endif /* DISTRIBUTED */

void fixHere(Object o)
{
  assert(RESDNT(o->flags));
  if (!fixedMap) fixedMap = IIScCreate();
  IIScInsert(fixedMap, (int)o, 1);
}

void forgetIsFixedHere(Object o)
{
  if (fixedMap)
    IIScDelete(fixedMap, (int)o);
}

void unfixHere(Object o)
{
  assert(RESDNT(o->flags));
  if (fixedMap)
    IIScDelete(fixedMap, (int)o);
}

int isFixedHere(Object o)
{
  if (!fixedMap) fixedMap = IIScCreate();
  return IIScLookup(fixedMap, (int)o) == 1;
}
@


1.16
log
@Fixed a warning reported by the alpha compiler
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.15 1998/06/24 16:14:00 norm Exp norm $
d27 66
a331 65
static int misdigit(int c)
{
  return ('0' <= c && c <= '9');
}
u32 sizeFromTemplate(Template t)
{
  int count, size, totalsize = 0;
  char c, *brands;

  if (ISNIL(t)) return 0;

  brands = (char *)t->d.data;
  while(*brands != '\0') {
    switch (*brands++) {
    case '%':
      count = 0;
      while (misdigit(c = *brands++)) {
	count = count * 10 + c-'0';
      }
      if (!count) count = 1;
      assert(c != '*');
      switch(c) {
      case 'm':
	assert(count == 1);
	size = 8;
	break;
      case 'X':
      case 'x':
      case 'D':
      case 'd':
      case 'F':
      case 'f':
	size = 4;
	break;
      case 'C':
      case 'c':
      case 'B':
      case 'b':
	size = 4;
	break;
      case 'V':
      case 'v':
	size = 8;
	break;
      case 'l':
      case 'L':
      case 'q':
	TRACE(rinvoke, 0, ("Brand %c can't appear in an activation record", c));
	assert(0);
	break;
      default:
	TRACE(rinvoke, 0, ("can't figure brand %c", c));
	assert(0);
      }
      totalsize += count * size;
      break;
    default:
      TRACE(rinvoke, 0, ("What is '%c' doing in a template?", brands[-1]));
      assert(0);
      break;
    }
  }
  return totalsize;
}

d468 1
a468 1
  ConcreteType spoofCT;
d473 1
a473 1
  Object spoof;
d563 2
a564 2
  int templateSize, nargsandress, i, howmany, sp;
  Object spoof;
d636 1
@


1.15
log
@Remove the indication of pending move when the move completes
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.14 1998/06/09 15:33:03 norm Exp norm $
d742 1
a742 1
  int answer;
@


1.14
log
@Clean up move records when move completes
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.13 1998/05/22 15:49:12 norm Exp norm $
d503 2
@


1.13
log
@Detect and respond to more node failure conditions during locate and move
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.12 1998/05/08 19:38:21 norm Exp norm $
d134 1
d258 1
@


1.12
log
@Cleanups to remove useless leftover drivel found by cxref
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.11 1998/05/04 19:19:45 norm Exp $
d106 1
a106 1
    TRACE(rinvoke, 3, ("Fixing %#x, %s here", o, OIDOf(o)));
d473 11
a483 9
  int result, howmany;

  spoofCT = buildSpoofCT(ove->d.template, templateSize);
  spoof = gc_malloc(templateSize + sizeof(FirstThing));
  SETRESDNT(spoof->flags);
  SETCODEPTR(spoof->flags, spoofCT);
  if (inDistGC()) SETDISTGC(spoof->flags);
  memcpy(spoof->d, (void *)state->fp, templateSize);

d520 1
a520 1
  WriteInt(state->pc - (u32)ove->d.code->d.data, str);
d525 17
a541 14
  howmany = state->fp ? (state->sp - state->fp - templateSize) / 8 : 0;
  WriteInt(howmany, str);
  if (howmany) sendNVarsAlone(str, howmany, (int *)(state->fp + templateSize));

  NewOID(&oidct); OIDInsert(oidct, (Object) spoofCT);
  NewOID(&oido); OIDInsert(oido, (Object) spoof);
  WriteOID(&oidct, str);
  WriteOID(&oido, str);
  ctstr = str;
  checkpointCTCallback = ctcallback;
  checkpointCTIntermediateCallback = cticallback;
  Checkpoint(spoof, spoofCT, str);
  ctstr = 0;
  memmove(WriteStream(str, 4), "DONE", 4);
d543 4
a546 3
  OIDRemove(oidct, (Object)spoofCT);
  OIDRemove(oido, spoof);
  recordSize(spoof, (templateSize + sizeof(FirstThing)) / 4);
d574 4
a577 1
  templateSize = sizeFromTemplate(ove->d.template);
d579 5
a583 1
  spoofCT = buildSpoofCT(ove->d.template, templateSize);
d585 8
a592 4
  ReadInt((u32 *)&howmany, str);
  if (howmany) {
    topress = vmMalloc(howmany * 8);
    extractNVarsAlone(str, howmany, topress, srv);
a593 10

  ReadOID(&oidct, str);
  ReadOID(&oido, str);
  OIDInsert(oidct, (Object) spoofCT);

  spoof = ExtractObjects(str, srv);
  assert(spoof == OIDFetch(oido));
  OIDRemove(oidct, (Object)spoofCT);
  OIDRemove(oido, spoof);

d620 6
a625 4
  if (templateSize > 0) {
    int *args = (int *)spoof->d;
    for(i=0 ; i < templateSize / 4; i++) {
      PUSH(int, args[i]);
d627 1
a628 1
  recordSize(spoof, (templateSize + sizeof(FirstThing)) / 4);
d632 1
a632 1
  if (howmany) {
@


1.11
log
@Removed OutstandingMoves table, and resend msgs when forwardMsg fails
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.10 1998/05/01 07:21:05 norm Exp norm $
d311 1
a311 1
	fprintf(stderr, "Brand %c can't appear in an activation record", c);
d315 1
a315 1
	fprintf(stderr, "can't figure brand %c", c);
d321 1
a321 1
      fprintf(stderr, "What is '%c' doing in a template?\n", brands[-1]);
@


1.10
log
@Implemented isfixed and unfix remotely
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.9 1998/04/20 13:19:44 norm Exp $
a25 1
ISet outstandingMoves;
d58 5
a62 1
    forwardMsg(forwardto, h, str);
a124 1
    ISetDelete(outstandingMoves, (int)state);
d189 1
a189 1
    ISetInsert(outstandingMoves, (int)state);
a245 1
    ISetDelete(outstandingMoves, (int)state);
d249 6
a254 1
      forwardMsg(getLocFromObj((Object)state), h, str);
d718 6
a723 1
    forwardMsg(forwardto, h, str);
d748 6
a753 1
    forwardMsg(forwardto, h, str);
@


1.9
log
@Made unavailable much more reliable, move correctly moves attached objects
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.8 1998/04/08 21:45:27 norm Exp norm $
d47 5
a51 1
      moveDone(stateFetch(h->ss, h->sslocation), h);
d102 5
d165 1
a165 1
    moveDone(state, &h);
d238 1
a238 1
  TRACE(rinvoke, 4, ("Move successful"));
d246 1
a246 1
      TRACE(rinvoke, 4, ("Forwarding move success to new ss location %s", 
d251 3
a253 1
      makeReady(state);
d483 2
d548 1
a548 1
  OID oido, oidct, prevstateoid, newstateoid;
d554 2
a595 2
      state->nsoid = nooid;
      state->nstoid = nooid;
d598 3
d668 1
a668 1
void doIsFixed(Object obj, State *state)
d675 1
d681 1
a681 1

d701 6
a706 1
    answer = isFixedHere(op);
d708 1
a708 1
    isFixedDone(state, answer);
d724 1
d726 3
a728 2
      PUSH(int, answer);
      PUSH(ConcreteType, BuiltinInstCT(BOOLEANI));
d756 13
@


1.8
log
@More reliable process management, got xforms working
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.7 1998/04/04 20:08:38 norm Exp norm $
a26 1
extern IISc outstandingInvokes;
d37 1
a40 1
  assert(!ISNIL(o));
d44 1
a44 1
  if (RESDNT(o->flags)) {
d52 1
a52 1
  } else {
d56 9
d78 1
a78 1
  anticipateGC(64 * 1024);
d434 3
a436 3
  *oidp = state->nsoid;
  if (!isNoOID(state->nsoid)) {
    *locp = getLocFromObj((Object)stateFetch(state->nsoid, limbo));
d482 1
a483 2
    prevstateoid = OIDOf(state);
    OIDRemove(prevstateoid, (Object)state);
d487 4
a490 1
    IIScInsert(outstandingInvokes, (int)state, (int)state->op);
d578 6
d615 1
@


1.7
log
@Small fixes to locate and move
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.6 1998/03/24 16:25:58 norm Exp norm $
d132 1
d184 1
d188 1
a424 1
  whatnext *wn;
d426 4
a429 6
  wn = (whatnext *)IIScLookup(whattodonext, (int)state);
  if (IIScIsNIL(wn)) {
    *oidp = nooid;
    *locp = getMyLoc();
  } else if (wn->action == DoAnotherState) {
    *oidp = OIDOf(wn->state);
a430 5
  } else if (wn->action == DoRemoteReturn) {
    *oidp = OIDOf(wn->state);
    *locp = wn->loc;
  } else {
    assert(0);
a471 1
    IIScDelete(whattodonext, (int)state);
d598 1
a598 1
    dependsOn(state, prevstate, DoRemoteReturn, 0, ove->d.nargs, ove->d.nress);
@


1.6
log
@'.'
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.2 1998/02/06 15:52:13 norm Exp norm $
d27 1
d140 1
d142 8
d157 1
d477 1
a479 1
    extern IISc outstandingInvokes;
@


1.5
log
@'./vm/src'
@
text
@d10 1
a10 3
#include "vm_exp.h"
#include "globals.h"
#include "trace.h"
d13 4
d19 4
a23 6
#include "bufstr.h"
#include "dist.h"
#include "streams.h"
#include "gc.h"
#include "remote.h"
#include "move.h"
d26 1
d59 1
a59 1
void extractActivation(Object, ConcreteType, Stream, Node);
d94 1
a94 1
      extractActivation(o, ct, str, srv);
d102 17
a118 7
    replyh = *h;
    replyh.kind = MoveReply;
    replyh.status = 0;
    reply = StartMsg(&replyh);
    TRACE(rinvoke, 4, ("Send successful move reply to %s @@ %s",
		       OIDString(h->ss), NodeString(h->sslocation)));
    sendMsg(replyh.sslocation, reply);
d141 1
d144 1
d158 1
d196 1
a196 4
    if (sendMsg(currentloc, str) < 0) {
      TRACE(rinvoke, 0, ("move: sendMsg failed"));
      /* DOTO: fail */
    }
d213 1
d220 1
a220 5
      if (RESDNT(state->op->flags)) {
	makeReady(state);
      } else {
	returnToForeignObject(state);
      }
a224 3
#endif

#ifdef DISTRIBUTED
d459 2
a460 1
    /* Don't bother coming back here, go to the previous one instead
d513 1
a513 1
void extractActivation(Object obj, ConcreteType ct, Stream str, Node srv)
d593 1
a593 1
    dependsOn(state, prevstate, DoRemoteReturn, 0, ove->d.nress);
d601 1
d651 1
a651 4
  if (sendMsg(srv, str) < 0) {
    TRACE(rinvoke, 0, ("doIsFixed: sendMsg failed"));
    /* TODO: What to do? */
  }
d656 14
d674 1
d676 4
a679 1
  assert(RESDNT(state->firstThing));
d681 3
a683 1
  PUSH(u32, h->status);
d685 17
a701 1
  makeReady(state);
d703 1
a703 1
#endif
@


1.4
log
@'./vm/src'
@
text
@d5 4
a8 12
#include <stdlib.h>
#pragma warning(disable: 4068)
#pragma pointer_size long
#include <sys/types.h>
#ifndef WIN32
#include <sys/time.h>
#include <netinet/in.h>
#endif /* not WIN32 */
#ifndef DOS
#include <netdb.h>
#endif
#pragma pointer_size short
d19 1
a19 1
#include "threads.h"
d27 1
a27 1
#ifdef USETHREADS
d32 1
a32 1
void handleMove3rdPartyRequest(RemoteOpHeader *h, vmThreadId srv, Stream str)
d35 1
a35 1
  vmThreadId newsrv;
d40 1
a40 1
  ReadThreadId(&newsrv, str);
d42 1
a42 1
		     ThreadIdString(newsrv)));
d44 1
a44 1
    if (vmSameThread(newsrv, getMyLoc())) {
d48 1
a48 1
      TRACE(rinvoke, 4, ("The object is here, sending it to %s", ThreadIdString(newsrv)));
d52 2
a53 2
    vmThreadId forwardto = getLocFromObj(o);
    TRACE(rinvoke, 4, ("Forwarding request to %s", ThreadIdString(forwardto)));
d58 1
a58 1
void extractActivation(Object, ConcreteType, Stream, vmThreadId);
d60 1
a60 1
void handleMoveRequest(RemoteOpHeader *h, vmThreadId srv, Stream str)
d62 2
d65 2
a66 3
  RemoteOpHeader replyh;
  Object o, oldo;
  ConcreteType ct;
d76 2
a77 1
  oldo = OIDFetch(h->target);
d79 1
d83 1
a83 1
  if (! ISNIL(oldo)) {
d85 2
a86 3
    TRACE(rinvoke, 6, ("Thawing %#x", oldo));
    assert(oldo == o);
    thaw(oldo, RRemote);
d106 1
a106 1
		       OIDString(h->ss), ThreadIdString(h->sslocation)));
d112 1
a112 1

d122 1
a122 1
int move(int option1, Object obj, vmThreadId srv, State *state)
d127 1
a127 1
  vmThreadId currentloc;
d141 1
a141 1
    h.sslocation = vmMyThreadId();
d151 1
a151 1
		       ThreadIdString(srv));)
d177 1
a177 1
		       ThreadIdString(currentloc), OIDString(h.target),
d179 1
a179 1
		       ThreadIdString(srv)));
d181 1
a181 1
    WriteThreadId(&srv, str);
d191 1
a191 1
void handleMoveReply(RemoteOpHeader *h, vmThreadId srv, Stream str)
d204 1
a204 1
			 ThreadIdString(getLocFromObj((Object)state))));
d219 2
a220 3
#ifdef USETHREADS
#undef isdigit
static int isdigit(int c)
d236 1
a236 1
      while (isdigit(c = *brands++)) {
d331 1
a331 1
		  vmThreadId srv)
d381 1
a381 1
void extractNVarsAlone(Stream str, int n, int *args, vmThreadId srv)
d404 1
a404 1
void getPreviousState(State *state, OID *oidp, vmThreadId *locp)
d436 1
a436 1
  vmThreadId prevstatesrv;
d453 1
a453 1
  if (bottomStackFrame(state) && noDependentThreads(state)) {
d474 1
a474 1
	ThreadIdString(prevstatesrv)));
d481 1
a481 1
  WriteThreadId(&prevstatesrv, str);
d507 1
a507 1
void extractActivation(Object obj, ConcreteType ct, Stream str, vmThreadId srv)
d515 1
a515 1
  vmThreadId prevstatesrv;
d519 1
a519 1
  ReadInt(&ready, str);
d524 1
a524 1
  ReadThreadId(&prevstatesrv, str);
d530 1
a530 1
  ReadInt(&howmany, str);
d558 1
a558 1
  extractNVars(str, nargsandress, (u32 *)state->sb, &state->ep, &state->et, srv);
d625 1
a625 1
  vmThreadId srv;
d632 1
a632 1
  h.sslocation = vmMyThreadId();
d641 1
a641 1
		     ThreadIdString(srv), OIDString(h.target),
d650 1
a650 1
void handleIsFixedRequest(RemoteOpHeader *h, vmThreadId srv, Stream str)
d654 1
a654 1
void handleIsFixedReply(RemoteOpHeader *h, vmThreadId srv, Stream str)
@


1.3
log
@Checkpoint
@
text
@d226 1
d469 1
d476 1
@


1.2
log
@Checkpoint
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.1 1997/01/21 23:59:53 norm Exp norm $
d5 2
d8 2
a9 1
#include <ctype.h>
a10 1
#include <sys/types.h>
d12 1
d75 1
a75 1
  int oldinh = anticipateGC(64 * 1024);
d116 1
a116 1
  inhibit_gc = oldinh;
a130 1
  int oldinh;
d136 1
a136 1
  oldinh = anticipateGC(64 * 1024);
d193 1
a193 1
  inhibit_gc = oldinh;
d226 4
d299 1
d319 1
d372 1
d418 1
a418 1
  } else if (wn->action == AnotherState) {
d421 1
a421 1
  } else if (wn->action == RemoteReturn) {
d449 1
d552 4
d557 1
d591 1
a591 1
    dependsOn(state, prevstate, RemoteReturn, 0, ove->d.nress);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id: move.c,v 1.4 1996/08/22 12:39:31 norm Exp norm $
d49 1
a49 1
    if (vmSameThreadHost(newsrv, getMyLoc())) {
d463 1
d477 1
a477 1
  howmany = (state->sp - state->fp - templateSize) / 8;
@
