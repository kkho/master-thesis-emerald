head	1.9;
access;
symbols
	105alpha:1.9
	104alpha:1.8
	103alpha:1.7
	102alpha:1.6
	101alpha:1.6
	100alpha:1.5;
locks; strict;
comment	@ * @;


1.9
date	99.02.22.22.24.47;	author norm;	state Exp;
branches;
next	1.8;

1.8
date	98.05.08.19.38.21;	author norm;	state Exp;
branches;
next	1.7;

1.7
date	98.04.30.20.46.11;	author norm;	state Exp;
branches;
next	1.6;

1.6
date	98.04.08.21.45.27;	author norm;	state Exp;
branches;
next	1.5;

1.5
date	98.03.24.16.25.58;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	98.03.11.22.43.33;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	98.03.02.16.37.40;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	98.02.23.16.20.39;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	97.01.21.23.59.53;	author norm;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Fixed a warning reported by the alpha compiler
@
text
@/*
 * Searchable Collections:
 *
 * Expanding hash tables with a key and data.
 */

#define E_NEEDS_STRING
#include "system.h"

#include "oisc.h"
#include "assert.h"
#include "trace.h"
#include "oidtoobj.h"

static unsigned oiscHash(unsigned char *key, int len);
static void ExpandHashTable(OISc sc);

#if !defined(USEPRIMESIZES)
static int sizes[] = {
  4, 8, 16, 32,
  64, 128, 256, 512,
  1024, 2048, 4096, 8192,
  16*1024, 32*1024, 64*1024, 128*1024,
  256*1024, 512*1024, 1024*1024, 2*1024*1024,
  4*1024*1024, 8*1024*1024, 16*1024*1024 };
#define Hash(key,sc) (oiscHash((unsigned char *)&key, sizeof(key)) & (sc->size - 1))
#else
static int sizes[] = {
  5, 7, 17, 31,
  67, 131, 257, 521,
  1031, 2053, 4099, 8093,
  16193, 32377, 65557, 131071,
  262187, 524869, 1048829, 2097223,
  4194371, 8388697, 16777291 };
#define Hash(key, sc) (oiscHash((char *)&key, sizeof(key)) % sc->size)
#endif

#define MAXFILL(x) (((x) * 17) / 20)
#define OFSIZE(x)  (x)

/*
 * Turning on DEBUGSC will cause the package to self-check on every (modifying)
 * operation.  The package runs very slowly when this is enabled.
 */


#ifdef DEBUGSC
static void CheckOutHashTable();
#define CHECKOUTHASHTABLE(sc) CheckOutHashTable(sc)
#else
#define CHECKOUTHASHTABLE(sc)
#endif

static int chooseSize(int size)
{
  int i;
  for (i = 0; sizes[i] <= size; i++) ;
  return sizes[i];
}

/* Return a new, empty OISc */
OISc OIScCreateN(int size)
{
  register int i;
  register OISc sc;

  sc = (OISc) vmMalloc(sizeof(OIScRecord));
  sc->size = chooseSize(size);
  sc->maxCount = MAXFILL(sc->size);
  sc->count = 0;
  sc->ofsize = OFSIZE(sc->size);
  sc->ofcount = 0;
  sc->table = (OIScTEPtr) vmMalloc((unsigned) OIScTSize(sc) * sizeof(OIScTE));
  for (i = 0; i < OIScTSize(sc); i++) {
    sc->table[i].value = OIScNIL;
  }
  for (i = sc->size; i < OIScTSize(sc) - 1; i++) {
    sc->table[i].chain = i + 1;
  }
  sc->of = sc->size;
  CHECKOUTHASHTABLE(sc);
  return sc;
}

OISc OIScCreate(void)
{
  return OIScCreateN(2);
}

/* Return a clone of the given OISc */
OISc OIScClone(OISc original)
{
  register OISc sc;

  sc = (OISc) vmMalloc(sizeof(OIScRecord));
  *sc = *original;
  sc->table = (OIScTEPtr) vmMalloc((unsigned) OIScTSize(sc) * sizeof(OIScTE));
  memmove(sc->table, original->table, (unsigned) OIScTSize(sc)*sizeof(OIScTE));
  CHECKOUTHASHTABLE(sc);
  return sc;
}

void OIScDestroy(sc)
register OISc sc;
{
  vmFree((char *)sc->table);
  vmFree((char *)sc);
}

/*
 * Insert the key, value pair in sc.  If the key already exists, change its 
 * value.
 */
static void IOIScInsert(OISc sc, OID a, OIScRangeType value)
{
  register int index;
  register OIScTEPtr e, ne;

  assert(!OIScIsNIL(value));
  if (sc->count >= sc->maxCount || sc->ofcount >= sc->ofsize) ExpandHashTable(sc);
  index = Hash(a, sc);
  e = &sc->table[index];
  if (OIScIsNIL(e->value)) {          /* put it here */
    e->key = a;
    e->value = value;
    e->chain = 0;
    sc->count++;
    return;
  }
  while (1) {
    if (OIScCOMPARE(e->key, a)) {
      e->value = value;
      return;
    } else if (e->chain) {
      e = &sc->table[e->chain];
    } else {
      assert(sc->of);
      e->chain = sc->of;
      ne = &sc->table[sc->of];
      sc->of = ne->chain;
      sc->ofcount++;
      ne->key = a;
      ne->value = value;
      ne->chain = 0;
      sc->count++;
      return;
    }
  }
}

/* Expand the hash table.  Each element in the table is re-hashed and entered 
 * in the new table. */
static void ExpandHashTable(OISc sc)
{
  register OISc newsc;
  register OIScTE *oe, *limit;

  newsc = OIScCreateN(sc->size+1);
  limit = &sc->table[OIScTSize(sc)];
  for (oe = &sc->table[0]; oe < limit; oe++) {
    if (OIScIsNIL(oe->value)) continue;
    IOIScInsert(newsc, oe->key, oe->value);
  }
  vmFree((char *)sc->table);
  *sc = *newsc;
  vmFree((char *)newsc);
  CHECKOUTHASHTABLE(sc);
}

/* Return the value associated with key in collection sc, or OIScNIL */
OIScRangeType OIScLookup(OISc sc, OID a)
{
  register int index = Hash(a, sc);
  register OIScTEPtr e;

  CHECKOUTHASHTABLE(sc);
  e = &sc->table[index];
  if (OIScIsNIL(e->value)) return OIScNIL;
  while (1) {
    if (OIScCOMPARE(e->key, a)) {
      return e->value;
    } else if (e->chain) {
      e = &sc->table[e->chain];
    } else {
      return OIScNIL;
    }
  }
}

void OIScInsert(OISc sc, OID a, OIScRangeType value)
{
  IOIScInsert(sc, a, value);
  CHECKOUTHASHTABLE(sc);
}

/* Remove the entry, if it is there */
void OIScDelete(OISc sc, OID a)
{
  register int index = Hash(a, sc);
  register OIScTEPtr e, prev = 0;

  e = &sc->table[index];
  if (OIScIsNIL(e->value)) return;
  while (1) {
    if (OIScCOMPARE(e->key, a)) {
      if (prev) {
	/*
	 * This is in the overflow area
	 */
	int tofree = e - &sc->table[0];
	prev->chain = e->chain;
	sc->table[tofree].chain = sc->of;
	sc->table[tofree].value = OIScNIL;
	sc->of = tofree;
	sc->ofcount--;
      } else if (e->chain) {
	int tofree = e->chain;
	*e = sc->table[tofree];
	sc->table[tofree].chain = sc->of;
	sc->table[tofree].value = OIScNIL;
	sc->of = tofree;
	sc->ofcount--;
      } else {
	e->value = OIScNIL;
      }
      sc->count--;
      return;
    } else {
      prev = e;
      e = &sc->table[e->chain];
    }
  }
}

/* DEBUGGING: Print the sc */
#define PrintOID(o) printf("%08x.%04x.%04x.%08x", \
			   o.ipaddress, o.port, o.epoch, o.Seq)

void OIScPrint(OISc sc)
{
  int index;
  register OIScTEPtr e;

  printf("Dump of sc @@ 0x%05x, %d entr%s, current max %d\n", 
	 (int)sc, sc->count, sc->count == 1 ? "y" : "ies",  sc->maxCount);
  printf("Index\tKey\t\t\t\t\tValue\n");
  for (index = 0; index < OIScTSize(sc); index++) {
    e = &sc->table[index];
    printf("%3d\t", index);
    PrintOID(e->key);
    printf("\t%08x\n", e->value);
  }
}

#ifdef DEBUGSC
/* DEBUGGING: Print the sc */
void OIScPrintF(OISc sc)
{
  int index;
  register OIScTEPtr e;

  TRACE(memory, 3, ("Dump of sc @@ 0x%05x, %d entr%s, current max %d", 
		     (int)sc, sc->count, sc->count == 1 ? "y" : "ies",  sc->maxCount));
  TRACE(memory, 3, ("Index\tKey\t\t\t\t\tValue"));
  for (index = 0; index < OIScTSize(sc); index++) {
    e = &sc->table[index];
    if (!OIScIsNIL(e->value)) {
      TRACE(memory, 3, ("%3d\t%s\t%08x",
			 index, OIDString(e->key), e->value));
    }
  }
}

/* Make sure that the hash table is internally consistent:
 *      every key is findable, 
 *      count reflects the number of elements
 */
void OIScCheckOutHashTable(OISc sc)
{
  register int i;
  register OIScTEPtr realE, e;
  register int index, firstIndex, count;
  int problemFound = 0;
  count = 0;

  for (i = 0; i < OIScTSize(sc); i++) {
    realE = &sc->table[i];
    if (!OIScIsNIL(realE->value)) {
      count++;
      index = Hash(realE->key, sc);
      firstIndex = index;
      e = &sc->table[index];
      while (1) {
	if (OIScIsNIL(e->value)) {              /* we did not find it */
	  problemFound ++;
	  fprintf(stderr, "Sc problem: Can't find (");
	  PrintOID(realE->key);
	  fprintf(stderr, ") -> %#x\n", realE->value);
	  fprintf(stderr, "  Hashes to index %d\n", firstIndex);
	  break;
	} else if (OIScCOMPARE(e->key, realE->key)) {
	  break;
	} else {
	  e = &sc->table[e->chain];
	}
      }
    }
  }  
  if (count != sc->count) {
    fprintf(stderr, "Sc problem: Should have %d entries, but found %d.\n", 
	    sc->count, count);
    problemFound ++;
  }
  if (problemFound) {
    OIScPrint(sc);
    abort();
  }
}
#endif

static unsigned oiscHash(unsigned char *key, int len)
{
  register unsigned h = 0, g;
  unsigned char *limit = key + len;
  for (; key < limit; key++) {
    h =  (h << 4) + (*key);
    if ((g = h & 0xf0000000)) {
      h = h ^ (g >> 24);
      h = h ^ g;
    }
  }
  return h;
}
@


1.8
log
@Cleanups to remove useless leftover drivel found by cxref
@
text
@d26 1
a26 1
#define Hash(key,sc) (oiscHash((char *)&key, sizeof(key)) & (sc->size - 1))
@


1.7
log
@Improved distgc tracing and fixed over-aggressive nature
@
text
@d255 1
d319 1
@


1.6
log
@More reliable process management, got xforms working
@
text
@d12 3
d252 18
@


1.5
log
@'.'
@
text
@d36 1
a36 1
#define OFSIZE(x)  (((x) * 5) / 20)
@


1.4
log
@Implement clone and use a better hash
@
text
@d13 1
d36 1
d51 7
d59 1
a59 1
OISc OIScCreate(void)
d65 1
a65 1
  sc->size = sizes[0];
d68 4
a71 2
  sc->table = (OIScTEPtr) vmMalloc((unsigned) sc->size * sizeof(OIScTE));
  for (i = 0; i < sc->size; i++) {
d74 4
d82 5
d94 2
a95 2
  sc->table = (OIScTEPtr) vmMalloc((unsigned) sc->size * sizeof(OIScTE));
  memmove(sc->table, original->table, (unsigned) sc->size * sizeof(OIScTE));
d107 41
d152 2
a153 3
  register OIScTE *nh, *oe, *ne;
  register int oldHashTableSize = sc->size, i;
  int index;
d155 3
a157 7
  for (i = 0; sizes[i] <= oldHashTableSize; i++) ;
  sc->size = sizes[i];
  sc->maxCount = MAXFILL(sc->size);
  nh = (OIScTEPtr) vmMalloc((unsigned)(sc->size * sizeof(OIScTE)));
  for (i = 0; i < sc->size; i++) nh[i].value = OIScNIL;
  for (i = 0; i < oldHashTableSize; i++) {
    oe = &sc->table[i];
d159 1
a159 12
    index = Hash(oe->key, sc);
    while (1) {
      ne = &nh[index];
      if (OIScIsNIL(ne->value)) {
	ne->key = oe->key;
	ne->value = oe->value;
	break;
      } else {
	index++;
	if (index >= sc->size) index = 0;
      }
    }
d162 2
a163 1
  sc->table = nh;
d174 2
d177 5
a181 2
    e = &sc->table[index];
    if (OIScIsNIL(e->value)) {          /* we did not find it */
a182 27
    } else if (OIScCOMPARE(e->key, a)) {
      return e->value;
    }
    if (++index >= sc->size) index = 0;
  }
}

/* Insert the key, value pair in sc.  If the key already exists, change its 
 * value. */
static void IOIScInsert(OISc sc, OID a, OIScRangeType value)
{
  register int index;
  register OIScTEPtr e;

  assert(!OIScIsNIL(value));
  if (sc->count >= sc->maxCount) ExpandHashTable(sc);
  index = Hash(a, sc);
  while (1) {
    e = &sc->table[index];
    if (OIScIsNIL(e->value)) {          /* put it here */
      e->key = a;
      e->value = value;
      sc->count++;
      return;
    } else if (OIScCOMPARE(e->key, a)) {
      e->value = value;
      return;
a183 1
    if (++index >= sc->size) index = 0;
d197 1
a197 3
  OIScDomainType key;
  register OIScRangeType value;
  register OIScTEPtr e;
d199 2
a201 5
    e = &sc->table[index];
    if (OIScIsNIL(e->value)) {          /* we did not find it */
      CHECKOUTHASHTABLE(sc);
      return;
    }
d203 18
a220 14
      /* Found it, now remove it */
      sc->count--;
      e->value = OIScNIL;
      while (1) {
	/* rehash until we reach nil again */
	if (++index >= sc->size) index = 0;
	e = & sc->table[index];
	if (OIScIsNIL(e->value)) {
	  CHECKOUTHASHTABLE(sc);
	  return;
	}
	/* rehashing is done by removing then reinserting */
	key = e->key;
	value = e->value;
a221 2
	sc->count--;
	IOIScInsert(sc, key, value);
d223 5
a228 1
    if (++index >= sc->size) index = 0;
d244 1
a244 1
  for (index = 0; index < sc->size; index++) {
d264 1
a264 1
  for (i = 0; i < sc->size; i++) {
d270 1
a271 1
	e = &sc->table[index];
a276 1
	  fprintf(stderr, "  Is at index %d\n", i);
a277 1
	  fprintf(stderr, "  Search to index %d doesn't find it\n", index);
d282 1
a282 3
	  index++;
	  if (index >= sc->size) index = 0;
	  assert (index != firstIndex);
@


1.3
log
@'./vm/src'
@
text
@d7 1
d12 1
d22 1
a22 1
#define Hash(key,sc) (OIScHASH(key) & (sc->size - 1))
d31 1
a31 1
#define Hash(key, sc) (OIScHASH(key) % sc->size)
d67 13
a227 1
#ifdef DEBUGSC
d232 1
a232 2
static void CheckOutHashTable(sc)
register OISc sc;
d277 14
a290 1
#endif
@


1.2
log
@'./vm/src'
@
text
@d7 2
a9 6

#pragma warning(disable: 4068)
#pragma pointer_size long
#include <stdio.h>
#pragma pointer_size short

d195 1
a195 1
			   o.IPAddress, o.EmeraldInstance, o.Epoch, o.Seq)
@


1.1
log
@Initial revision
@
text
@d9 1
d130 1
a130 1
void OIScInsert(OISc sc, OID a, OIScRangeType value)
a143 1
      CHECKOUTHASHTABLE(sc);
a146 1
      CHECKOUTHASHTABLE(sc);
d153 6
a180 1
	key = e->key;
d186 1
d190 1
a190 1
	OIScInsert(sc, key, value);
d248 1
a248 1
	} else if (OIScCOMPARE(e->key, realE->key.a)) {
d263 4
a266 1
  if (problemFound) OIScPrint(sc);
@
