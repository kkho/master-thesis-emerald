head	1.5;
access;
symbols
	105alpha:1.5
	104alpha:1.4
	103alpha:1.4
	102alpha:1.4
	101alpha:1.4
	100alpha:1.4;
locks; strict;
comment	@ * @;


1.5
date	98.06.24.16.14.41;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	98.03.24.16.25.58;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	98.03.02.16.37.40;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	98.02.23.16.20.39;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	97.01.21.23.59.53;	author norm;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Handle NIL Squeues since they can be nil before monitor initialization
@
text
@/* Generated by specialize genericqueue SQueue "struct State *"
 * Queues are a sequence of some domain.
 * Operations:
 *	create, destroy, insert, remove, insertfront, removeback, size, print
 *	foreach
 */

#ifndef _EMERALD_SQUEUE_H
#define _EMERALD_SQUEUE_H
/*
 * Before using this, one must define the following:
 *	SQueueDomainType	- a typedef for the domain
 */
typedef struct State * SQueueDomainType;

/*
 * Hidden, private type declarations.  The only thing
 * that applications of this package are to see is SQueue,
 * and they are to treat it as opaque:  that is, they may
 * assign it, and pass it as arguments, but not manipulate
 * what it points to directly.
 */

typedef struct SQueueRecord {
    SQueueDomainType *table;
    int size, first, count;
} SQueueRecord, *SQueue;

/* OPERATIONS */

/* Return a new, empty queue */
SQueue SQueueCreate(void);

/* Destroy a queue */
void SQueueDestroy(SQueue);

/* Insert the value at the rear of the queue */
void SQueueInsert(SQueue q, SQueueDomainType v);

/* Insert the value at the front of the queue */
void SQueueInsertFront(SQueue q, SQueueDomainType v);

/* Remove and return the value at the front of the queue */
SQueueDomainType SQueueRemove(SQueue q);

/* Remove and return the value at the back of the queue */
SQueueDomainType SQueueRemoveBack(SQueue q);

/* Remove a specific element from the SQueue, return 1 if found */
int SQueueYank(SQueue q, SQueueDomainType e);

/* DEBUGGING: Print the queue */
void SQueuePrint(SQueue q);

/* Iterate over the elements of the queue
 * At each iteration, SQueueValue is set to the next element
 * Usage:
 *	SQueueForEach(someSq, key) {
 *	  / * whatever you want to do with key * /
 *	} SQueueNext();
 */
#define SQueueForEach(q, value) \
  { \
    int SQueuexx_index, SQueuexx_count; \
    for (SQueuexx_index = (((q) && !ISNIL(q)) ? (q)->first: 0), SQueuexx_count = 0; \
	 SQueuexx_count < (((q) && !ISNIL(q)) ? (q)->count : 0); \
	 SQueuexx_count++, \
	 SQueuexx_index += \
	   (SQueuexx_index == (q)->size -1 ? -((q)->size - 1) : 1)) { \
      *(SQueueDomainType*)(&(value)) = (q)->table[SQueuexx_index]; \
      { 

#define SQueueNext() \
      } \
    } \
  }

/* Return the number of elements in SQueue */
#define SQueueSize(q) (((q) && !ISNIL(q)) ? (q)->count : 0)

#include "storage.h"

#endif /* _EMERALD_SQUEUE_H */
@


1.4
log
@'.'
@
text
@d65 2
a66 2
    for (SQueuexx_index = ((q) ? (q)->first: 0), SQueuexx_count = 0; \
	 SQueuexx_count < ((q) ? (q)->count : 0); \
d79 1
a79 1
#define SQueueSize(q) ((q) ? (q)->count : 0)
@


1.3
log
@'./vm/src'
@
text
@d65 2
a66 2
    for (SQueuexx_index = (q)->first, SQueuexx_count = 0; \
	 SQueuexx_count < (q)->count; \
d79 1
a79 1
#define SQueueSize(SQueue) ((SQueue)->count)
@


1.2
log
@'./vm/src'
@
text
@d81 1
a81 1
#include "memory.h"
@


1.1
log
@Initial revision
@
text
@d8 2
a9 2
#ifndef _SQUEUE_H
#define _SQUEUE_H
d83 1
a83 1
#endif
@
