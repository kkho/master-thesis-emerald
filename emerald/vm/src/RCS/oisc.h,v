head	1.7;
access;
symbols
	105alpha:1.7
	104alpha:1.7
	103alpha:1.7
	102alpha:1.6
	101alpha:1.6
	100alpha:1.6;
locks; strict;
comment	@ * @;


1.7
date	98.04.30.20.46.11;	author norm;	state Exp;
branches;
next	1.6;

1.6
date	98.03.24.16.25.58;	author norm;	state Exp;
branches;
next	1.5;

1.5
date	98.03.11.22.43.33;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	98.03.02.16.37.40;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	98.02.23.16.20.39;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	98.02.09.17.55.17;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	97.01.21.23.59.53;	author norm;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Improved distgc tracing and fixed over-aggressive nature
@
text
@/*
 * OIScs (searchable collections) are things that map 
 * pairs of oids onto ints.  Operations:
 *	create, destroy, insert, lookup, size, and print
 */

#ifndef __EMERALD_OISC_H
#define __EMERALD_OISC_H

#include "storage.h"
#include "types.h"

typedef OID OIScDomainType;
#define OIScRangeType  int
#define OIScHASH(X) ((unsigned) (((X).ipaddress) ^ (((X).Seq) << 0)))
#define OIScCOMPARE(K,X) (sameOID((K), (X)))
#define OIScNIL (JNIL)
#define OIScIsNIL(X) ((int)(X) == OIScNIL)
#define OIScTSize(sc) ((sc)->size + (sc)->ofsize)
/*
 * Hidden, private type declarations.  The only thing
 * that applications of this package are to see is OISc,
 * and they are to treat it as opaque:  that is, they may
 * assign it, and pass it as arguments, but not manipulate
 * what it points to directly.
 */

typedef struct OIScTE {
    OIScDomainType	 key;		/* the key for this entry */
    OIScRangeType	 value;		/* what we want */
    int			 chain;		/* overflow chain */
} OIScTE, *OIScTEPtr;

typedef struct OIScRecord {
    OIScTEPtr table;
    int size, maxCount, count, ofsize, ofcount, of;
} OIScRecord, *OISc;

/* OPERATIONS */

/* Return a new, empty Searchable Collection */
OISc OIScCreate(void);
OISc OIScCreateN(int);
OISc OIScClone(OISc original);

/* Destroy a collection */
void OIScDestroy(OISc sc);

/* Insert the pair <key, value> into collection OISc */
void OIScInsert(OISc sc, OID a, OIScRangeType value);

/* Delete the pair with key key from the collection OISc */
void OIScDelete(OISc sc, OID a);

/* Return the value associated with key in collection 
 * OISc, or OIScNIL if no such pair exists */
int OIScLookup(OISc sc, OID a);

/* DEBUGGING: Print the collection OISc */
void OIScPrint(OISc sc);
void OIScPrintF(OISc sc);

/* Iterate over the elements of the collection OISc.  
 * At each iteration, OISckey and OIScvalue are set to the next
 * <key, value> pair in the collection.  
 * Usage:
 *	OIScForEach(sc, key_a, value) {
 *	  / * whatever you want to do with key_a, key_b, value * /
 *	} OIScNext();
 */
#define OIScForEach(OISc, OISckey, OIScvalue) \
  { \
    int OIScxx_index; \
    for (OIScxx_index = 0; OIScxx_index < OIScTSize(OISc); OIScxx_index++) { \
      if (!OIScIsNIL((OISc)->table[OIScxx_index].value)) { \
	*(OID*)(&(OISckey)) = (OISc)->table[OIScxx_index].key; \
	*(OIScRangeType *)(&(OIScvalue)) = (OISc)->table[OIScxx_index].value; \
	{

#define OIScNext() \
	} \
      } \
    } \
  }

/* Iterate over the elements of the collection OISc backwards.  
 * At each iteration, OISckey and OIScvalue are set to the next
 * <key, value> pair in the collection.  
 * Usage:
 *	OIScForEachBackwards(sc, key_a, value) {
 *	  / * whatever you want to do with key_a, key_b, value * /
 *	} OIScNext();
 */
#define OIScForEachBackwards(OISc, OISckey, OIScvalue) \
  { \
    int OIScxx_index; \
    for (OIScxx_index = OIScTSize(OISc) - 1; OIScxx_index >= 0; OIScxx_index--) { \
      if (!OIScIsNIL((OISc)->table[OIScxx_index].value)) { \
	*(OID*)(&(OISckey)) = (OISc)->table[OIScxx_index].key; \
	*(OIScRangeType *)(&(OIScvalue)) = (OISc)->table[OIScxx_index].value; \
	{ 

#define OIScNext() \
	} \
      } \
    } \
  }

/* Return the number of elements in OISc */
#define OIScSize(OISc) ((OISc)->count)

#endif /* _EMERALD_OISC_H */
@


1.6
log
@'.'
@
text
@d61 1
@


1.5
log
@Implement clone and use a better hash
@
text
@d19 1
a19 1

d31 1
d36 1
a36 1
    int size, maxCount, count;
d43 1
d73 1
a73 1
    for (OIScxx_index = 0; OIScxx_index < (OISc)->size; OIScxx_index++) { \
d77 1
a77 1
	{ 
d96 1
a96 1
    for (OIScxx_index = (OISc->size - 1); OIScxx_index >= 0; OIScxx_index--) { \
@


1.4
log
@'./vm/src'
@
text
@d42 1
@


1.3
log
@'./vm/src'
@
text
@d10 1
a10 1
#include "memory.h"
d15 1
a15 1
#define OIScHASH(X) ((unsigned) (((X).IPAddress) ^ (((X).Seq) << 0)))
@


1.2
log
@Checkpoint
@
text
@d7 2
a8 2
#ifndef _OISC_H
#define _OISC_H
d108 1
a108 1
#endif /* OISc_h */
@


1.1
log
@Initial revision
@
text
@d82 23
@
