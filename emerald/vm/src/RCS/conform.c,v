head	1.5;
access;
symbols
	105alpha:1.5
	104alpha:1.5
	103alpha:1.4
	102alpha:1.3
	101alpha:1.3
	100alpha:1.3;
locks; strict;
comment	@ * @;


1.5
date	98.05.08.19.38.21;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	98.05.01.04.47.38;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	98.03.02.16.37.40;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	98.02.23.16.20.39;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	97.01.21.23.59.53;	author norm;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Cleanups to remove useless leftover drivel found by cxref
@
text
@#define E_NEEDS_STRING
#include "system.h"

#include "types.h"
#include "assert.h"
#include "ooisc.h"
#include "trace.h"
#include "globals.h"
#include "oidtoobj.h"

static OOISc assumeMap = 0;
static OOISc conformMap = 0;
static int iconforms(AbstractType, AbstractType, int);

int conforms(AbstractType a, AbstractType b)
{
  int res;
  assumeMap = OOIScCreate();
  res = iconforms(a, b, 0);
  OOIScDestroy(assumeMap);
  assumeMap = 0;
  return res;
}

static char *pad(int l)
{
  while (l-- > 0) {
    printf("  ");
  }
  return 0;
}

static int samename(ATOpVectorElement aove, ATOpVectorElement bove)
{
  return (aove->d.name->d.items == bove->d.name->d.items &&
	  VLen(aove->d.arguments) == VLen(bove->d.arguments) &&
	  !strncmp((char *)aove->d.name->d.data, 
		   (char *)bove->d.name->d.data,
		   bove->d.name->d.items));
}

#define DONE(x) { result = x; goto done; }

static int iconforms(AbstractType a, AbstractType b, int l)
{
  OID ao, bo;
  int result, i, j, k, found, foundincache = 0;
  ATOpVectorElement aove, bove;

  if (!conformMap) conformMap = OOIScCreate();
  assert(assumeMap);
  if (ISNIL(a) || ISNIL(b)) {
    TRACE(conform, 0, ("emx: conforms on nil type"));
    return 1;
  }

  ao = OIDOf(a);
  bo = OIDOf(b);
  TRACE(conform, 2, ((pad(l), "==> %.*s (%#x) vs %.*s (%#x)"), 
		     a->d.name->d.items,
		     a->d.name->d.data,
		     ao.Seq,
		     b->d.name->d.items,
		     b->d.name->d.data,
		     bo.Seq));
  l++;
  result = OOIScLookup(conformMap, ao, bo);
  if (result >= 0) {
    TRACE(conform, 2, ((pad(l), "Found answer in cache")));
    foundincache = 1;
    DONE(result);
  }
  result = OOIScLookup(assumeMap, ao, bo);
  if (result >= 0) {
    TRACE(conform, 2, ((pad(l), "We are assuming these conform")));
    DONE(result);
  }
  if (a == BuiltinInstAT(NILI)) {
    TRACE(conform, 2, ((pad(l), "%.*s is None"),
	   a->d.name->d.items,
	   a->d.name->d.data));
    DONE(1);
  }
  if (b == BuiltinInstAT(ANYI)) {
    TRACE(conform, 2, ((pad(l), "%.*s is Any"),
		       b->d.name->d.items,
		       b->d.name->d.data));
    DONE(1);
  } 
  if (b == BuiltinInstAT(NILI)) {
    TRACE(conform, 2, ((pad(l), "%.*s is None"),
		       b->d.name->d.items,
		       b->d.name->d.data));
    DONE(0);
  } 
  if (a == b) {
    TRACE(conform, 2, ((pad(l), "%.*s == %.*s"),
		       a->d.name->d.items,
		       a->d.name->d.data,
		       b->d.name->d.items,
		       b->d.name->d.data));
    DONE(1);
  } 
  if (EqOID(ao, bo)) {
    TRACE(conform, 2, ((pad(l), "%.*s = %.*s"),
		       a->d.name->d.items,
		       a->d.name->d.data,
		       b->d.name->d.items,
		       b->d.name->d.data));
    DONE(1);
  } 
  if (b->d.flags & AT_ISVECTOR) {
    if (!(a->d.flags & AT_ISVECTOR)) {
      TRACE(conform, 2, ((pad(l), "%.*s is a vector and %.*s is not"),
			 a->d.name->d.items,
			 a->d.name->d.data,
			 b->d.name->d.items,
			 b->d.name->d.data));
      DONE(0);
    }
  } else if (isNoNode(bo) && isBuiltinINSTAT(bo.Seq) &&
	     (bo.Seq == OIDOfBuiltin(B_INSTAT, BOOLEANI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, CHARACTERI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, INTEGERI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, NODEI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, SIGNATUREI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, REALI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, STRINGI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, TIMEI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, NODELISTELEMENTI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, NODELISTI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, INSTREAMI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, OUTSTREAMI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, BITCHUNKI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, CONCRETETYPEI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, COPVECTORI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, COPVECTOREI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, AOPVECTORI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, AOPVECTOREI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, APARAMLISTI) ||
	      bo.Seq == OIDOfBuiltin(B_INSTAT, INTERPRETERSTATEI))) {
    TRACE(conform, 2, ((pad(l), "%.*s is a cannot-be-conformed-to builtin"),
		       b->d.name->d.items,
		       b->d.name->d.data));
    DONE(0);
  } 
  if (b->d.flags & AT_ISIMMUTABLE
      && !a->d.flags & AT_ISIMMUTABLE) {
    TRACE(conform, 2, ((pad(l), "%.*s is not immutable"), 
		       a->d.name->d.items,
		       a->d.name->d.data));
    DONE(0);
  } 
  if (a->d.ops->d.items < b->d.ops->d.items) {
    TRACE(conform, 2, ((pad(l), "%.*s doesn't have enough operations"),
		       a->d.name->d.items,
		       a->d.name->d.data));
    DONE(0);
  }
  OOIScInsert(assumeMap, ao, bo, 1);
  for (i = 0; i < b->d.ops->d.items; i++) {
    bove = b->d.ops->d.data[i];
    found = 0;
    TRACE(conform, 4, ((pad(l-1), "Looking for operation %.*s[%d]"),
		       bove->d.name->d.items,
		       bove->d.name->d.data,
		       VLen(bove->d.arguments)));
    for (j = 0;
	 j < a->d.ops->d.items;
	 j++) {
      aove = a->d.ops->d.data[j];
      if (samename(aove, bove)) {
	if (bove->d.isFunction
	    && !aove->d.isFunction) {
	  TRACE(conform, 2, ((pad(l), "Operation %.*s[%d] is not a function"),
			     aove->d.name->d.items,
			     aove->d.name->d.data,
			     VLen(aove->d.arguments)));
	  DONE(0);
	}
	if (!ISNIL(aove->d.arguments)) {
	  for (k = 0; k < aove->d.arguments->d.items; k++) {
	    TRACE(conform, 4, ((pad(l-1), "Checking argument %d"), k));
	    if (!iconforms(bove->d.arguments->
			   d.data[k],
			   aove->d.arguments->
			   d.data[k], l+1)) {
	      TRACE(conform, 2, ((pad(l), "Operation %.*s[%d] argument %d doesn't conform"),
				 aove->d.name->d.items,
				 aove->d.name->d.data,
				 VLen(aove->d.arguments), k));
	      DONE(0);
	    }
	  }
	}
	if (!ISNIL(aove->d.results)) {
	  for (k = 0;
	       k < aove->d.results->d.items;
	       k++) {
	    TRACE(conform, 4, ((pad(l-1), "Checking result %d"), k));
	    if (!iconforms(aove->d.results->
			   d.data[k],
			   bove->d.results->
			   d.data[k], l+1)) {
	      TRACE(conform, 2, ((pad(l), "Operation %.*s[%d] result %d doesn't conform"),
				 aove->d.name->d.items,
				 aove->d.name->d.data, k));
	      DONE(0);
	    }
	  }
	}
	found = 1;
	break;
      }
    }
    if (!found) {
      TRACE(conform, 2, ((pad(l), "Operation %.*s[%d] is not defined"),
			 bove->d.name->d.items,
			 bove->d.name->d.data,
			 VLen(bove->d.arguments)));
      DONE(0);
    }
  }
  result = 1;
 done:
  l--;
  TRACE(conform, 2, ((pad(l), "<== %s"), result ? "yes" : "no"));
  if (l == 0 && !foundincache) {
    OOIScInsert(conformMap, ao, bo, result);
  }
  return result;
}

@


1.4
log
@Eradicated all vestiges of the old TRACE0-7 macros
@
text
@a0 3
/* comment me!
 */

d53 1
a53 1
    fprintf(stderr, "emx: conforms on nil type");
@


1.3
log
@'./vm/src'
@
text
@d62 7
a68 7
  TRACE6(conform, 2, (pad(l), "==> %.*s (%#x) vs %.*s (%#x)"), 
	 a->d.name->d.items,
	 a->d.name->d.data,
	 ao.Seq,
	 b->d.name->d.items,
	 b->d.name->d.data,
	 bo.Seq);
d72 1
a72 1
    TRACE0(conform, 2, (pad(l), "Found answer in cache"));
d78 1
a78 1
    TRACE0(conform, 2, (pad(l), "We are assuming these conform"));
d82 1
a82 1
    TRACE2(conform, 2, (pad(l), "%.*s is None"),
d84 1
a84 1
	   a->d.name->d.data);
d88 3
a90 3
    TRACE2(conform, 2, (pad(l), "%.*s is Any"),
	   b->d.name->d.items,
	   b->d.name->d.data);
d94 3
a96 3
    TRACE2(conform, 2, (pad(l), "%.*s is None"),
	   b->d.name->d.items,
	   b->d.name->d.data);
d100 5
a104 5
    TRACE4(conform, 2, (pad(l), "%.*s == %.*s"),
	   a->d.name->d.items,
	   a->d.name->d.data,
	   b->d.name->d.items,
	   b->d.name->d.data);
d108 5
a112 5
    TRACE4(conform, 2, (pad(l), "%.*s = %.*s"),
	   a->d.name->d.items,
	   a->d.name->d.data,
	   b->d.name->d.items,
	   b->d.name->d.data);
d117 5
a121 5
      TRACE4(conform, 2, (pad(l), "%.*s is a vector and %.*s is not"),
	     a->d.name->d.items,
	     a->d.name->d.data,
	     b->d.name->d.items,
	     b->d.name->d.data);
d145 3
a147 3
    TRACE2(conform, 2, (pad(l), "%.*s is a cannot-be-conformed-to builtin"),
	   b->d.name->d.items,
	   b->d.name->d.data);
d152 3
a154 3
    TRACE2(conform, 2, (pad(l), "%.*s is not immutable"), 
	   a->d.name->d.items,
	   a->d.name->d.data);
d158 3
a160 3
    TRACE2(conform, 2, (pad(l), "%.*s doesn't have enough operations"),
	   a->d.name->d.items,
	   a->d.name->d.data);
d167 4
a170 4
    TRACE3(conform, 4, (pad(l-1), "Looking for operation %.*s[%d]"),
	   bove->d.name->d.items,
	   bove->d.name->d.data,
	   VLen(bove->d.arguments));
d178 4
a181 4
	  TRACE3(conform, 2, (pad(l), "Operation %.*s[%d] is not a function"),
		 aove->d.name->d.items,
		 aove->d.name->d.data,
		 VLen(aove->d.arguments));
d186 1
a186 1
	    TRACE1(conform, 4, (pad(l-1), "Checking argument %d"), k);
d191 4
a194 4
	      TRACE4(conform, 2, (pad(l), "Operation %.*s[%d] argument %d doesn't conform"),
		     aove->d.name->d.items,
		     aove->d.name->d.data,
		     VLen(aove->d.arguments), k);
d203 1
a203 1
	    TRACE1(conform, 4, (pad(l-1), "Checking result %d"), k);
d208 3
a210 3
	      TRACE3(conform, 2, (pad(l), "Operation %.*s[%d] result %d doesn't conform"),
		     aove->d.name->d.items,
		     aove->d.name->d.data, k);
d220 4
a223 4
      TRACE3(conform, 2, (pad(l), "Operation %.*s[%d] is not defined"),
	     bove->d.name->d.items,
	     bove->d.name->d.data,
	     VLen(bove->d.arguments));
d230 1
a230 1
  TRACE1(conform, 2, (pad(l), "<== %s"), result ? "yes" : "no");
@


1.2
log
@'./vm/src'
@
text
@d4 3
@


1.1
log
@Initial revision
@
text
@d56 1
a56 1
  assert(HASOID(a->flags) && HASOID(b->flags));
@
