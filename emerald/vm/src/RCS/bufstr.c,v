head	1.7;
access;
symbols
	105alpha:1.7
	104alpha:1.7
	103alpha:1.5
	102alpha:1.5
	101alpha:1.4
	100alpha:1.3;
locks; strict;
comment	@ * @;


1.7
date	98.05.22.15.49.12;	author norm;	state Exp;
branches;
next	1.6;

1.6
date	98.05.08.19.37.48;	author norm;	state Exp;
branches;
next	1.5;

1.5
date	98.04.20.13.19.44;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	98.04.08.21.45.27;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	98.03.02.16.37.40;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	98.02.23.16.20.39;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	97.01.21.23.59.53;	author norm;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Detect and respond to more node failure conditions during locate and move
@
text
@/* bufstr.c - buffer stream using streams.c
 */

#define E_NEEDS_IOV
#include "system.h"

#include "assert.h"
#include "bufstr.h"
#include "storage.h"
#include "trace.h"

enum { INITIALWRITEBUFFERSIZE = 1024 };

static struct StreamConstructor rbs_constructor;
StreamConstructor ReadBufferStream = &rbs_constructor;
static int create_rbs( StreamBuffer buf, void **d );
static void seek_rbs( StreamBuffer buf, void **d, unsigned int where );
static int destroy_rbs( StreamBuffer buf, void **d );

static struct StreamConstructor fbs_constructor;
StreamConstructor FreeBufferStream = &fbs_constructor;
static int destroy_fbs( StreamBuffer buf, void **d );

static struct StreamConstructor wbs_constructor;
StreamConstructor WriteBufferStream = &wbs_constructor;
static int create_wbs( StreamBuffer buf, void **d );
static int flush_wbs( StreamBuffer buf, void **d );
static int destroy_wbs( StreamBuffer buf, void **d );

static struct StreamConstructor rbs_constructor = {
  Read,
  create_rbs,
  NULL,
  destroy_rbs,
  seek_rbs };

static struct StreamConstructor fbs_constructor = {
  Read,
  create_rbs,
  NULL,
  destroy_fbs,
  seek_rbs };

static struct StreamConstructor wbs_constructor = {
  Write,
  create_wbs,
  flush_wbs,
  destroy_wbs,
  NULL }; 
  
static int
create_rbs( StreamBuffer buf, void **d )
{
  struct iovec *iov;

  iov = (struct iovec*) vmMalloc( sizeof( struct iovec ) );
  if( iov == NULL ) { return -1; }
  *iov = *(struct iovec*)(*d); *d = (void*)iov;
  buf->Start = (StreamByte*) iov->iov_base;
  buf->End = buf->Start + iov->iov_len;
  buf->Head = buf->Start; buf->AtEOF = 1;
  buf->ValidBytes = iov->iov_len;
  return 0;
}

static void
seek_rbs( StreamBuffer buf, void **d, unsigned int pos )
{
  if( (int)pos > buf->ValidBytes ) FatalError("seek_rbs ");
  buf->Head = buf->Start + pos;
  buf->ValidBytes = buf->End - buf->Head;
}

static int
destroy_rbs( StreamBuffer buf, void **d )
{
  struct iovec *iov = (struct iovec*) (*d);
  vmFree( iov ); return 0;
}

static int
destroy_fbs( StreamBuffer buf, void **d )
{
  struct iovec *iov = (struct iovec*) (*d);
  vmFree( iov->iov_base ); vmFree( iov );
  return 0;
}

static int
create_wbs( StreamBuffer buf, void **d )
{
  struct iovec* iov;

  buf->Start = (StreamByte*) vmMalloc( INITIALWRITEBUFFERSIZE );
  if( buf->Start == NULL ) { return -1; }
  buf->End = buf->Start + INITIALWRITEBUFFERSIZE;
  buf->Head = buf->Start;
  buf->ValidBytes = 0;

  iov = (struct iovec*) vmMalloc( sizeof( struct iovec ) );
  if( iov == NULL ) { vmFree( buf->Start ); return -1; }
  iov->iov_base = (char *)buf->Start;
  iov->iov_len = INITIALWRITEBUFFERSIZE;
  *d = (void*)iov; return 0;
}

static int
flush_wbs( StreamBuffer buf, void **d )
{
  struct iovec *iov = (struct iovec*) (*d);
  int len = (int)buf->Start - (int)iov->iov_base + buf->ValidBytes;

  iov->iov_len *= 2;
  iov->iov_base = (void*) vmRealloc( iov->iov_base, iov->iov_len );
  assert( iov->iov_base != NULL );
  buf->Start = (StreamByte *)iov->iov_base + len;
  /* Head is decremented in FlushStream */
  buf->Head = buf->Start + buf->ValidBytes;
  buf->End = (StreamByte *)iov->iov_base + iov->iov_len;
  return buf->ValidBytes;
}

static int
destroy_wbs( StreamBuffer buf, void **d )
{
  struct iovec *iov;

  assert(d);
  TRACE(rinvoke, 15, ("destroy_wbs buf = %x, d = %x, *d = %x", buf, d, *d));
  iov = (struct iovec*) (*d);

  TRACE(rinvoke, 16, ("destroy_wbs iov->iov_base = %x", iov->iov_base));
  vmFree( iov->iov_base );
  vmFree( iov ); return 0;
}

void
BufferToIovec( Stream str, struct iovec *iov )
{
  StreamBuffer buf;
  struct iovec *iov0;

  GetStreamData( str, &buf, (void**) &iov0 );
  iov->iov_base = iov0->iov_base;
  iov->iov_len = (int)buf->Start - (int)iov0->iov_base + buf->ValidBytes;
}

int
BufferLength( Stream str )
{
  StreamBuffer buf;
  struct iovec *iov;

  GetStreamData( str, &buf, (void**) &iov );
  return (int)buf->Start - (int)iov->iov_base + buf->ValidBytes;
}

char *
BufferData( Stream str )
{
  StreamBuffer buf;
  struct iovec *iov;

  GetStreamData( str, &buf, (void**) &iov );
  return (char*) iov->iov_base;
}

Stream WriteToReadStream(Stream wStream, int dodestroy)
{
  Stream rStream;
  struct iovec wvec, rvec;
  BufferToIovec(wStream, &wvec);
  rvec.iov_base = malloc(wvec.iov_len);
  rvec.iov_len = wvec.iov_len;
  memcpy(rvec.iov_base, wvec.iov_base, rvec.iov_len);
  rStream = CreateStream(FreeBufferStream, &rvec);
  if (dodestroy) DestroyStream(wStream);
  return rStream;
}

/* EOF */
@


1.6
log
@Reply to stranded messages when a location fails to find the object
@
text
@d129 1
a129 1
  TRACE(rinvoke, 5, ("destroy_wbs buf = %x, d = %x, *d = %x", buf, d, *d));
d132 1
a132 1
  TRACE(rinvoke, 6, ("destroy_wbs iov->iov_base = %x", iov->iov_base));
@


1.5
log
@Made unavailable much more reliable, move correctly moves attached objects
@
text
@d168 1
a168 1
Stream WriteToReadStream(Stream wStream)
d175 1
d177 1
a177 1
  DestroyStream(wStream);
@


1.4
log
@More reliable process management, got xforms working
@
text
@d168 12
@


1.3
log
@'./vm/src'
@
text
@d10 1
d126 5
a130 1
  struct iovec *iov = (struct iovec*) (*d);
d132 1
@


1.2
log
@'./vm/src'
@
text
@d4 3
d9 1
a9 2
#include "memory.h"
#include "error.h"
d68 1
a68 1
  if( pos > buf->ValidBytes ) FatalError("seek_rbs ");
d101 1
a101 1
  iov->iov_base = buf->Start;
d115 1
a115 1
  buf->Start = (char *)iov->iov_base + len;
d118 1
a118 1
  buf->End = (char *)iov->iov_base + iov->iov_len;
@


1.1
log
@Initial revision
@
text
@d113 1
a113 1
  buf->Start = iov->iov_base + len;
d116 1
a116 1
  buf->End = iov->iov_base + iov->iov_len;
@
