head	1.5;
access;
symbols
	105alpha:1.5
	104alpha:1.5
	103alpha:1.4
	102alpha:1.3
	101alpha:1.3
	100alpha:1.3;
locks; strict;
comment	@ * @;


1.5
date	98.05.08.19.38.21;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	98.04.30.20.46.11;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	98.03.24.16.25.58;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	98.03.02.16.37.40;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	98.02.23.16.30.33;	author norm;	state Exp;
branches;
next	;


desc
@Inline extract functions.
@


1.5
log
@Cleanups to remove useless leftover drivel found by cxref
@
text
@#ifndef _EMERALD_EXTRACT_H
#define _EMERALD_EXTRACT_H

#ifndef _EMERALD_TYPES_H
#include "types.h"
#endif

#ifdef E_NEEDS_EXTRACT_BITS8
static inline void ExtractBits8(Bits8 *theByte, Bits8 *data)
{
  *theByte = *data;
}
#endif

#if defined(E_NEEDS_EXTRACT_BITS16) || defined(E_NEEDS_EXTRACT_NODE) || defined(E_NEEDS_EXTRACT_OID)
static inline void ExtractBits16(Bits16 *theWord, Bits8 *data)
{
  *theWord = ntohs(*((Bits16 *) data));
}
#endif

static inline void ExtractBits32(Bits32 *theLong, Bits8 *data)
{
  *theLong = ntohl(*((Bits32 *) data));
}

#ifdef E_NEEDS_EXTRACT_OID
static inline void ExtractOID(OID *theOID, Bits8 *data)
{
  ExtractBits32(&theOID->ipaddress, data);
  ExtractBits16(&theOID->port, data + 4);
  ExtractBits16(&theOID->epoch, data + 6);
  ExtractBits32(&theOID->Seq, data + 8);
}
#endif

extern void incomingRef(Object, int), incomingObject(Object);
extern void makeRefBlack(Object), makeRefGrey(Object);

#ifdef E_NEEDS_EXTRACT_OBJECT_DESCRIPTOR
static inline void ExtractObjectDescriptor(Object o, Bits8 *data)
{
  unsigned int newflags, finalflags;
  ExtractBits32(&newflags, data);
  finalflags = (o->flags & ALLBITS) | newflags;  
  /*
   * If we are dgcing, and the other side says the object is black,
   * and it was not resident before, then remove it from greys.
   */
  if (inDistGC() && !RESDNT(o->flags))
    if (DISTGC(newflags))
      makeRefBlack(o);
    else
      makeRefGrey(o);

    
  if (DISTGC(o->flags) && !DISTGC(newflags)) CLEARDISTGC(finalflags);
  TRACE(index, 2, ("EOD: %x was %x now %x", o, o->flags, finalflags));
  o->flags = finalflags;
}
#endif

#ifdef E_NEEDS_EXTRACT_NODE
static void ExtractNode(Node *t, Bits8 *data)
{
  /* No ntoh desired here */
  t->ipaddress = *(Bits32 *) data;
  ExtractBits16(&t->port, data + 4);
  ExtractBits16(&t->epoch, data + 6);
}
#endif

#endif /* _EMERALD_EXTRACT_H */
@


1.4
log
@Improved distgc tracing and fixed over-aggressive nature
@
text
@d4 4
@


1.3
log
@'.'
@
text
@d33 2
a34 1
extern void incomingRef(Object, int), incomingObject(Object, int);
d39 1
a39 1
  unsigned int newflags;
d41 15
a55 2
  TRACE(index, 2, ("EOD: %x was %x now %x", o, o->flags, (o->flags & ALLBITS) | newflags));
  o->flags = (o->flags & ALLBITS) | newflags;
@


1.2
log
@'./vm/src'
@
text
@d4 1
d9 1
d11 1
d16 1
d23 1
d31 1
d35 1
d43 1
d45 1
d53 1
@


1.1
log
@Initial revision
@
text
@d21 3
a23 3
  ExtractBits32(&theOID->IPAddress, data);
  ExtractBits16(&theOID->EmeraldInstance, data + 4);
  ExtractBits16(&theOID->Epoch, data + 6);
d37 1
a37 7
#ifdef USETHREADS

#ifndef _EMERALD_THREADS_H
#include "threads.h"
#endif

static void ExtractThreadId(vmThreadId *t, Bits8 *data)
d42 1
a42 1
  ExtractBits16(&t->incarnation, data + 6);
a43 1
#endif
@
