head	1.6;
access;
symbols
	105alpha:1.5
	104alpha:1.2
	103alpha:1.2
	102alpha:1.2
	101alpha:1.1
	100alpha:1.1;
locks; strict;
comment	@ * @;


1.6
date	2007.06.11.02.49.16;	author norm;	state Exp;
branches;
next	1.5;

1.5
date	99.02.22.22.26.52;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	99.01.22.00.24.43;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	98.06.03.07.38.36;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	98.04.15.04.28.18;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	98.03.30.19.36.41;	author norm;	state Exp;
branches;
next	;


desc
@Emerald interface to xforms.
@


1.6
log
@Check in current version
@
text
@#include "xforms.h"
#include "iisc.h"
#include "assert.h"
#include "dist.h"
#include "trace.h"

IISc freeobjtoextra;

Display *mfl_get_display(void)
{
  return fl_get_display();
}

int mfl_errorhandler(Display *display, XErrorEvent *ev)
{
  TRACE(x, 0, ("mfl_errorhandler was called"));
  printf("An X error happened\n");
  die();
  return 0;
}

void mfl_initialize(char *progname)
{
  int argc = 1;
  static int alreadyInitialized = 0;
#if defined(alpha)
#  pragma pointer_size long
#endif
  char *arg = "junk";
#if defined(alpha)
#  pragma pointer_size short
#endif

  if (!alreadyInitialized) {
    alreadyInitialized = 1;
    freeobjtoextra = IIScCreate();
    TRACE(x, 3, ("mfl_initialize %s", progname));
    fl_initialize(&argc, &arg, progname, 0, 0);
    XSetErrorHandler(mfl_errorhandler);
  }
}

void mfl_add_chart_value(FL_OBJECT * obj, float val, char *text, int col)
{
  TRACE(x, 3, ("mfl_add_chart_value %#x %g %s %d", obj, val, text, col));
  fl_add_chart_value(obj, (double)val, text, col);
}

void mfl_insert_chart_value(FL_OBJECT * obj, int index, float val, char *text, int col)
{
  fl_insert_chart_value(obj, index, (double)val, text, col);
}

void mfl_replace_chart_value(FL_OBJECT * obj, int index, float val, char *text, int col)
{
  fl_replace_chart_value(obj, index, (double)val, text, col);
}

void mfl_set_chart_bounds(FL_OBJECT * obj, float xmin, float xmax)
{
  fl_set_chart_bounds(obj, (double)xmin, (double)xmax);
}

void mfl_set_slider_value(FL_OBJECT * obj, float val)
{
  fl_set_slider_value(obj, (double)val);
}

int mfl_get_slider_value(FL_OBJECT * obj)
{
  float r = fl_get_slider_value(obj);
  return *(int *)&r;
}

void mfl_set_slider_step(FL_OBJECT * obj, float val)
{
  fl_set_slider_step(obj, (double)val);
}

void mfl_set_slider_size(FL_OBJECT * obj, float val)
{
  fl_set_slider_size(obj, (double)val);
}

void mfl_set_slider_bounds(FL_OBJECT * obj, float xmin, float xmax)
{
  fl_set_slider_bounds(obj, (double)xmin, (double)xmax);
}

void mfl_set_dial_value(FL_OBJECT * obj, float val)
{
  fl_set_dial_value(obj, (double)val);
}

int mfl_get_dial_value(FL_OBJECT * obj)
{
  float r = fl_get_dial_value(obj);
  return *(int *)&r;
}

void mfl_set_dial_step(FL_OBJECT * obj, float val)
{
  fl_set_dial_step(obj, (double)val);
}

void mfl_set_dial_bounds(FL_OBJECT * obj, float xmin, float xmax)
{
  fl_set_dial_bounds(obj, (double)xmin, (double)xmax);
}

void mfl_set_dial_angles(FL_OBJECT * obj, float xmin, float xmax)
{
  fl_set_dial_angles(obj, (double)xmin, (double)xmax);
}

void mfl_set_counter_value(FL_OBJECT * obj, float val)
{
  fl_set_counter_value(obj, (double)val);
}

int mfl_get_counter_value(FL_OBJECT * obj)
{
  float r = fl_get_counter_value(obj);
  return *(int *)&r;
}

void mfl_set_counter_step(FL_OBJECT * obj, float small, float large)
{
  fl_set_counter_step(obj, (double)small, (double)large);
}

void mfl_set_counter_bounds(FL_OBJECT * obj, float xmin, float xmax)
{
  fl_set_counter_bounds(obj, (double)xmin, (double)xmax);
}

int mfl_get_input_cursorxpos(FL_OBJECT *obj)
{
  int x, y;
  fl_get_input_cursorpos(obj, &x, &y);
  return x;
}

void mfl_set_timer(FL_OBJECT * obj, float val)
{
  fl_set_timer(obj, (double)val);
}

int mfl_get_timer(FL_OBJECT * obj)
{
  float r = fl_get_timer(obj);
  return *(int *)&r;
}

void mfl_flush(void)
{
  XFlush(fl_get_display());
}

void mfl_ringbell(void)
{
  XBell(fl_display, 0);
}

FL_OBJECT *mfl_do_forms(void)
{
  FL_OBJECT *changed;
  TRACE(x, 4, ("mfl_do_forms"));
  changed = fl_do_forms();
  TRACE(x, 5, ("mfl_do_forms returns %#x", changed));
  return changed;
}
  
typedef struct {
  unsigned int state;
  int first, full, processed;
  int changed;
  int event;
  FL_Coord mx, my;
  int key;
  void *xev;
} freeextra;

#define MFL_EVENT 1
#define MFL_MX 2
#define MFL_MY 3
#define MFL_KEY 4
#define MFL_CHANGED 5
#define MFL_X 6
#define MFL_Y 7
#define MFL_W 8
#define MFL_H 9

int mfl_free_fetch(FL_OBJECT *obj, int which)
{
  freeextra *fe = (freeextra *)IIScLookup(freeobjtoextra, (int)obj);
  assert(!IIScIsNIL(fe));

  TRACE(x, 5, ("mfl_free_fetch %#x %d", obj, which));
  
  switch(which) {
  case MFL_EVENT:
    return fe->event;
    break;
  case MFL_MX:
    return fe->mx;
    break;
  case MFL_MY:
    return fe->my;
    break;
  case MFL_KEY:
    return fe->key;
    break;
  case MFL_CHANGED:
    fe->changed = 1;
    return 0;
  case MFL_X:
    return obj->x;
    break;
  case MFL_Y:
    return obj->y;
    break;
  case MFL_W:
    return obj->w;
    break;
  case MFL_H:
    return obj->h;
    break;
  default:
    return -1;
    break;
  }
}

void mfl_free_wait(FL_OBJECT *obj, unsigned int *block)
{
  freeextra *fe = (freeextra *)IIScLookup(freeobjtoextra, (int)obj);
  assert(!IIScIsNIL(fe));
  TRACE(x, 5, ("mfl_free_wait %#x", obj));
  if (!fe->first) {
    fe->processed = 1;
  } else {
    fe->first = 0;
  }
  if (fe->full) {
    fe->full = 0;
    *block = 0;
  } else {
    fe->state = *block;
    *block = 1;
  }
}

int mfl_free_handler(FL_OBJECT *obj, int event, FL_Coord mx, FL_Coord my,
		     int key, void *xev)
{
  freeextra *fe = (freeextra *)IIScLookup(freeobjtoextra, (int)obj);
  if (IIScIsNIL(fe)) return 0;
  TRACE(x, 5, ("mfl_free_handler %#x %d %d %d %d", obj, event, mx, my, key));
  if (event == FL_MOTION && fe->mx == mx && fe->my == my) return 0;
  fe->changed = 0;
  fe->event = event;
  fe->mx = mx;
  fe->my = my;
  fe->key = key;
  fe->xev = xev;
  fe->processed = 0;
  if (fe->state) {
    fe->full = 0;
    makeReady(fe->state);
    fe->state = 0;
  } else {
    fe->full = 1;
  }
  while (!fe->processed) {
    processEverythingOnce();
  }
  fe->full = 0;
  return fe->changed;
}

FL_OBJECT *mfl_add_free(int type, FL_Coord x, FL_Coord y, FL_Coord w,
			  FL_Coord h, const char *label)
{
  FL_OBJECT *o;
  freeextra *fe;
  o = fl_add_free(type, x, y, w, h, label, mfl_free_handler);
  fe = (freeextra *)malloc(sizeof(freeextra));
  memset(fe, 0, sizeof *fe);
  fe->first = 1;
  IIScInsert(freeobjtoextra, (int)o, (int)fe);
  o->wantkey = FL_KEY_ALL;
  return o;
}

void mfl_set_text_clipping(FL_Coord x, FL_Coord y, FL_Coord w, FL_Coord h)
{
  fl_set_text_clipping(x, y, w, h);
}

void mfl_unset_text_clipping()
{
  fl_unset_text_clipping();
}

int mfl_get_width(FL_OBJECT *obj)
{
  FL_Coord w, h, x, y;
  fl_get_object_geometry(obj, &x, &y, &w, &h);
  return w;
}
@


1.5
log
@Several updates to the xforms interface
@
text
@d5 1
d16 1
d37 1
d45 1
d165 9
d198 2
d239 1
d258 2
a259 1
  assert (!IIScIsNIL(fe));
d282 1
a282 1
FL_OBJECT *mfl_create_free(int type, FL_Coord x, FL_Coord y, FL_Coord w,
d287 1
a287 1
  o = fl_create_free(type, x, y, w, h, label, mfl_free_handler);
@


1.4
log
@Fixed memset to clear whole structure, added get_width
@
text
@d17 1
d24 3
d28 4
@


1.3
log
@Removed reference to obsolete vmStats
@
text
@d264 1
a264 1
  memset(fe, 0, sizeof fe);
d279 7
@


1.2
log
@Make XForms free objects work
@
text
@a15 1
  vmStats();
@


1.1
log
@Initial revision
@
text
@d155 2
a156 2
  semaphore forevent;
  semaphore forreply;
a157 1
  int first;
d213 1
a213 3
extern void SNotUseful(void), SUseful(void);

int mfl_free_wait(FL_OBJECT *obj)
d218 1
a218 1
    MTSemV(&fe->forreply);
d222 7
a228 4
  SNotUseful();
  MTSemP(&fe->forevent);
  SUseful();
  return 1;
d243 12
a254 4
  MTSemV(&fe->forevent);
  SNotUseful();
  MTSemP(&fe->forreply);
  SUseful();
d265 1
a267 2
  MTSemInit(&fe->forevent, 0);
  MTSemInit(&fe->forreply, 0);
@
