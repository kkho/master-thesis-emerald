head	1.2;
access;
symbols
	105alpha:1.2
	104alpha:1.2
	103alpha:1.2
	102alpha:1.2
	101alpha:1.2
	100alpha:1.2
	DIKU_0:1.1;
locks; strict;
comment	@# @;


1.2
date	97.01.22.00.05.57;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	93.06.01.23.28.18;	author mueller;	state Exp;
branches;
next	;


desc
@Emerald compiler test
@


1.2
log
@Fix to use <- instead of ==, better tests of vectors
@
text
@const tboolean <- object tboolean
  const myTest <- runtest.create[stdin, stdout, "tboolean"]
  initially
    % each test looks like myTest.check[<boolean expression>, "<same exp>"]
    var i, j : Boolean
    i <- false
    myTest.check[i = false, "i = false"]
    myTest.check[i == false, "i == false"]
    myTest.check[false == false, "false == false"]
    i <- true
    myTest.check[i = true, "i = true"]
    myTest.check[i == true, "i == true"]
    myTest.check[true == true, "true == true"]
    i <- false
    j <- true
    myTest.check[i < j, "i < j"]
    myTest.check[i <= j, "i <= j"]
    myTest.check[j > i, "j > i"]
    myTest.check[j >= i, "j >= i"]
    j <- false
    myTest.check[i <= j, "i <= j"]
    myTest.check[i >= j, "i >= j"]
    i <- true
    j <- true
    myTest.check[i <= j, "i <= j"]
    myTest.check[i >= j, "i >= j"]

    i <- false
    j <- true    
    myTest.check[i | j, "i | j"]
    myTest.check[i or j, "i or j"]
    myTest.check[!i & j, "!i & j"]
    myTest.check[!i and j, "!i and j"]
    myTest.check[!i, "!i"]
    myTest.check[!false, "!false"]
    myTest.check[i.asString = "false", "i.asString = \"false\""]
    myTest.check[j.asString = "true", "j.asString = \"true\""]
    myTest.check[false.asString = "false", "false.asString = \"false\""]
    myTest.check[true.asString = "true", "true.asString = \"true\""]
    
    myTest.done
  end initially
end tboolean
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
  const myTest == runtest.create[stdin, stdout, "tboolean"]
@
