head	1.59;
access;
symbols
	105alpha:1.59
	104alpha:1.59
	103alpha:1.59
	102alpha:1.59
	101alpha:1.59
	100alpha:1.59
	DIKU_0:1.40
	carlton_start:1.33
	immel_start:1.15;
locks; strict;


1.59
date	98.04.04.20.09.31;	author norm;	state Exp;
branches;
next	1.58;

1.58
date	98.03.02.16.38.38;	author norm;	state Exp;
branches;
next	1.57;

1.57
date	98.02.23.16.21.33;	author norm;	state Exp;
branches;
next	1.56;

1.56
date	97.01.22.00.03.20;	author norm;	state Exp;
branches;
next	1.55;

1.55
date	96.03.28.23.05.29;	author norm;	state Exp;
branches;
next	1.54;

1.54
date	95.09.26.15.25.49;	author norm;	state Exp;
branches;
next	1.53;

1.53
date	95.06.23.22.16.28;	author norm;	state Exp;
branches;
next	1.52;

1.52
date	95.04.28.19.55.19;	author norm;	state Exp;
branches;
next	1.51;

1.51
date	95.03.04.07.08.22;	author norm;	state Exp;
branches;
next	1.50;

1.50
date	95.03.03.05.44.23;	author norm;	state Exp;
branches;
next	1.49;

1.49
date	95.02.15.21.13.37;	author norm;	state Exp;
branches;
next	1.48;

1.48
date	95.02.09.00.39.41;	author norm;	state Exp;
branches;
next	1.47;

1.47
date	95.02.07.05.46.00;	author norm;	state Exp;
branches;
next	1.46;

1.46
date	95.02.07.01.48.31;	author norm;	state Exp;
branches;
next	1.45;

1.45
date	94.12.19.07.19.08;	author norm;	state Exp;
branches;
next	1.44;

1.44
date	94.12.06.20.12.48;	author norm;	state Exp;
branches;
next	1.43;

1.43
date	94.10.04.05.31.27;	author norm;	state Exp;
branches;
next	1.42;

1.42
date	94.10.01.07.55.40;	author norm;	state Exp;
branches;
next	1.41;

1.41
date	94.09.16.21.03.55;	author norm;	state Exp;
branches;
next	1.40;

1.40
date	94.08.22.23.43.48;	author norm;	state Exp;
branches;
next	1.39;

1.39
date	94.08.17.16.51.22;	author norm;	state Exp;
branches;
next	1.38;

1.38
date	94.06.08.15.24.42;	author norm;	state Exp;
branches;
next	1.37;

1.37
date	94.03.02.19.00.09;	author norm;	state Exp;
branches;
next	1.36;

1.36
date	94.02.01.16.46.15;	author norm;	state Exp;
branches;
next	1.35;

1.35
date	94.01.12.04.54.04;	author norm;	state Exp;
branches;
next	1.34;

1.34
date	93.12.20.21.09.40;	author norm;	state Exp;
branches;
next	1.33;

1.33
date	93.07.17.06.40.18;	author norm;	state Exp;
branches;
next	1.32;

1.32
date	93.07.15.20.31.06;	author mueller;	state Exp;
branches;
next	1.31;

1.31
date	93.06.25.15.52.18;	author norm;	state Exp;
branches;
next	1.30;

1.30
date	93.06.21.17.10.40;	author norm;	state Exp;
branches;
next	1.29;

1.29
date	93.06.16.05.20.24;	author norm;	state Exp;
branches;
next	1.28;

1.28
date	93.06.15.15.29.04;	author norm;	state Exp;
branches;
next	1.27;

1.27
date	93.06.03.21.55.49;	author norm;	state Exp;
branches;
next	1.26;

1.26
date	93.03.11.00.13.54;	author norm;	state Exp;
branches;
next	1.25;

1.25
date	93.03.02.21.16.21;	author norm;	state Exp;
branches;
next	1.24;

1.24
date	93.02.25.00.18.06;	author norm;	state Exp;
branches;
next	1.23;

1.23
date	93.02.17.17.17.38;	author norm;	state Exp;
branches;
next	1.22;

1.22
date	93.01.27.04.41.59;	author norm;	state Exp;
branches;
next	1.21;

1.21
date	92.12.24.09.36.01;	author norm;	state Exp;
branches;
next	1.20;

1.20
date	92.12.23.15.30.15;	author norm;	state Exp;
branches;
next	1.19;

1.19
date	92.12.12.05.03.16;	author norm;	state Exp;
branches;
next	1.18;

1.18
date	92.12.10.17.07.12;	author norm;	state Exp;
branches;
next	1.17;

1.17
date	92.11.25.04.43.37;	author norm;	state Exp;
branches;
next	1.16;

1.16
date	92.07.29.22.32.00;	author norm;	state Exp;
branches;
next	1.15;

1.15
date	92.06.03.15.01.48;	author norm;	state Exp;
branches;
next	1.14;

1.14
date	92.06.03.10.13.44;	author norm;	state Exp;
branches;
next	1.13;

1.13
date	92.04.07.21.12.22;	author norm;	state Exp;
branches;
next	1.12;

1.12
date	92.04.07.18.09.23;	author norm;	state Exp;
branches;
next	1.11;

1.11
date	91.08.03.09.26.37;	author norm;	state Exp;
branches;
next	1.10;

1.10
date	91.06.01.18.06.34;	author norm;	state Exp;
branches;
next	1.9;

1.9
date	91.05.30.15.06.16;	author norm;	state Exp;
branches;
next	1.8;

1.8
date	91.05.22.15.30.15;	author norm;	state Exp;
branches;
next	1.7;

1.7
date	91.05.19.20.00.28;	author norm;	state Exp;
branches;
next	1.6;

1.6
date	91.04.22.22.54.06;	author norm;	state Exp;
branches;
next	1.5;

1.5
date	91.04.22.22.54.04;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	91.04.22.22.54.02;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	91.04.22.22.54.00;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	91.04.22.22.53.58;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	91.04.22.22.53.56;	author norm;	state Exp;
branches;
next	;


desc
@
@


1.59
log
@Better deferred typechecking messages
@
text
@const invoc <- class Invoc (Tree) [xxtarget : Tree, xxopname : Ident, xxargs : Tree]
    const ln : Integer <- xxtarget$ln
    field opNumber : Integer
    field nress : Integer <- 1
    var isNotManifest : Boolean <- false
    field value : Tree <- nil
    field target : Tree <- xxtarget
    field xopname : Ident <- xxopname
    field args  : Tree <- xxargs
    var typeinfo : Tree <- nil
    const VoS <- Vector.of[Symbol]

    export operation getIsNotManifest -> [r : Boolean]
      r <- isNotManifest
    end getIsNotManifest
    export operation setIsNotManifest [r : Boolean]
      isNotManifest <- r
    end setIsNotManifest
    export function upperbound -> [r : Integer]
      r <- 1
    end upperbound
    export function getElement [i : Integer] -> [r : Tree]
      if i = 0 then
	r <- target
      elseif i = 1 then
	r <- args
      end if
    end getElement
    export operation setElement [i : Integer, r : Tree]
      if i = 0 then
	target <- r
      elseif i = 1 then
	args <- r
      end if
    end setElement

    export function getnargs -> [r : Integer]
      if args == nil then
	r <- 0
      else
	r <- args.upperbound + 1
      end if
    end getnargs

    export operation copy [i : Integer] -> [newt : Tree]
      var ntarget, nargs : Tree
      if target !== nil then ntarget <- target.copy[i] end if
      if args !== nil then nargs <- args.copy[i] end if
      const r <- invoc.create[ln, ntarget, xopname, nargs]
      r$isNotManifest <- isNotManifest
      newt <- r
    end copy
    export operation resolveSymbols [st : SymbolTable, nexp : Integer]
      nress <- nexp
      target.resolveSymbols[st, 1]
      if args !== nil then args.resolveSymbols[st, 1] end if
    end resolveSymbols

  export operation assignTypes
    if self$value !== nil then
      self$value.assignTypes
    else
      FTree.assignTypes[self]
    end if
  end assignTypes

  function isSelf -> [r : Boolean] 
    const t <- nameof self$target

    if t = "aselflit" then
      r <- true
    elseif t = "asym" then
      const ts <- view self$target as Sym
      r <- ts$mySym$isSelf
    else
      r <- false
    end if
  end isSelf

  operation isAlreadySet [s : Symbol, v1 : VoS, v2 : VoS] -> [r : Boolean]
    r <- false
    const limit <- v1.upperbound
    for i : Integer <- 0 while i <= limit by i <- i + 1
      if v1[i] == s then r <- true return end if
      if v2[i] == s then r <- true return end if
    end for
  end isAlreadySet

  export operation typeCheck 
    if typeinfo !== nil then return end if
    var isNone : Boolean <- false
    if self$value !== nil then
      self$value.typeCheck
      return
    end if
    var targetct   : Tree <- self$target.getCT
    var targettype : Tree
    if targetct == nil then
      targettype <- self$target.getAT
      if nameof targettype = "abuiltinlit" then
	const ttbID : Integer <- (view targettype as BuiltinLit)$id
	isNone <- ttbID = 0x1007 or ttbID = 0x1607
	const newtargettype <- (view targettype as hasinstat)$instAT
	if newtargettype !== nil then targettype <- newtargettype end if
      end if
      if nameof targettype = "aglobalref" then
	const ttgID : Integer <- (view targettype as GlobalRef)$id
	isNone <- ttgID = 0x1007 or ttgID = 0x1607
	const newtargettype <- targettype.asType
	if newtargettype !== nil then targettype <- newtargettype end if
      end if
      if targettype !== nil then
	targetct <- (view targetType as hasInstCT)$instCT
      end if
    end if
    var theopsig : OpSig
    const env <- Environment$env
    const opst <- xopname$name

    if targetCT !== nil and nameof targetCT = "aglobalref" then
      const codeoid <- (view targetCT as GlobalRef)$codeoid
      if codeoid !== nil then
	const newr <- ObjectTable.Lookup[codeoid]
	if newr !== nil then targetCT <- newr end if
      end if
    end if
    if targetct !== nil and nameof targetct = "anoblit" then
      const tob <- view targetct as Oblit
      isNone <- tob$codeOID = 0x1807
      var theopdef : OpDef
      theopdef, opNumber <- tob.findOp[xopname, self.isSelf, self$nargs, 0]
      opNumber <- -opNumber
      if theopdef !== nil then
	theopsig <- view theopdef$sig as OpSig
      end if
      if env$tracetypeCheck then
	env.printf["invoc.check of \"%s\" on %d, got sig from ct,self? %s\n",
	  { opst, ln, self.isSelf.asString }]
      end if
      if isNone then
	% No problem, the target has type None, so has all operations
	typeinfo <- self.fakeResultTypes
	return
      end if
    elseif targettype !== nil and nameof targettype = "anatlit" then
      const targetat <- view targettype as ATLit
      isNone <- targetat$id = 0x1607
      targetat.assignTypes
      theopsig, opNumber <- targetat.findOp[xopname, self$nargs, 0] 
      if env$tracetypeCheck then
	env.printf["invoc.check of \"%s\" on %d, got sig from at\n",
	  { opst, ln}]
      end if
      if isNone then
	% No problem, the target has type None, so has all operations
	typeinfo <- self.fakeResultTypes
	return
      end if
    elseif isNone then
      % No problem, the target has type None, so has all operations
      typeinfo <- self.fakeResultTypes
      return
    else
      % Can't find a type
      FTree.typecheck[self]
      return
    end if
    if theopsig == nil then
      env.SemanticError[ln, "Operation %s[%d] is not defined",
	{ opst, self$nargs }]
      typeinfo <- self.fakeResultTypes
      return
    end if
    if theopsig$mustBeCompilerExecuted then
      env.SemanticError[ln, "Operation \"%s[%d]\" must be manifest, but isn't",
	{ opst, self$nargs }]
      typeinfo <- self.fakeResultTypes
      return
    end if
    const opsignress <- theopsig$nress
    const opsignargs <- theopsig$nargs

    var limit : Integer
    var opsigargs : Tree <- theopsig$params
    
    if opsignargs != self$nargs then
      env.SemanticError[ln,
	"Number of arguments %d incorrect, \"%s\" expects %d",
	{ self$nargs, opst, opsignargs }]
    end if
%   if opsignress != self$nress then
%     env.SemanticError[self$ln,
%	"Number of results %d incorrect, \"%s\" returns %d",
%	{ self$nress, opst, opsignress }]
%   end if

    % This +10 should be +opsig.wheres.length

    const oldvalues <- VoT.create[self$nargs+10]
    const oldtypes  <- VoT.create[self$nargs+10]
    const parxs <- VoT.create[self$nargs+10]
    const valuesyms <- VoS.create[self$nargs+10]
    const typesyms  <- VoS.create[self$nargs+10]
    const theParams  <- (view theopsig as OpSig)$params
    const theResults <- (view theopsig as OpSig)$results
    var redoassignment : Boolean <- false


    if env$tracetypecheck then
      env.printf["Before typechecking\n", nil]
      theopsig.print[env$stdout, 0]
    end if
    limit <- self$nargs
    if limit > opsignargs then limit <- opsignargs end if
    for i : Integer <- 1 while i <= limit by i <- i + 1
      const thisarg <- self$args[i-1]
      const actualtype <- view thisarg.getAT as hasconforms
      const thisparx <- opsigargs[i-1]
      const formaltype <- thisparx.asType
      if redoassignment then
	parxs[i] <- thisparx
	thisparx.assignTypes
      end if
      if nameof thisparx = "aparam" then
	const thispar <- view thisparx as Param
	const thisparsym : Symbol <- (view thispar$xsym as Sym)$mysym
	if thisparsym$isTypeVariable then
	  var thisvalue : Tree
	  if !thisarg$isNotManifest then
	    thisvalue <- thisarg.execute.asType
	  end if
	  if thisvalue == nil then
	    env.SemanticError[ln,
	      "Parameter %d to %S[%d] must be manifest", 
	      { i, xopname, self$nargs}]
	  elseif !self.isAlreadySet[thisparsym, valuesyms, typesyms] then
	    % We actually have a value here, change the value of the param
	    % First check for a constraint
	    assert thisparsym$value !== nil
	    if !(view thisvalue as hasConforms).ConformsTo[ln, view thisparsym$value as ATLit] then
	      env.SemanticError[ln, 
		"Actual #%d to \"%S[%d]\" does not match constraint on formal",
		{ i, xopname, self$nargs }]
	    end if
	    if env$tracetypecheck then
	      env.printf["Setting %S's (%d) value to %S\n", 
		{ thisparsym$myident, Environment.getPtr[thisparsym], thisvalue }]
	    end if
	    valuesyms[i-1] <- thisparsym
	    oldvalues[i-1] <- view thisparsym$value as Tree
	    thisparsym$value <- thisvalue
	    redoassignment <- true
	  end if
	end if
	if nameof thispar$xtype = "asym" then
	  const thispartypesym <- (view thispar$xtype as sym)$mysym
	  if thispartypesym$isTypeVariable and !self.isAlreadySet[thispartypesym, valuesyms, typesyms] then
	    assert thispartypesym$value !== nil
	    if !actualType.ConformsTo[ln, view thispartypesym$value as ATLit] then
	      env.SemanticError[ln, 
		"Actual type #%d to \"%S[%d]\" does not match constraint on formal",
		{ i, xopname, self$nargs }]
	    end if
	    if env$tracetypecheck then
	      env.printf["Setting %S's (%d) types value to %S\n", 
		{ thispartypesym$myident, Environment.getPtr[thispartypesym],
		  actualType }]
	    end if
	    typesyms[i-1] <- thispartypesym
	    oldtypes[i-1] <- view thispartypesym$value as Tree
	    thispartypesym$value <- view actualType as Tree
	    redoassignment <- true
	  end if
	end if
      end if
      if actualtype == nil then
	env.ttypeCheck["invoc.typecheck of \"%s\" on %d, actual %d type is nil\n", 
	  { opst, ln, i} ]
      elseif formaltype == nil then
	env.ttypeCheck["invoc.typecheck of \"%s\" on %d, formal %d type is nil\n", 
	  { opst, ln, i } ]
      elseif !actualType.conformsTo[ln, formalType] then
	env.SemanticError[ln, 
	  "Actual #%d to \"%s\" does not conform to formal",
	  { i, opst}]
      end if
    end for
    if theResults == nil then
      if nress = 0 then
	typeinfo <- Seq.create[ln]
	FTree.typeCheck[self]
      else
	env.SemanticError[ln, "Invocation %S[%d] returns 0 results, %d are expected", { xopname, self$nargs, nress} ]
	typeinfo <- self.fakeResultTypes
      end if
    elseif nress != theResults.upperbound + 1 then
      env.SemanticError[ln, "Invocation %S[%d] returns %d results, %d are expected", { xopname, self$nargs, theResults.upperbound + 1, nress } ]
      typeinfo <- self.fakeResultTypes
    else
      if redoassignment then
	const thewheres <- (view theopsig as OpSig)$xwhere
	if thewheres !== nil then
	  const st <- (view theopsig as OpSig)$st
	  const newst <- SymbolTable.create[(view theopsig as OpSig)$st,CBlock]
	  const todo <- seq.create[thewheres$ln]
	  var xx : Any
	  for i : Integer <- 0 while i <= thewheres.upperbound by i <- i + 1
	    const awhere  <- view thewheres[i] as Wherewidgit
	    const aop     <- awhere$xop

	    if aop = OP_WHERE then
	      % This is a declaration, and I need to do it
	      const awsymdef<- awhere$xsym
	      const awsym   <- (view awsymdef as Sym)$mysym
	      valuesyms[self$nargs + i] <- awsym
	      oldvalues[self$nargs + i] <- view awsym$value as Tree
	      const tcopy   <- awhere$xtype.copy[0]
	      todo.rcons[tcopy]
	      awsym$value <- tcopy
	    end if
	  end for
	  xx <- todo.removeSugar[nil]
	  todo.defineSymbols[newst]
	  todo.resolveSymbols[newst, 1]
	  loop
	    exit when !todo.findManifests
	  end loop
	  todo.evaluateManifests
	end if
      end if
      var theType : Tree
      if nress != 1 then typeinfo <- Seq.create[ln] end if
      for i : Integer <- 0 while i <= theResults.upperbound by i <- i + 1
	if redoassignment then
	  parxs[self$nargs + i] <- theResults[i]
	  theResults[i].assignTypes
	end if
	theType <- theResults[i].asType
	if nameof theType = "abuiltinlit" then
	  theType <- (view theType as hasInstAT).getInstAT
	end if
	if env$traceassignTypes then
	  env.printf["invoc.getAT:  answer is %s\n", {theType.asString}]
	end if
	if nress = 1 then
	  typeinfo <- theType
	else
	  typeinfo.rcons[theType]
	end if
      end for
      FTree.typeCheck[self]
      if redoassignment then
	% That same old + 10
	for i : Integer <- limit + 10 - 1 while i >= 0 by i <- i - 1
	  if valuesyms[i] !== nil then
	    if env$tracetypecheck then
	      env.printf["Setting %S's (%d) value back to %S\n", 
		{ valueSyms[i]$myident, Environment.getPtr[valueSyms[i]], oldvalues[i] }]
	    end if
	    valueSyms[i]$value <- oldvalues[i]
	  end if
	  if typesyms[i] !== nil then
	    if env$tracetypecheck then
	      env.printf["Setting type %S's (%d) value back to %S\n", 
		{ typeSyms[i]$myident, Environment.getPtr[typeSyms[i]], oldtypes[i] }]
	    end if
	    typeSyms[i]$value <- oldtypes[i]
	  end if
%	  if parxs[i] !== nil then
%	    parxs[i].assignTypes
%	  end if
	end for
	theopsig.assignTypes
      end if
    end if
    if env$tracetypecheck then
      env.printf["After all typechecking is done\n", nil]
      theopsig.print[env$stdout, 0]
    end if
  end typeCheck

  export operation findThingsToGenerate [q : Any]
    if self$value !== nil then
      self$value.findThingsToGenerate[q]
    else
      FTree.findThingsToGenerate[q, self]
    end if
  end findThingsToGenerate

  export function count [x : Tree] -> [r : Integer]
    if x == nil then
      r <- 0
    else
      r <- x.upperbound + 1
    end if
  end count

  export operation tryInline[ct : Tree, xct : Printable] -> [r : Boolean]
    const bc <- view xct as ByteCode
    const ob <- view ct as oblit
    var def : OpDef
    var stat : Tree
    var sig : OpSig
    const hasGenerateLValue <- typeobject hasGenerateLValue
      operation generateLValue[Printable]
    end hasGenerateLValue
    var lv : hasGenerateLValue
    var first : String
    var instSize : Integer <- 0
    var generatedSize : Integer <- 4
    var nResults : Integer <- 0
    var isPrim : Boolean
    var index : Integer
    const env <- Environment$env

    r <- false
    if env$traceinline then
      env.printf["Trying an inline of %s on %s\n",
	{self$xopname.asString, ob$name.asString}]
    end if
    def, index <- ob.findOp[self$xopname, self.isSelf, self$nargs, self$nress]
    if def == nil or !def$isInlineable then return end if
    
    sig <- view def$sig as OpSig
    if sig$results !== nil then
      nResults <- 1
    end if
    
    isprim, stat <- def.findStatement
    assert stat !== nil 

    if isprim then
      const prims <- view stat as PrimStat
      const number <- prims$number
      const extravals <- self.count[prims$vals] - self.count[self$args]
      var lt : Integer
      % Check that if there is 1 result that it is also the left of the
      % primstat  
  
      % Check that there are the same number of args as vals
      if extravals < 0 then
	env.tinline["  Less prim vals than args\n", nil]
	return
      end if

      % We assume that the order of arguments to the primitive statement is
      % local instance vars followed by arguments in the same order as the
      % arguments

      % Check that the args are in the same order as the prim vals
      
      instSize <- ob$instanceSize  
  
      if prims$xvar !== nil then
	% all things are assumed vars
	generatedSize <- 8
      end if
      bc.pushSize[generatedSize]	
  
      if prims$xself !== nil then
        self$target.generate[bc]
      end if
  
      % Generate the local variables
      for i : Integer <- 0 while i < extravals by i <- i + 1
	const val <- view prims$vals[i] as Sym
	const valsym <- val$mysym
	const offset : Integer <- valsym$offset
	var lgeneratedSize : Integer
	if valsym$isNotManifest then
	  % Generate the target
	  bc.pushSize[4]
	  self$target.generate[bc]
	  bc.popSize

	  if bc$size = 4 or valsym$size = 4 then
	    bc.addCode["LDINDS"]
	    lgeneratedSize <- 4
	  else
	    bc.addCode["LDVINDS"]
	    lgeneratedSize <- 8
	  end if
	  if offset == nil or offset == 0 then
	    % Use 4
	    bc.addValue[4, 2]
	  else
	    bc.addValue[valsym$offset, 2]
	  end if
	  bc.finishExpr[lgeneratedsize, val$codeOID, val$atOID]
	else
	  (view valsym$value as Tree).generate[bc]
	end if
      end for
      
      if instSize == ~8 and number !== nil then
	first <- (view number[0] as hasStr)$str
	if first = "SET" then
	  assert prims$vals.upperbound = 1
	  assert self$args.upperbound = 1
	  self$args[0].generate[bc]
	  bc.pushSize[8]
	  self$args[1].generate[bc]
	  bc.popSize
	else
	  if self$args !== nil then self$args.generate[bc] end if
	end if
      else
	if self$args !== nil then self$args.generate[bc] end if
      end if
	
      if number !== nil then
	const limit : Integer <- number.upperbound
	for i : Integer <- number.lowerbound while i <= limit by i <- i + 1
	  const v <- view number[i] as hasStr
	  const s : String <- v$str
	  if s[0] >= '0' and s[0] <= '9' then
	    const primno <- Integer.Literal[s]
	    bc.addValue[primno, 1]
	  else
	    if s = "SET" and instSize = ~8 then
	      bc.addCode["SETV"]
	    elseif s = "GET" and instSize = ~8 then
	      bc.addCode["GETV"]
	      generatedSize <- 8
	    else
	      bc.addCode[s]
	      if s = "LDIS" then
		bc.alignTo[2]
	      end if
	    end if
	  end if
  
	end for
      end if
      bc.popSize
      if nResults > 0 then
	% Worry about if the context needs a different size
	if bc$size = 4 then
	  bc.finishExpr[generatedSize, 0, 0]
	elseif bc$size = 8 and generatedSize = 4 then
	  const thetype <- sig$results[0][1].asType
	  const t <- (view thetype as hasInstCT)$instCT
	  const u <- view t as hasIDs
	  if t == nil then
	    Environment$env.printf["inlined invoc botch, thetype = %s, theopname = %s, thetarget = %s\n", {thetype.asString, xopname$name, ob.asString}]
	    Environment$env.printf["  the type id = %#x instSize = %d\n", 
	      {(view thetype as hasID)$id, instSize}]
	    Environment$env.printf["  the type.isVector = %s\n", 
	      {(view thetype as ATLit)$isVector.asString}]
	    Environment$env.printf["  the type.name = %s\n", 
	      {(view thetype as ATLit)$name.asString}]
	    bc.finishExpr[generatedSize, 0x80000000, 0x1601]
	  else
	    bc.finishExpr[generatedSize, u$codeOID, (view thetype as hasID)$id]
	  end if
	end if
      end if
    else 			% assignstatement
      const asss <- view stat as AssignStat
      var right : Tree
      var rname : String
      var rsy : Symbol
      var rsym: Sym

      if env$traceinline then
	env.printf["  Found an assignment statement\n", nil]
      end if

      % Check that if there is 1 result that it is also the left of the
      % assignstat
  
      assert nResults = 1

      right <- asss$right[0]
      rname <- nameof right
      if rname = "aliteral" and (view right as Literal)$index = IntegerIndex then
	right.generate[bc]
      elseif rname = "asym" then
	rsym<- view right as Sym
	rsy <- rsym$mysym
	if !rsy$isNotManifest then
	  (view rsy$value as Tree).generate[bc]
	else
	  if self.isself then
	    % Since the target is me, I can just use the right hand side
	    rsym.generate[bc]
	  else
	    % Generate the target
	    bc.pushSize[4]
	    self$target.generate[bc]
	    bc.popSize
  
	    if bc$size = 4 or rsy$size = 4 then
	      generatedSize <- 4
	      bc.addCode["LDINDS"]
	    else
	      generatedSize <- 8
	      bc.addCode["LDVINDS"]
	    end if
	    bc.addValue[rsy$offset, 2]
	    bc.finishExpr[generatedSize, rsym$codeOID, (view rsy$ATinfo as hasID)$id]
	  end if
	end if
      end if
    end if
    r <- true
  end tryInline

  export operation generate [xct : Printable]
    const bc <- view xct as ByteCode
    if self$value !== nil then
      const gs <- typeobject gs
	operation generateSelf[Printable]
      end gs
      const vgs <- view self$value as gs
      vgs.generateSelf[xct]
    else
      var targetType, targetCT : Tree
      const env <- Environment$env
      bc.lineNumber[ln]
      if env$traceinline then
	env.printf["invoc.inline: %s target is %s\n",
	  {xopname$name, self$target.asString}]
      end if
      targetCT <- self$target$ct
      if targetCT == nil then
	targetType <- self$target.getat
	if targetType !== nil then
	  if env$traceinline then
	    env.printf["targetType is %s\n", {targetType.asString}]
	  end if
	  targetCT <- (view targetType as hasInstCT)$instCT
	end if
      end if
      if targetCT !== nil and nameof targetCT = "aglobalref" then
	const codeoid <- (view targetCT as GlobalRef)$codeoid
	if codeoid !== nil then
	  const newr <- ObjectTable.Lookup[codeoid]
	  if newr !== nil then targetCT <- newr end if
	end if
      end if
	
      if env$traceinline then
	if targetCT == nil then
	  env.printf["targetCT is nil\n", nil]
	else
	  env.printf["targetCT is %s\n", {targetCT.asString}]
	end if
      end if
      if targetCT !== nil and
	 nameof targetCT = "anoblit" and
	 ((view targetCT as ObLit)$isImmutable or
	  ! env$generateconcurrent) 
      then
	if self.tryInline[targetCT, xct] then return end if
      end if

      % Push nil objects (in the 8-byte format) onto the stack in the
      % slots where return values should eventually go.
      for i : Integer <- 0 while i < self$nress by i <- i + 1
	bc.addCode["PUSHNILV"]
      end for
      % Push the arguments on the stack.
      bc.pushSize[8]
      if self$args !== nil then 
	self$args.generate[xct]
      end if
      % Generate the object whose operation we are about to invoke.
      self$target.generate[xct]
      bc.popSize
      % Invoke it.
      if targetCT !== nil and nameof targetCT = "anoblit" then
	if opNumber == nil or opNumber >= 0 then
	  var theOpDef : Any
	  const tob <- view targetCT as ObLit
	  theopdef, opNumber <- tob.findOp[xopname, self.isSelf, self$nargs, 0]
	  %	
	  % We have to take special care of nil.  If we are explicitly 
	  % invoking nil, then we will know the CT.  Nil has every operation, 
	  % but doesn't really implement them all, so we have to special case
	  % it 'cause we won't find the operation.
	  if tob$codeoid = 0x1807 then
	    assert opNumber == nil
	    opNumber <- 0
	  else
	    opNumber <- -opNumber
	  end if
	end if
	opNumber <- -opNumber
	assert opNumber <= 255
	bc.addCode["CALLCTB"]
	bc.addValue[opnumber, 1]
      elseif Environment$env$useAbCons then
	assert opNumber >= 0
	if opNumber <= 255 then
	  bc.addCode["CALLB"]
	  bc.addValue[opNumber, 1]
	else
	  assert opNumber <= 65535
	  bc.addCode["CALLS"]
	  bc.addValue[opNumber, 2]
	end if
      else
	var name : String <- xopname$name
	if self$args == nil then 
	  name <- name || "@@0"
	else
	  name <- name || "@@" || (self$args.upperbound + 1).asString
	end if
	name <- name || "@@" || self$nress.asString
	const opoid <- opnametooid.Lookup[name]
	if opoid <= 32767 then
	  bc.addCode["CALLOIDS"]
	  bc.addValue[opoid, 2]
	else
	  bc.addCode["CALLOID"]
	  bc.addValue[opoid, 4]
	end if
      end if
      % The call should return its result(s) in the 8-byte format; this
      % changes it to the 4-byte format if necessary.
      % In addition, if we are using ab/cons, then we need to generate code
      % to correct the ab in the ab/cons that left for us by the called
      % procedure.  Where do we find the abs?
      % The third argument needs to be the at that we have generated.
      if self$nress = 1 then
        bc.finishExpr[8, 0, 0]
      end if
    end if
  end generate

  operation findObject [t : Tree] -> [s : String, result : Oblit]
    var r : Tree
    s <- nameof t
    r <- view t as Tree
    loop
      exit when s != "asym"
      r <- view (view r as Sym)$mysym$value as Tree
      if r == nil then
	s <- "totaljunk"
      else
	s <- nameof r
      end if
    end loop
    result <- view r as ObLit
  end findObject

  export operation findManifests -> [changed : Boolean]
    const env <- Environment$env

    changed <- false
    if ! self$isNotManifest then
      var makeNotManifest : Boolean <- false
      if self$target$isNotManifest then
	makeNotManifest <- true
      else
	if self$args !== nil then
	  for i : Integer <- 0 while i <= self$args.upperbound by i <- i + 1
	      const arg <- args[i]
	    if arg$isNotManifest or nameof arg = "aliteral" then
	      makeNotManifest <- true
	    end if
	  end for
	end if
	if !makeNotManifest then
	  var thing : Oblit
	  var s : String
	  s, thing <- self.findObject[self$target]
  
	  if env$traceevaluatemanifests then
	    env.printf["invoc on line %d, s = %s\n", { ln, s : Any} ]
	  end if
	  if s = "anoblit" then
	    makeNotManifest <- !thing.isAFunction[self$xopname, self$nargs, 0]
	    %
	    % Only because I'm tired of trying things that don't work
	    %
	    makeNotManifest <- makeNotManifest | xopname$name != "of"
	  elseif s = "abuiltinlit" then
	    % A builtin literal
	    % this is manifest if the operation is "of"
	    makeNotManifest <- xopname$name != "of"
	  else
	    makeNotManifest <- true
	  end if
	  if env$traceevaluatemanifests then
	    env.printf["makeNonManifest = %s\n", {makeNotManifest.asString}]
	  end if
	end if
      end if
      if makeNotManifest then
	self$isNotManifest <- true
	changed <- true
      end if
    end if
    changed <- FTree.findManifests[self] | changed
  end findManifests

  function toInt [a : Any] -> [r : Integer]
    primitive [r] <- [a]
  end toInt

  export operation execute -> [r : Tree]
    var tar : Tree
    var t : Oblit
    var theopdef, theopsig, thebody, thestats, thestat, theexps, theexp : Tree
    var theparams, thewheres, thewhere : Tree
    var thecopy : Oblit
    var newst : SymbolTable
    const VofT <- Vector.of[Tree]
    var executedargs  : VofT
    var keystring : String
    var id, codeid, instcodeid : Integer
    var resultObject : Any
    var oldfilename : String
    var filename : String
    var tarname : String
    var shouldCacheAnswer : Boolean <- false
    var index : Integer
    const env <- Environment$env
    const tem : Boolean <- env$traceevaluatemanifests

    if self$value !== nil then
      r <- self$value
      return
    end if
    tar <- self$target.execute
    if tar == nil then
      env$needMoreEvaluateManifest <- true
      return
    end if

    tarname <- nameof tar
    if tem then
      env.info[ln, "Invoc.execute on \"%S\", opname %S",
	{ self$target, xopname } ]
    end if

    if args !== nil then
      executedargs <- VofT.create[self$nargs]
      for i : Integer <- 0 while i <= args.upperbound by i <- i + 1
	var a : Tree <- args[i]
	var xa, xxa : Tree
	xa <- a.execute
	if xa !== nil then xxa <- xa.asType end if
	if tem then
	  env.printf["  arg %d was %S\n", { i, a }]
	  env.printf["  arg %d.execute is %S\n", {i, xa}]
	  env.printf["  arg %d.execute.asType is %S\n", {i, xxa}]
	end if
	if xxa == nil then
	  env$needMoreEvaluateManifest <- true
	  return
	end if
	executedargs[i] <- xxa
      end for
    end if

    % Check the invoc cache
    if self$nargs = 1 then
      const argone <- executedargs[0]
      const aashasid <- view argone as hasId
      const tashasId <- view tar as hasId
      var aid : Integer
      if aashasid == nil then
	env.info[ln, "The invoc of %S should be manifest but arg[0] is nil\n", {xopname}]
      else
        aid <- aashasid$id
	if aid !== nil and aid != 0 then
	  keystring <- formattedOutput.sprintf["%#x.%s[%#x]",
	    { tashasId$id, xopname$name, aashasid$id }]
	  shouldCacheAnswer <- true
%	    (tashasId$id == 0x100c | tashasid$id == 0x1012)
%	    & (xopname$name = "of")
%%%% Seems to break something
%%%%	    & (0x1000 <= aashasid$id) & (aashasid$id <= 0x1a00)
	end if
      end if
    end if
    if keystring !== nil then
      id, codeid, instcodeid, oldfilename, resultObject <- InvocCache.Lookup[keystring]
      filename <- env$fn
      if tem then
	env.printf["Invoc (%s) found %x %x %x %x\n", 
	  {keystring, id, codeid, instcodeid, self.toInt[resultObject]}]
      end if
      if id !== nil then
	if resultObject !== nil then
	  r <- view resultObject as Tree
	  self$value <- r
	  if tem then env.printf["Found a result object\n", nil] end if
	  return
	elseif tarname != "anoblit" then
	  r <- GlobalRef.create[ln, id, nil, codeid, instcodeid, nil]
	  self$value <- r
	  if tem then env.printf["Created a result globalref\n", nil] end if
	  return
	end if
      end if
    end if
    if tarname != "anoblit" then return end if

    t <- view tar as Oblit
    theopdef, index <- t.findOp[self$xopname, self.isSelf, self$nargs, 0]
    theopsig <- (view theopdef as OpDef)$sig
    theparams<- (view theopsig as OpSig)$params
    thewheres<- (view theopsig as OpSig)$xwhere
    thebody  <- (view theopdef as OpDef)$body
    thestats <- (view thebody  as Block)$stats
    if thestats == nil then return end if
    if thestats.upperbound != 0 then return end if
    thestat <- thestats[0]
    theexps <- (view thestat as AssignStat)$right
    theexp  <- theexps[0]

    % Evaluate its symbols
    % This used to be
    newst <- SymbolTable.create[(view theopdef as OpDef)$st$outer, CBlock]
    %
    % but it is now
    % newst <- SymbolTable.create[env$rootst, CBlock]
    % newst <- SymbolTable.create[env$rootst$inner[0], CBlock]
    %
    % because I lose the symbol tables
    
    % so we believe that this object is manifest
    newst$depth <- 1

    %
    % Send the deferred type checks all at once if there are more than one
    %
    const params <- Array.of[Any].empty
    const psyms <- Array.of[Any].empty

    if theparams !== nil then
      for i : Integer <- 0 while i <= theparams.upperbound by i <- i + 1
	const aparam  <- view theparams[i] as Param
	const apsymdef<- view aparam$xsym as Sym
	const apsym   <- apsymdef$mysym
	const asymbol <- newst.define[ln, apsym$myident, SConst, false]
	const avalue  <- executedargs[i]
	assert avalue !== nil
	%
	% Do the type checking here.
	%
	if theparams.upperbound = 0 then
	  env.scheduleDeferredTypeCheck[self, aparam, apsym, avalue, i]
	else
	  params.addupper[aparam]
	  psyms.addupper[apsym]
	end if
	asymbol$value <- avalue
      end for
      if theparams.upperbound > 0 then
	env.scheduleDeferredTypeCheck[self, params, psyms, executedargs, 0]
      end if
    end if

    % by this point, theexp had better be an oblit
    thecopy <- view theexp.copy[0] as Oblit

    newst$myTree <- thecopy

    if thewheres !== nil then
      const todo <- seq.create[thewheres$ln]
      var xx : Any
      for i : Integer <- 0 while i <= thewheres.upperbound by i <- i + 1
	const awhere  <- view thewheres[i] as Wherewidgit
	const aop     <- awhere$xop

	if aop = OP_FORALL then
	  % This is a "for all"
	  % Ignore it for now ???
%	  const awsymdef<- awhere$xsym
%	  const awsym   <- (view awsymdef as Sym)$mysym
%	  const asymbol <- newst.define[ln, awsym$myident, SConst, false]
%	  const tcopy   <- 
%	    atlit.create[
%	      awhere$ln, 
%	      thecopy$sfname,
%	      sym.create[
%		awhere$ln, 
%		Environment$Env$ITable.Lookup["whocares", 999]], 
%	      seq.create[awhere$ln]]
%	  todo.rcons[tcopy]
%	  asymbol$value <- tcopy
	  
	elseif aop = OP_WHERE then
	  % This is a declaration, and I need to do it
	  const awsymdef<- awhere$xsym
	  const awsym   <- (view awsymdef as Sym)$mysym
	  const asymbol <- newst.define[ln, awsym$myident, SConst, false]
	  const tcopy   <- awhere$xtype.copy[0]
	  todo.rcons[tcopy]
	  asymbol$value <- tcopy
	else
	  % This is just a constraint, the only thing we need to do is type
	  % checking
	end if
      end for
      xx <- todo.removeSugar[nil]
      todo.defineSymbols[newst]
      todo.resolveSymbols[newst, 1]
      loop
	exit when !todo.findManifests
      end loop
      todo.evaluateManifests
    end if
    
    thecopy <- thecopy.removeSugar[nil]
    thecopy.defineSymbols[newst]
    thecopy.resolveSymbols[newst, 1]
    loop
      exit when ! thecopy.findManifests
    end loop
    if keystring !== nil and id !== nil then
      if Environment$env$optimizeInvocExecute and oldfilename !== nil and oldfilename != filename then
	const ict <- view thecopy$instCT as oblit
	thecopy$alreadyGenerated <- true
	ict$alreadyGenerated <- true
      end if
      thecopy$id <- id
      thecopy$codeOID <- codeid
      thecopy$instCTOID <- instcodeid
    end if
    thecopy.makeMeManifest
    if Environment$env$dumpevaluatemanifests then
      Environment$env$stdout.putString["The tree before evaluating manifests\n"]
      thecopy.Print[Environment$env$stdout, 0]
    end if
    thecopy.evaluateManifests
    if Environment$env$dumpevaluatemanifests then
      Environment$env$stdout.putString["The tree after evaluating manifests\n"]
      thecopy.Print[Environment$env$stdout, 0]
    end if
    env.tassigntypes["Invoke.execute, assigning types\n", nil]
    thecopy.assignTypes
    self$value <- thecopy
    const itsinstct <- (view thecopy$instCT as ObLit)
    if itsinstct !== nil then itsinstct.setATType end if
    r <- thecopy
    env.pass["Invoke.execute, answer is \"%s\"\n", {r.asString}]
    if keystring !== nil then
      if env$traceevaluatemanifests then
	env.printf["Invoc inserting %s, %x %x %x %x %s\n",
	  {keystring, thecopy$id, thecopy$codeOID, thecopy$instCTOID, 
	   self.toInt[thecopy], shouldCacheAnswer.asString : Any}]
      end if
      if shouldCacheAnswer then
	invoccache.Insert[keystring, thecopy$id, thecopy$codeOID, thecopy$instCTOID, filename, thecopy]
      else
	invoccache.Insert[keystring, thecopy$id, thecopy$codeOID, thecopy$instCTOID, filename, nil]
      end if
    end if
  end execute

  export operation doDeferredTypeCheck
    [params : Any, % Param
     psyms : Any,  % Symbol
     values : Any, % Tree
     whichparameter : Integer]
    const env <- Environment$env
    const tem <- env$traceEvaluateManifests
    var paramlist, psymlist, valuelist : RISA
    var aparam : Param
    var apsym : Symbol
    var avalue : Tree
    var limit : Integer

    if env$dotypecheck then
      const atypes <- AOA.empty
      const btypes <- AOA.empty
      if nameof params = "aparam" then
	limit <- 0
	aparam <- view params as Param
	apsym <- view psyms as Symbol
	avalue <- view values as Tree
      else
	limit <- (view params as RISA).upperbound
	paramlist <- view params as RISA
	psymlist <- view psyms as RISA
	valuelist <- view values as RISA
      end if
      for i : Integer <- 0 while i <= limit by i <- i + 1
	if limit > 0 then
	  aparam <- view paramlist[i] as Param
	  apsym <- view psymlist[i] as Symbol
	  avalue <- view valuelist[i] as Tree
	end if
	const parameterType <- aparam$xtype.execute.asType
	const parameterConstraint <- view apsym$value as Tree
	const argumentValue <- view avalue as hasConforms
	const argumentType <- view (view argumentValue as Tree).getAT as hasConforms
	if tem then
	  env.printf["  parameter %d type is %S\n", {i + 1, parameterType}]
	  env.printf["  parameter %d constraint is %S\n", {i + 1, parameterConstraint}]
	  env.printf["  argument %d type is %S\n", {i + 1, argumentType}]
	  env.printf["  argument %d value is %S\n", {i + 1, argumentValue}]
	end if
	
	if limit = 0 then
	  if !argumentType.conformsTo[ln, parameterType] then
	    env.SemanticError[ln, 
	      "Actual #%d to \"%S[%d]\" does not conform to formal (deferred)",
	      { whichparameter + 1, xopname, self$nargs }]
	    self$value <- Literal.NilL[0]
	  end if
	else
	  atypes.addupper[argumentType]
	  btypes.addupper[parameterType]
	end if

	if parameterConstraint !== nil then
	  if limit = 0 then
	    if !argumentValue.ConformsTo[ln, parameterConstraint] then
	      env.SemanticError[ln, 
		"Actual #%d to \"%S[%d]\" does not match constraint on formal (deferred)",
		{ whichparameter + 1, xopname, self$nargs }]
	      self$value <- Literal.NilL[0]
	    end if
	  else
	    atypes.addupper[argumentValue]
	    btypes.addupper[parameterConstraint]
	  end if
	end if
      end for
      if limit > 0 then
	if !Conformer.Conforms[ln, atypes, btypes] then
	  env.SemanticError[ln, 
	    "Actuals (as a group) to \"%S[%d]\" do not conform or do not match constraint on formals",
	    { xopname, self$nargs }]
	  self$value <- Literal.NilL[0]
	end if
      end if
    end if
  end doDeferredTypeCheck

  operation fakeResultTypes -> [r : Tree]
    const noneType <- (view BuiltinLit.findTree[0x1007,nil] as hasInstAT).getInstAT.asType
    if nress = 1 then
      r <- noneType
    else
      r <- Seq.create[ln]
      for i : Integer <- 0 while i < nress by i <- i + 1
	r.rcons[noneType]
      end for
    end if
    FTree.typeCheck[self]
  end fakeResultTypes

  export operation getAT -> [r : Tree]
    const env <- Environment$env

    if typeinfo !== nil then
    elseif self$value !== nil then
      typeinfo <- self$value.getat
    else
      self.typecheck
      if typeinfo == nil then r <- self.fakeResultTypes end if
    end if
    r <- typeinfo
  end getAT

  export operation getCT -> [r : Tree]
    if self$value !== nil then
      r <- self$value$ct
    else
      r <- self.getat
      if r !== nil then r <- (view r as hasInstCT).getinstct end if
    end if
  end getCT

  export operation evaluateManifests
    if ! self$isNotManifest then
      if self$value == nil then
	% set value to the result of doin the invoke
	self$value <- self.execute
      end if
    end if
    FTree.evaluateManifests[self]
  end evaluateManifests

  export function asString -> [r : String]
    r <- "invoc"
  end asString

  export operation flatten [ininvoke : Boolean, indecls : Tree] -> [r : Tree, decls : Tree]
    target, decls <- target.flatten[true, indecls]
    if args !== nil then
      args, decls <- args.flatten[true, decls]
    end if
    if ininvoke then
      const id <- newid.newid
      const asym : Sym <- sym.create[self$ln, id]
      const c : constdecl <- constdecl.create[self$ln, asym, nil, self]
      if decls == nil then 
	decls <- seq.singleton[c]
      else
	decls.rcons[c]
      end if
      r <- sym.create[self$ln, id]
    else
      r <- self
    end if
  end flatten
end Invoc

export Invoc
@


1.58
log
@'./EC'
@
text
@d1104 1
a1104 1
	      "Actual #%d to \"%S[%d]\" does not conform to formal",
@


1.57
log
@'./EC'
@
text
@d928 7
d946 6
a951 1
	env.scheduleDeferredTypeCheck[self, aparam, apsym, avalue, i]
d954 3
d1058 4
a1061 4
    [aparam : Param,
     apsym : Symbol,
     avalue : Tree,
     i : Integer]
d1064 5
d1071 12
a1082 9
      const parameterType <- aparam$xtype.execute.asType
      const parameterConstraint <- view apsym$value as Tree
      const argumentValue <- view avalue as hasConforms
      const argumentType <- view (view argumentValue as Tree).getAT as hasConforms
      if tem then
	env.printf["  parameter %d type is %S\n", {i + 1, parameterType}]
	env.printf["  parameter %d constraint is %S\n", {i + 1, parameterConstraint}]
	env.printf["  argument %d type is %S\n", {i + 1, argumentType}]
	env.printf["  argument %d value is %S\n", {i + 1, argumentValue}]
d1084 50
a1133 11
      if !argumentType.conformsTo[ln, parameterType] then
	env.SemanticError[ln, 
	  "Actual #%d to \"%S[%d]\" does not conform to formal",
	  { i + 1, xopname, self$nargs }]
	self$value <- Literal.NilL[0]
      elseif parameterConstraint !== nil and
	!argumentValue.ConformsTo[ln, parameterConstraint] then
	env.SemanticError[ln, 
	  "Actual #%d to \"%S[%d]\" does not match constraint on formal",
	  { i + 1, xopname, self$nargs }]
	self$value <- Literal.NilL[0]
@


1.56
log
@Many changes
@
text
@d140 5
d153 5
@


1.55
log
@Flatten invocations to reduce jibberish on the stack
@
text
@d992 1
a992 1
      if oldfilename !== nil and oldfilename != filename then
@


1.54
log
@Make type stuff work
@
text
@a425 1
      var needConversion : Boolean <- false
d444 1
a444 17
      if prims$xvar == nil then
	% See if we have to generate vars and then convert
	% we have to do this if
	%   extravals > 0 and self$target contains an invoke, or
	%   (prims$xself !== nil or extravals > 0) and arg[0] contains an invoke, or
	%   args[1..n] contains an invoke
	needConversion <- 
	  extravals > 0 and self$target.containsInvoke or
	  (prims$xself !== nil or extravals > 0) and self$args !== nil and self$args[0].containsInvoke
	if self$args == nil then lt <- 0 else lt <- self$args.upperbound end if
	for i : Integer <- 1 while !needConversion and i <= lt by i <- i + 1
	  needConversion <- self$args[i].containsInvoke
	end for
	if needConversion then
	  generatedSize <- 8
	end if
      else
a490 6
	  if needConversion then
	    bc.addCode["CVX"]
	    bc.addValue[2, 1]
	    generatedSize <- 4
	    needConversion <- false
	  end if
a500 8
      if needConversion then
	% convert all the 8 byte things back to 4.  
	var nvalues : Integer <- self.count[prims$vals]
	if prims$xself !== nil then nvalues <- nvalues + 1 end if
	bc.addCode["CVX"]
	bc.addValue[nvalues, 1]
	generatedSize <- 4
      end if
d1002 1
a1002 1
    if false then
d1007 1
a1007 1
    if false then
d1115 19
a1133 3
  export operation containsInvoke -> [r : Boolean]
    r <- true
  end containsInvoke
@


1.53
log
@Implement defered type checking of manifest invocs
@
text
@d10 2
d80 9
d90 1
d92 21
a112 4
    if self$value == nil then
      var targetct   : Tree <- self$target.getCT
      var targettype : Tree <- self$target.getAT
      if targetct == nil and targettype !== nil then
d115 57
a171 4
      var theopsig : OpSig
      const env <- Environment$env
      const opst <- xopname$name
      var foundType : Boolean <- false
d173 91
a263 4
      if targetct !== nil then
	if env$tracetypeCheck then
	  env.printf["invoc.check of \"%s\" on %d, ct is %s\n",
	    { opst, ln, targetct.asString }]
d266 65
a330 55
      if targetct !== nil and nameof targetct = "anoblit" then
	const tob <- view targetct as Oblit
	isNone <- tob$codeOID = 0x1807
	var theopdef : OpDef
	theopdef, opNumber <- tob.findOp[xopname, self.isSelf, self$nargs, 0]
	opNumber <- -opNumber
	foundType <- true
	if theopdef !== nil then
	  theopsig <- view theopdef$sig as OpSig
	end if
	if env$tracetypeCheck then
	  env.printf["invoc.check of \"%s\" on %d, got sig from ct,self? %s\n",
	    { opst, ln, self.isSelf.asString }]
	end if
      elseif targettype !== nil then
	if nameof targettype = "abuiltinlit" then
	  const ttbID : Integer <- (view targettype as BuiltinLit)$id
	  isNone <- ttbID = 0x1007 or ttbID = 0x1607
	  const newtargettype <- (view targettype as hasinstat)$instAT
	  if newtargettype !== nil then targettype <- newtargettype end if
	end if
	if nameof targettype = "aglobalref" then
	  const ttgID : Integer <- (view targettype as GlobalRef)$id
	  isNone <- ttgID = 0x1007 or ttgID = 0x1607
	  const newtargettype <- targettype.asType
	  if newtargettype !== nil then targettype <- newtargettype end if
	end if
	if nameof targettype = "anatlit" then
	  const targetat <- view targettype as ATLit
	  isNone <- targetat$id = 0x1607
	  foundType <- true
	  targetat.assignTypes
	  theopsig, opNumber <- targetat.findOp[xopname, self$nargs, 0] 
	end if
	if env$tracetypeCheck then
	  env.printf["invoc.check of \"%s\" on %d, got sig from at\n",
	    { opst, ln}]
	end if
      end if
      if !foundType then
	if env$tracetypeCheck then
	  env.printf["invoc.check of \"%s\" on %d: theopsig = nil\n",
	    { opst, ln }]
	end if
	if env$useAbCons then
	  env.SemanticError[self$ln, 
	    "Can't find an operation signature for operation %s[%d]", 
	    {opst, self$nargs}]
	end if
      elseif theopsig == nil then
	if isNone then
	  % No problem, the target has type None, so has all operations
	else
	  env.SemanticError[ln, "Operation %s[%d] is not defined",
	    { opst, self$nargs }]
d332 2
a333 12
      elseif theopsig$mustBeCompilerExecuted then
	env.SemanticError[ln, "Operation \"%s[%d]\" must be manifest, but isn't",
	  { opst, self$nargs }]
      else
	var opsignress, opsignargs : Integer
	var limit : Integer
	var opsigargs : Tree <- theopsig$params
	
	if opsigargs == nil then
	  opsignargs <- 0
	else
	  opsignargs <- opsigargs.upperbound + 1
d335 2
a336 2
	if theopsig$results == nil then
	  opsignress <- 0
d338 1
a338 1
	  opsignress <- theopsig$results.upperbound + 1
d340 18
a357 25
	if opsignargs != self$nargs then
	  env.SemanticError[ln,
	    "Number of arguments %d incorrect, \"%s\" expects %d",
	    { self$nargs, opst, opsignargs }]
	end if
%	if opsignress != self$nress then
%	  env.SemanticError[self$ln,
%	    "Number of results %d incorrect, \"%s\" returns %d",
%	    { self$nress, opst, opsignress }]
%	end if
	limit <- self$nargs
	if limit > opsignargs then limit <- opsignargs end if
	for i : Integer <- 1 while i <= limit by i <- i + 1
	  const actualtype <- view self$args[i-1].getAT as hasconforms
	  const formaltype <- opsigargs[i-1].asType
	  if actualtype == nil then
	    env.ttypeCheck["invoc.typecheck of \"%s\" on %d, actual %d type is nil\n", 
	      { opst, ln, i} ]
	  elseif formaltype == nil then
	    env.ttypeCheck["invoc.typecheck of \"%s\" on %d, formal %d type is nil\n", 
	      { opst, ln, i } ]
	  elseif !actualType.conformsTo[ln, formalType] then
	    env.SemanticError[ln, 
	      "Actual #%d to \"%s\" does not conform to formal",
	      { i, opst}]
d359 3
d363 1
d365 4
a368 3
      FTree.typeCheck[self]
    else
      self$value.typeCheck
d1107 1
d1113 3
a1115 2
    if self$value !== nil then
      r <- self$value.getat
d1117 2
a1118 81
      var targetct   : Tree <- self$target.getCT
      var targettype : Tree <- self$target.getAT
      var theopsig : Tree

      if targetct !== nil and nameof targetct = "anoblit" then 
	const tob <- view targetct as Oblit
	var theopdef : OpDef
	var index : Integer
	theopdef, index <- tob.findOp[self$xopname, self.isSelf, self$nargs, 0]
	if theopdef == nil then
	  if env$traceAssignTypes then
	    env.printf["invoc.getAT: can't find %s[%d] in oblit\n", 
	      { xopname$name, self$nargs }]
	    targetct.print[env$stdout, 0]
	  end if
	else
	  theopsig <- theopdef$sig
	end if
      end if
      if theopsig == nil and targettype !== nil then
	if env$traceassigntypes then
	  env.printf["invoc.getAT: target type is %s\n",
	    {targettype.asString}]
	end if
	if nameof targettype = "abuiltinlit" then
	  const newtargettype <- (view targettype as hasinstat)$instAT
	  if newtargettype !== nil then
	    targettype <- newtargettype
	    if env$traceassigntypes then
	      env.printf["invoc.getAT: target type is now %s\n", {targettype.asString}]
	    end if
	  end if
	end if
	if nameof targettype = "anatlit" then
	  const targetat <- view targettype as ATLit
	  var index : Integer
	  theopsig, index <- targetat.findOp[self$xopname, self$nargs, 0]
	end if
      else
	if env$traceassignTypes then
	  env.printf["Invoc.getAT, target is %s, targetct and targettype are nil\n",
	    {self$target.asString}]
	end if
      end if
      if theopsig == nil then
	if env$traceassignTypes then
	  env.printf["invoc.getAT: theopsig is nil\n", nil]
	end if
      else
	const theResults <- (view theopsig as OpSig)$results
	if theResults == nil then
	  if nress = 0 then
	    r <- Seq.create[ln]
	  else
	    env.SemanticError[ln, "Invocation %S[%d] returns 0 results, %d are expected", { xopname, self$nargs, nress} ]
	    r <- self.fakeResultTypes
	  end if
	elseif nress != theResults.upperbound + 1 then
	  env.SemanticError[ln, "Invocation %S[%d] returns %d results, %d are expected", { xopname, self$nargs, theResults.upperbound + 1, nress } ]
	  r <- self.fakeResultTypes
	else
	  var theType : Tree
	  for i : Integer <- 0 while i <= theResults.upperbound by i <- i + 1
	    theType <- theResults[i].asType
	    if nameof theType = "abuiltinlit" then
	      theType <- (view theType as hasInstAT).getInstAT
	    end if
	    if env$traceassignTypes then
	      env.printf["invoc.getAT:  answer is %s\n", {theType.asString}]
	    end if
	    if theResults.upperbound = 0 then
	      r <- theType
	    else
	      if r == nil then
		r <- Seq.create[0]
	      end if
	      r.rcons[theType]
	    end if
	  end for
	end if
      end if
d1120 1
d1141 1
d1145 1
@


1.52
log
@Stop inlining so agressively in the face of distribution
@
text
@d94 1
a94 1
	    { opst, self$ln, targetct.asString }]
d109 1
a109 1
	    { opst, self$ln, self.isSelf.asString }]
d133 1
a133 1
	    { opst, self$ln}]
d139 1
a139 1
	    { opst, self$ln }]
d150 1
a150 1
	  env.SemanticError[self$ln, "Operation %s[%d] is not defined",
d154 1
a154 1
	env.SemanticError[self$ln, "Operation \"%s[%d]\" must be manifest, but isn't",
d172 1
a172 1
	  env.SemanticError[self$ln,
d188 1
a188 1
	      { opst, self$ln, i} ]
d191 3
a193 3
	      { opst, self$ln, i } ]
	  elseif !actualType.conformsTo[self$ln, formalType] then
	    env.SemanticError[self$ln, 
d474 1
a474 1
      bc.lineNumber[self$ln]
d625 1
a625 1
	    env.printf["invoc on line %d, s = %s\n", { self$ln, s : Any} ]
d748 1
a748 1
	  r <- GlobalRef.create[self$ln, id, nil, codeid, instcodeid, nil]
d772 1
a772 1
    % newst <- SymbolTable.create[(view theopdef as OpDef)$st, CBlock]
d775 2
a776 1
    newst <- SymbolTable.create[env$rootst, CBlock]
d793 1
a793 26
	if env$dotypecheck then
	  const parameterType <- aparam$xtype.execute.asType
	  const parameterConstraint <- view apsym$value as Tree
	  const argumentValue <- view avalue as hasConforms
	  const argumentType <- view (view argumentValue as Tree).getAT as hasConforms
	  if tem then
	    env.printf["  parameter %d type is %S\n", {i + 1, parameterType}]
	    env.printf["  parameter %d constraint is %S\n", {i + 1, parameterConstraint}]
	    env.printf["  argument %d type is %S\n", {i + 1, argumentType}]
	    env.printf["  argument %d value is %S\n", {i + 1, argumentValue}]
	  end if
	  if !argumentType.conformsTo[ln, parameterType] then
	    env.SemanticError[self$ln, 
	      "Actual #%d to \"%S[%d]\" does not conform to formal",
	      { i + 1, xopname, self$nargs }]
	    self$value <- Literal.NilL[0]
	    return
	  elseif parameterConstraint !== nil and
	    !argumentValue.ConformsTo[ln, parameterConstraint] then
	    env.SemanticError[self$ln, 
	      "Actual #%d to \"%S[%d]\" does not match constraint on formal",
	      { i + 1, xopname, self$nargs }]
	    self$value <- Literal.NilL[0]
	    return
	  end if
	end if
d895 34
@


1.51
log
@Fixed a long standing problem with manifest invocs
@
text
@d504 8
a511 2
      if targetCT !== nil and nameof targetCT = "anoblit" and 
	self.tryInline[targetCT, xct] then return end if
@


1.50
log
@Use new streams code
@
text
@d647 4
d732 2
a733 2
	env.printf["Invoc (%s) found %x %x %x\n", 
	  {keystring, id, codeid, instcodeid}]
d739 1
d744 1
d902 1
a902 1
	env.printf["Invoc inserting %s, %x %x %x %s\n",
d904 1
a904 1
	   shouldCacheAnswer.asString : Any}]
d907 1
a907 1
	invoccache.Insert[keystring, thecopy$id, thecopy$codeOID, thecopy$instCTOID, filename, r]
@


1.49
log
@Fix generation of inline field selections
@
text
@d716 3
a718 3
	  shouldCacheAnswer <- 
	    (tashasId$id == 0x100c | tashasid$id == 0x1012)
	    & (xopname$name = "of")
@


1.48
log
@Oops, got the manifests wrong on invocs again
@
text
@d309 1
d316 1
a316 1
	  if bc$size = 4 then
d318 1
d321 1
d329 1
@


1.47
log
@Take care of invoking nil
@
text
@d600 28
a627 4
      elseif self$args !== nil then
	for i : Integer <- 0 while i <= self$args.upperbound by i <- i + 1
	  const arg <- args[i]
	  if arg$isNotManifest or nameof arg = "aliteral" then
d630 3
a632 24
	end for
      else
	var thing : Oblit
	var s : String
	s, thing <- self.findObject[self$target]

	if env$traceevaluatemanifests then
	  env.printf["invoc on line %d, s = %s\n", { self$ln, s : Any} ]
	end if
	if s = "anoblit" then
	  makeNotManifest <- !thing.isAFunction[self$xopname, self$nargs, 0]
	  %
	  % Only because I'm tired of trying things that don't work
	  %
	  makeNotManifest <- makeNotManifest | xopname$name != "of"
	elseif s = "abuiltinlit" then
	  % A builtin literal
	  % this is manifest if the operation is "of"
	  makeNotManifest <- xopname$name != "of"
	else
	  makeNotManifest <- true
	end if
	if env$traceevaluatemanifests then
	  env.printf["makeNonManifest = %s\n", {makeNotManifest.asString}]
@


1.46
log
@Even better semantics checks, avoid invoking nil, fix class
@
text
@d521 11
a531 1
	  opNumber <- -opNumber
@


1.45
log
@Fix a problem with generating inlined field references
@
text
@d588 1
a588 2
      if self$target$isNotManifest or
         self$args !== nil and self$args$isNotManifest then
d590 7
d777 1
a777 1
	      { i, xopname, self$nargs }]
d784 1
a784 1
	      { i, xopname, self$nargs }]
@


1.44
log
@Clean up generating the second things in references
@
text
@d444 1
d447 1
d451 1
a451 1
	    bc.finishExpr[rsy$size, rsym$codeOID, (view rsy$ATinfo as hasID)$id]
@


1.43
log
@Fixed a problem with invoc's first figuring out opNumbers from ATs
and then later getting it from the corresponding CT.
@
text
@d388 2
a389 2
	if bc$size = 4 and generatedSize = 8 then
	  bc.addCode["POOP"]
d402 1
a402 1
	    bc.fetchVariableSecondThing[0x80000000, 0x1601]
d404 1
a404 1
	    bc.fetchVariableSecondThing[u$codeOID, (view thetype as hasID)$id]
d449 1
a449 3
	    if rsy$size = 4 and bc$size = 8 then
	      bc.fetchVariableSecondThing[rsym$codeOID, (view rsy$ATinfo as hasID)$id]
	    end if
d554 7
a560 1
      if bc$size == 4 and self$nress = 1 then bc.addCode["POOP"] end if
@


1.42
log
@Improved constant type assignment
@
text
@d102 1
d517 1
a517 1
	if opNumber == nil then
d521 1
d523 1
d528 1
@


1.41
log
@Inserted a number of additional type checks, put line numbers in literals
@
text
@d484 8
d980 3
@


1.40
log
@August 94 Checkpoint II
@
text
@d2 1
a55 3
    initially
      ln <- target$ln
    end initially
d112 1
a112 1
	  const ttbID <- (view targettype as BuiltinLit)$id
d118 1
a118 1
	  const ttgID <- (view targettype as GlobalRef)$id
d307 1
a307 1
	const offset <- valsym$offset
d361 1
a361 1
	const limit <- number.upperbound
d364 1
a364 1
	  const s <- v$str
d526 1
a526 1
	const name <- xopname$name
d624 1
a624 1
    const tem <- env$traceevaluatemanifests
d754 1
a754 1
	    self$value <- Literal.NilL
d761 1
a761 1
	    self$value <- Literal.NilL
@


1.39
log
@Checkpoint of DIKU August 94 changes
@
text
@d81 1
d101 1
d114 2
d120 2
d127 1
d148 8
a155 1
	env.SemanticError[self$ln, "Operation %s[%d] is not defined",
a156 3
      elseif theopsig$mustBeCompilerExecuted then
	env.SemanticError[self$ln, "Operation \"%s\" must be manifest, but isn't",
	  { opst }]
d177 5
a181 5
	if opsignress != self$nress then
	  env.SemanticError[self$ln,
	    "Number of results %d incorrect, \"%s\" returns %d",
	    { self$nress, opst, opsignress }]
	end if
d754 2
a755 2
	      "Actual #%d to \"%S\" does not conform to formal",
	      { i, xopname }]
d761 2
a762 2
	      "Actual #%d to \"%S\" does not match constraint on formal",
	      { i, xopname }]
d869 12
d886 1
a886 1
    elseif self$nress = 1 then
d931 5
a935 1
      if theopsig !== nil then
d938 5
a942 2
	  if env$traceassigntypes then
	    env.printf["invoc.getAT: sig$results is nil where 1 expected\n", nil]
d944 3
a946 8
	elseif theResults.upperbound = 0 then
	  r <- theResults[0].asType
	  if nameof r = "abuiltinlit" then
	    r <- (view r as hasInstAT).getInstAT
	  end if
	  if env$traceassignTypes then
	    env.printf["invoc.getAT:  answer is %s\n", {r.asString}]
	  end if
d948 18
a965 4
	  if env$traceassignTypes then
	    env.printf["invoc.getAT: sig$nresults wrong, is %s should be 1\n",
	      {theResults.upperbound}]
	  end if
a966 4
      else
	if env$traceassignTypes then
	  env.printf["invoc.getAT: theopsig is nil\n", nil]
	end if
a967 4
    else
      if env$traceassignTypes then
	env.printf["Invoc.getAT, nress = %d\n", {self$nress}]
      end if
a968 1
    
@


1.38
log
@First attempt at abcons
@
text
@d1 1
a1 1
const invoc <- class Invoc (Tree) [xxtarget : Tree, xxopname : Tree, xxargs : Tree]
d7 1
a7 1
    field xopname : OpName <- view xxopname as OpName
d17 1
a17 1
      r <- 2
a22 2
	r <- xopname
      elseif i = 2 then
a29 2
	xopname <- view r as OpName
      elseif i = 2 then
d43 1
a43 1
      var ntarget, nopname, nargs : Tree
a44 1
      if xopname !== nil then nopname <- xopname.copy[i] end if
d46 1
a46 1
      const r <- invoc.create[ln, ntarget, nopname, nargs]
d84 3
d89 1
a89 2
      const opid <- xopname$id
      const opst <- opid.asString
d93 2
a94 1
	env.ttypeCheck["invoc.check of \"%s\" on %d, ct is %s\n",
d96 1
d106 4
a109 2
	env.ttypeCheck["invoc.check of \"%s\" on %d, got sig from ct, self = %s\n",
	  { opst, self$ln, self.isSelf.asString }]
d115 4
d125 4
a128 2
	env.ttypeCheck["invoc.check of \"%s\" on %d, got sig from at\n",
	  { opst, self$ln}]
d131 4
a134 2
	env.ttypeCheck["invoc.check of \"%s\" on %d: theopsig = nil\n",
	  { opst, self$ln }]
d143 3
d175 1
a175 2
	  const opsigparam <- view opsigargs[i-1] as Param
	  const formaltype  <- view (view opsigparam$xsym as Sym)$mysym$ATInfo as Tree
d180 2
a181 2
	    env.ttypeCheck["invoc.typecheck of \"%s\" on %d, formal %d (%s) type is nil\n", 
	      { opst, self$ln, i, (view opsigparam$xsym as Sym).asString} ]
d190 2
a202 32
  export operation findStatement [def : Tree] -> [isPrim : Boolean, ans : Tree]
    const xbody <- (view def as OpDef)$body
    const xstats <- (view xbody as Block)$stats
    if xstats !== nil and xstats.upperbound = 0 then
      const stat <- xstats[0]
      const statname <- nameof stat
      
      if statname = "aprimstat" then
	ans <- stat 
	isPrim <- true
      elseif statname = "anassignstat" then
	const a <- view stat as AssignStat
	var st : Tree
	var name : String
	if a$left .upperbound != 0 then return end if
	if a$right.upperbound != 0 then return end if
	st <- a$right[0]
	name <- nameof st
	if name = "asym" then
	  const sy <- (view st as Sym)$mysym
	  if !sy$isNotManifest or sy$base == 'O' then
	    isPrim <- false
	    ans <- stat
	  end if
	elseif name = "anintlit" then
	  isPrim <- false
	  ans <- stat
	end if
      end if
    end if
  end findStatement

d227 1
d230 4
a233 2
    Environment$env.tinline["Trying an inline of %s on %s\n",
      {self$xopname.asString, ob$name.asString}]
d235 2
a236 1
    if def == nil then return end if
d238 1
a238 2
    if sig$results == nil then
    elseif sig$results.upperbound = 0 then
a239 2
    else
      return
a240 1
    Environment$env.tinline["  Looking for a statement\n", nil]
d242 2
a243 7
    isprim, stat <- self.findStatement[def]
    if stat == nil then
      Environment$env.tinline["  Didn't find one\n", nil]
      return
    else
      Environment$env.tinline["  Found one %s\n", {isprim.asString}]
    end if
d256 1
a256 1
	Environment$env.tinline["  Less prim vals than args\n", nil]
d385 1
a385 1
	    Environment$env.printf["inlined invoc botch, thetype = %s, theopname = %s, thetarget = %s\n", {thetype.asString, self$xopname.asString, ob.asString}]
d400 1
a400 1
      var r : Tree
d405 3
a407 1
      Environment$env.tinline["  Found an assignment statement\n", nil]
d414 4
a417 4
      r <- asss$right[0]
      rname <- nameof r
      if rname = "anintlit" then
	r.generate[bc]
d419 1
a419 1
	rsym<- view r as Sym
d459 1
d461 4
a464 2
      Environment$env.tinline["invoc.inline: %s target is %s\n",
	{self$xopname.asString, self$target.asString}]
d469 3
a471 1
	  Environment$env.tinline["targetType is %s\n", {targetType.asString}]
d475 6
a480 4
      if targetCT == nil then
	Environment$env.tinline["targetCT is nil\n", nil]
      else
	Environment$env.tinline["targetCT is %s\n", {targetCT.asString}]
d517 1
a517 2
	const ashasId <- xopname
	const name <- ashasId$id.asString
d539 2
a540 1
  operation findObject [t : Tree] -> [s : String, r : Oblit]
d542 1
a542 1
    r <- t
d552 1
d577 1
a577 1
	  makeNotManifest <- makeNotManifest | xopname$id.asString != "of"
d581 1
a581 1
	  makeNotManifest <- xopname$id.asString != "of"
d605 1
a605 1
    var args  : VofT
a612 1
    const onashasid<- view self$xopname as hasIdent
d614 2
d623 1
a623 1
      Environment$env$needMoreEvaluateManifest <- true
d626 1
d628 3
a630 3
    if Environment$env$traceevaluatemanifests then
      Environment$env.printf["Invoke.execute, target is \"%s\", opname is %s, on line %d\n",
	{ self$target.asString, onashasid$id.asString, self$ln } ]
d632 3
a634 6
    Environment$env.pass["Invoke.execute, target is \"%s\", opname is %s\n",
      { tarname, onashasid$id.asString : String }]
      
    if self$args !== nil then
      const env <- Environment$env
      args <- VofT.create[self$nargs]
d636 1
a636 1
	var a : Tree <- self$args[i]
a637 4
	if env$traceevaluatemanifests then
	  Environment$env.printf["Invoc: arg %d was a %s\n", {i, a.asString}]
	  a.print[Environment$env$stdout, 5]
	end if
d640 5
d646 1
a646 12
	  if Environment$env$traceEvaluateManifests then
	    Environment$env.printf["Invoke.execute, target is \"%s\", opname is %s, on line %d\n",
	      { self$target.asString, onashasid$id.asString, self$ln } ]
	    Environment$env.printf["  arg %d was %s\n", { i, a.asString }]
	    if xa == nil then
	      Environment$env.printf["  arg %d.execute is nil\n", {i}]
	    else
	      Environment$env.printf["  arg %d.execute is %s\n", {i,xa.asString}]
	    end if
	    Environment$env.printf["  arg %d.execute.asType is nil\n", {i}]
	  end if
	  Environment$env$needMoreEvaluateManifest <- true
d649 1
a649 1
	args[i] <- xxa
d655 1
a655 1
      const argone <- args[0]
d660 1
a660 1
	Environment$env.printf["The invoc of %s on line %d should be manifest but arg[0] is nil\n", {onashasid$id.asString, self$ln}]
d665 1
a665 1
	    { tashasId$id, onashasid$id.asString, aashasid$id }]
d668 1
a668 1
	    & (onashasid$id.asString = "of")
d676 3
a678 3
      filename <- (view Environment$env$filename as hasStr)$str
      if Environment$env$traceevaluatemanifests then
	Environment$env.printf["Invoc (%s) found %x %x %x\n", 
d687 1
a687 1
	  r <- GlobalRef.create[self$ln, id, codeid, instcodeid, nil]
a706 2
    % by this point, theexp had better be an oblit
    thecopy <- view theexp.copy[0] as Oblit
a707 4
    if false then
      Environment$env$stdout.putString["The tree just after the copy\n"]
      thecopy.Print[Environment$env$stdout, 0]
    end if
d713 1
a713 1
    newst <- SymbolTable.create[Environment$env$rootst, CBlock]
d721 5
a725 5
	const aparam  <- theparams[i]
	const apsymdef<- (view aparam as Param)$xsym
	const apsym   <- (view apsymdef as Sym)$mysym
	const asymbol <- newst.define[apsym$myident, SConst, false]
	const avalue   <- args[i]
d727 29
d759 6
d772 1
a772 1
	if aop = 3 then % OP_FORALL
d777 1
a777 1
%	  const asymbol <- newst.define[awsym$myident, SConst, false]
d789 1
a789 1
	elseif aop = 1 then	% OP_WHERE
d793 1
a793 1
	  const asymbol <- newst.define[awsym$myident, SConst, false]
d798 2
a799 1
	  % This is just a constraint, ignore it now
d837 1
a837 1
    Environment$env.tassigntypes["Invoke.execute, assigning types\n", nil]
d840 2
a841 4
    begin
      const t <- (view thecopy$instCT as ObLit)
      if t !== nil then t.setATType end if
    end
d843 1
a843 1
    Environment$env.pass["Invoke.execute, answer is \"%s\"\n", {r.asString}]
d845 2
a846 2
      if Environment$env$traceevaluatemanifests then
	Environment$env.printf["Invoc inserting %s, %x %x %x %s\n",
d859 2
a865 1
      const env <- Environment$env
d876 1
a876 1
	      { self$xopname.asString, self$nargs }]
d884 4
a887 2
	env.tassignTypes["invoc.getAT: target type is %s\n",
	  {targettype.asString}]
d892 3
a894 2
	    env.tassignTypes["invoc.getAT: target type is now %s\n",
	      {targettype.asString}]
d903 4
a906 2
	env.tassignTypes["Invoc.getAT, target is %s, targetct and targettype are nil\n",
	  {self$target.asString}]
d911 3
a913 2
	  env.tassignTypes["invoc.getAT: sig$results is nil where 1 expected\n",
	    nil]
d915 3
a917 12
	  const theResult <- view theResults[0] as Param
	  const itsType <- theResult$xtype
	  const t <- itsType.execute
	  if t == nil then
	    env.tassignTypes["invoc.getAT:  execute failed on\n", nil]
	    itsType.print[env$stdout, 0]
	  else
	    r <- t.asType
	    if nameof r = "abuiltinlit" then
	      r <- (view r as hasInstAT).getInstAT
	    end if
	    env.tassignTypes["invoc.getAT:  answer is %s\n", {r.asString}]
d919 3
d923 4
a926 2
	  env.tassignTypes["invoc.getAT: sig$nresults wrong, is %s should be 1\n",
	    {theResults.upperbound}]
d929 3
a931 1
	env.tassignTypes["invoc.getAT: theopsig is nil\n", nil]
d934 3
a936 1
      Environment$env.tassignTypes["Invoc.getAT, nress = %d\n", {self$nress}]
d950 1
a950 1
	% set value to the right value
@


1.37
log
@Prepare to generate ab/cons and invokes by index
@
text
@d3 2
a4 1
    field resultTypeOID : Integer
a5 1
    var isNotManifest : Boolean <- false
a8 2
    field nress : Integer <- 1
    field abconindex : Integer
d51 3
a53 6
      begin
        const r <- invoc.create[ln, ntarget, nopname, nargs]
	r$isNotManifest <- isNotManifest
	r$opNumber <- opNumber
	newt <- r
      end
d102 1
a102 1
	theopdef, abconindex <- tob.findOp[xopname, self.isSelf, self$nargs, 0]
a110 1
	  const hasinstat <- typeobject t op getInstAT -> [Tree] end t
d118 1
a118 1
	  theopsig, abconindex <- targetat.findOp[xopname, self$nargs, 0] 
a161 1
	  const hasconforms<- typeobject t op conformsTo[Integer, Tree]->[Boolean] end t
d231 1
a231 10
    const bc <- view xct as typeobject T
	op addCode[String]
	op addValue [Integer, Integer]
	op pushSize[Integer]
	op popSize
	op getSize -> [Integer]
	function asString -> [String]
	operation fetchVariableSecondThing[Integer, Integer]
	operation alignTo[Integer]
      end T
a238 1
    const hasGetStr <- typeobject X function getStr -> [String] end X
a240 1
    const hasInstSize <- typeobject t function getInstanceSize -> [Integer] end t
a245 1
    const hasThisObject <- typeobject t function getThisObject -> [Tree] end t
d346 1
a346 1
	first <- (view number[0] as hasGetStr)$str
d378 1
a378 1
	  const v <- view number[i] as hasGetStr
d406 2
a407 2
	  const t <- (view thetype as typeobject t op getInstCT -> [Tree] end t)$instCT
	  const u <- view t as typeobject t operation getCodeOID -> [Integer] end t
d411 1
a411 1
	      {(view thetype as typeobject t op getID -> [Integer] end t)$id, instSize}]
d418 1
a418 1
	    bc.fetchVariableSecondThing[u$codeOID, 0x1601]
d462 1
a462 1
	      bc.fetchVariableSecondThing[rsym$codeOID, 0x1601]
d472 1
a472 8
    const bc <- view xct as typeobject T
	op addCode[String]
	op addValue [Integer, Integer]
	op pushSize[Integer]
	op popSize
	op getSize -> [Integer]
	op lineNumber [Integer]
      end T
d489 1
a489 1
	  targetCT <- (view targetType as typeobject t op getInstCT -> [Tree] end t )$instCT
d513 18
a530 4
      if false then
	% TODO:  We need to find the abstract op number sometime
	bc.addCode["CALL"]
	bc.addValue[self$opNumber, 1]
d555 1
a555 1
  operation findObject [t : Tree] -> [s : String, r : Tree]
a569 1
    const HASISAF <- typeobject HASISAF op isAFunction[Tree,Integer,Integer]->[Boolean] end HASISAF
d579 1
a579 1
	var thing : Tree
d587 1
a587 1
	  makeNotManifest <- !(view thing as HASISAF).isAFunction[self$xopname, self$nargs, 0]
d627 1
a627 1
    const onashasid<- view self$xopname as hasId
a679 1
      const hasIntId <- typeobject t function getId -> [Integer] end t
d681 2
a682 2
      const aashasid <- view argone as hasIntId
      const tashasId <- view tar as hasIntId
d701 1
a701 1
      filename <- (view Environment$env$filename as typeobject t function getStr -> [String] end t)$str
a882 1
	  const hasinstat <- typeobject t op getInstAT -> [Tree] end t
d914 1
a914 1
	      r <- (view r as typeobject t op getInstAT -> [Tree] end t).getInstAT
@


1.36
log
@Preparatory work for Ab/Cons
@
text
@d10 1
d106 2
a107 1
	const theopdef <- tob.findOp[xopname, self.isSelf, self$nargs, 0] 
d124 1
a124 1
	  theopsig <- targetat.findOp[xopname, self$nargs, 0] 
d132 5
d263 1
d269 1
a269 1
    def <- ob.findOp[self$xopname, self.isSelf, self$nargs, self$nress]
d552 2
a553 1
	if Environment$env$usecalloids then
d555 1
a555 1
	  bc.addValue[opnametooid.Lookup[name], 2]
d558 1
a558 1
	  bc.addValue[opnametooid.Lookup[name], 4]
d641 1
d735 1
a735 1
    theopdef <- t.findOp[self$xopname, self.isSelf, self$nargs, 0]
d880 3
a882 1
	const theopdef <- tob.findOp[self$xopname, self.isSelf, self$nargs, 0]
d907 2
a908 1
	  theopsig <- targetat.findOp[self$xopname, self$nargs, 0]
@


1.35
log
@Fix primitives so that full variables are on the stack when invokes
happen.
@
text
@d238 1
a238 1
	operation fetchLiteral[Integer]
d427 1
a427 1
	    bc.fetchLiteral[0x80000000]
d429 1
a429 1
	    bc.fetchLiteral[u$codeOID]
d473 1
a473 1
	    bc.fetchLiteral[rsym$codeOID]
@


1.34
log
@Finalized merge with Mark Immels version
@
text
@d284 2
d303 17
a319 1
      if prims$xvar !== nil then
d362 6
d378 8
d951 3
@


1.33
log
@Generate code for the results of manifest invocs when recompiling
@
text
@d485 2
d490 1
d495 1
d498 1
d506 3
a508 1
	if self$args !== nil then 
d511 1
d520 2
@


1.32
log
@doesn't depend on version of compiler which allows declarations
after statements
@
text
@d585 2
d662 2
a663 1
      id, codeid, instcodeid, resultObject <- InvocCache.Lookup[keystring]
d775 5
a779 1
      thecopy$alreadyGenerated <- true
a782 4
      begin
	const ict <- view thecopy$instCT as oblit
	ict$alreadyGenerated <- true
      end
d810 1
a810 1
	invoccache.Insert[keystring, thecopy$id, thecopy$codeOID, thecopy$instCTOID, r]
d812 1
a812 1
	invoccache.Insert[keystring, thecopy$id, thecopy$codeOID, thecopy$instCTOID, nil]
@


1.31
log
@Type checking errors repaired
@
text
@d722 1
d756 1
a756 1
      const xx <- todo.removeSugar[nil]
@


1.30
log
@Copies must also perform a removeSugar pass
@
text
@d755 1
a755 1
      todo <- todo.removeSugar[nil]
@


1.29
log
@Convert to the new subscript syntax a[b]
@
text
@d755 1
d764 1
@


1.28
log
@Eliminate a[b] as shorthand for self.a[b]
@
text
@d162 2
a163 2
	  const actualtype <- view self$args(i-1).getAT as hasconforms
	  const opsigparam <- view opsigargs(i-1) as Param
d194 1
a194 1
      const stat <- xstats(0)
d206 1
a206 1
	st <- a$right(0)
d313 1
a313 1
	const val <- view prims$vals(i) as Sym
d339 1
a339 1
	first <- (view number(0) as hasGetStr)$str
d343 1
a343 1
	  self$args(0).generate[bc]
d345 1
a345 1
	  self$args(1).generate[bc]
d357 1
a357 1
	  const v <- view number(i) as hasGetStr
d359 1
a359 1
	  if s(0) >= '0' and s(0) <= '9' then
d384 1
a384 1
	  const thetype <- sig$results(0)(1).asType
d415 1
a415 1
      r <- asss$right(0)
d610 1
a610 1
	var a : Tree <- self$args(i)
d633 1
a633 1
	args(i) <- xxa
d640 1
a640 1
      const argone <- args(0)
d645 1
a645 1
	Environment$env.printf["The invoc of %s on line %d should be manifest but arg(0) is nil\n", {onashasid$id.asString, self$ln}]
d688 1
a688 1
    thestat <- thestats(0)
d690 1
a690 1
    theexp  <- theexps(0)
d711 1
a711 1
	const aparam  <- theparams(i)
d715 1
a715 1
	const avalue   <- args(i)
d723 1
a723 1
	const awhere  <- view thewheres(i) as Wherewidgit
d859 1
a859 1
	  const theResult <- view theResults(0) as Param
@


1.27
log
@Avoid invoking nil when executing a manifest invocation
@
text
@d272 1
a272 1
    isprim, stat <- findStatement[def]
d543 1
a543 1
	s, thing <- findObject[self$target]
@


1.26
log
@Redefine STContext and STKind, eliminate Symref and Symdef
@
text
@d792 2
a793 1
      (view thecopy$instCT as ObLit).setATType
@


1.25
log
@Fix calls to SemanticError
@
text
@d203 1
d207 2
a208 1
	if nameof st = "asym" then
d214 3
d403 2
d415 9
a423 8
      rsym<- view asss$right(0) as Sym
      rsy <- rsym$mysym
      if !rsy$isNotManifest then
	(view rsy$value as Tree).generate[bc]
      else
	if self.isself then
	  % Since the target is me, I can just use the right hand side
	  rsym.generate[bc]
d425 3
a427 7
	  % Generate the target
	  bc.pushSize[4]
	  self$target.generate[bc]
	  bc.popSize

	  if bc$size = 4 or rsy$size = 4 then
	    bc.addCode["LDINDS"]
d429 12
a440 4
	    bc.addCode["LDVINDS"]
	  end if
	  bc.addValue[rsy$offset, 2]
	  if rsy$size = 4 and bc$size = 8 then
d442 1
d700 1
a700 1
    % newst <- SymbolTable.create[(view theopdef as OpDef)$st, STContext.CBlock]
d703 1
a703 1
    newst <- SymbolTable.create[Environment$env$rootst, STContext.CBlock]
d714 1
a714 1
	const asymbol <- newst.define[apsym$myident, STKind.SConst, false]
d725 2
a726 2
	const aopname <- FTree.getString[aop]
	if aopname == nil then
d731 1
a731 1
%	  const asymbol <- newst.define[awsym$myident, STKind.SConst, false]
d736 1
a736 1
%	      symdef.create[
d743 1
a743 1
	elseif aopname = "opname (<-)" then
d747 1
a747 1
	  const asymbol <- newst.define[awsym$myident, STKind.SConst, false]
@


1.24
log
@Fix conforms expressions, fix a bug in inline expansion
@
text
@d131 2
a132 1
	env.SemanticError[self$ln, "Operation %s[%d] is not defined\n", { opst, self$nargs }]
d150 1
a150 1
	    "Number of arguments %d incorrect, \"%s\" expects %d\n",
d155 1
a155 1
	    "Number of results %d incorrect, \"%s\" returns %d\n",
d173 1
a173 1
	      "Actual #%d to \"%s\" does not conform to formal\n",
d841 4
a844 1
	if theResults.upperbound = 0 then
@


1.23
log
@Remove unnecessary field in invoc
@
text
@d421 1
a421 1
	  if bc$size = 4 then
d427 3
@


1.22
log
@Execute invocations found in idb
@
text
@a2 1
    field isLocal : Boolean <- false
d10 1
a54 1
	r$isLocal <- isLocal
@


1.21
log
@Identify opnames with the number of arguments
@
text
@d654 1
a654 1
	elseif tarname != "anoblit" or true then
d757 4
@


1.20
log
@Use nameof rather than asString
@
text
@d484 4
d490 1
a490 1
	  bc.addValue[opnametooid.Lookup[ashasId$id.asString], 2]
d493 1
a493 1
	  bc.addValue[opnametooid.Lookup[ashasId$id.asString], 4]
@


1.19
log
@Get rid of return on generate
@
text
@d8 1
a8 1
    field xopname : Tree <- xxopname
d33 1
a33 1
	xopname <- r
d78 1
a78 1
    const t <- self$target.asString
d80 1
a80 1
    if t = "selflit" then
d82 1
a82 1
    elseif t.getSlice[0, 3] = "sym" then
d96 1
a96 1
      const opid <- (view self$xopname as OpName)$id
d104 1
a104 1
      if targetct !== nil and targetct.asString = "oblit" then
d106 1
a106 1
	const theopdef <- tob.findOp[self$xopname, self.isSelf, self$nargs, 0] 
d114 1
a114 1
	if targettype.asString = "builtinlit" then
d119 1
a119 1
	if targettype.asString = "atlit" then
d123 1
a123 1
	  theopsig <- targetat.findOp[self$xopname, self$nargs, 0] 
d195 1
a195 1
      const statname <- stat.asString
d197 1
a197 1
      if statname = "primstat" then
d200 1
a200 1
      elseif statname = "assignstat" then
d206 1
a206 1
	if st.asString.getSlice[0, 3] = "sym" then
d467 1
a467 1
      if targetCT !== nil and targetCT.asString = "oblit" and 
d483 1
a483 1
	const ashasId <- view self$xopname as hasId
d497 1
a497 1
    s <- t.asString.getSlice[0, 5]
d500 1
a500 1
      exit when s != "symre" and s != "symde"
d505 1
a505 1
	s <- r.asString.getSlice[0, 5]
d528 1
a528 1
	if s.length >= 5 and s.getslice[0, 5] = "oblit" then
d533 2
a534 2
	  makeNotManifest <- makeNotManifest | self$xopname.asString != "opname (of)"
	elseif s = "built" then
d537 1
a537 1
	  makeNotManifest <- self$xopname.asString != "opname (of)"
d578 1
a578 1
    tarname <- tar.asString
d650 1
a650 1
	elseif tarname != "oblit" or true then
d657 1
a657 1
    if tarname != "oblit" then return end if
d795 1
a795 1
      if targetct !== nil and targetct.asString = "oblit" then 
d811 1
a811 1
	if targettype.asString = "builtinlit" then
d820 1
a820 1
	if targettype.asString = "atlit" then
d839 1
a839 1
	    if r.asString = "builtinlit" then
@


1.18
log
@Removed all monitors
@
text
@a225 1
    var junk : Any
d303 1
a303 1
        junk <- self$target.generate[bc]
d314 1
a314 1
	  junk <- self$target.generate[bc]
d329 1
a329 1
	  junk <- (view valsym$value as Tree).generate[bc]
d338 1
a338 1
	  junk <- self$args(0).generate[bc]
d340 1
a340 1
	  junk <- self$args(1).generate[bc]
d343 1
a343 1
	  if self$args !== nil then junk <- self$args.generate[bc] end if
d346 1
a346 1
	if self$args !== nil then junk <- self$args.generate[bc] end if
d411 1
a411 1
	junk <- (view rsy$value as Tree).generate[bc]
d415 1
a415 1
	  junk <- rsym.generate[bc]
d419 1
a419 1
	  junk <- self$target.generate[bc]
d434 1
a434 2
  export operation generate [xct : Printable] -> [rct : None]
    var junk : Any
d474 1
a474 1
	junk <- self$args.generate[xct]
d476 1
a476 1
      junk <- self$target.generate[xct]
@


1.17
log
@Implement change to "new" keyword.
@
text
@a1 1
  monitor
d8 1
a8 1
    field opname : Tree <- xxopname
d24 1
a24 1
	r <- opname
d33 1
a33 1
	opname <- r
d50 1
a50 1
      if opname !== nil then nopname <- opname.copy[i] end if
a67 1
  end monitor
d96 1
a96 1
      const opid <- (view self$opname as OpName)$id
d106 1
a106 1
	const theopdef <- tob.findOp[self$opname, self.isSelf, self$nargs, 0] 
d123 1
a123 1
	  theopsig <- targetat.findOp[self$opname, self$nargs, 0] 
d256 2
a257 2
      {self$opname.asString, ob$name.asString}]
    def <- ob.findOp[self$opname, self.isSelf, self$nargs, self$nress]
d384 1
a384 1
	    Environment$env.printf["inlined invoc botch, thetype = %s, theopname = %s, thetarget = %s\n", {thetype.asString, self$opname.asString, ob.asString}]
d455 1
a455 1
	{self$opname.asString, self$target.asString}]
d485 1
a485 1
	const ashasId <- view self$opname as hasId
d531 1
a531 1
	  makeNotManifest <- !(view thing as HASISAF).isAFunction[self$opname, self$nargs, 0]
d535 1
a535 1
	  makeNotManifest <- makeNotManifest | self$opname.asString != "opname (of)"
d539 1
a539 1
	  makeNotManifest <- self$opname.asString != "opname (of)"
d569 1
a569 1
    const onashasid<- view self$opname as hasId
d662 1
a662 1
    theopdef <- t.findOp[self$opname, self.isSelf, self$nargs, 0]
d799 1
a799 1
	const theopdef <- tob.findOp[self$opname, self.isSelf, self$nargs, 0]
d803 1
a803 1
	      { self$opname.asString, self$nargs }]
d824 1
a824 1
	  theopsig <- targetat.findOp[self$opname, self$nargs, 0]
@


1.16
log
@Evaluate manifests in multiple passes
@
text
@d48 1
a48 1
    export operation copy [i : Integer] -> [new : Tree]
d58 1
a58 1
	new <- r
@


1.15
log
@Hide unexported operations from the outside
@
text
@d578 4
d603 10
a612 7
	  Environment$env.printf["Invoke.execute, target is \"%s\", opname is %s, on line %d\n",
	    { self$target.asString, onashasid$id.asString, self$ln } ]
	  Environment$env.printf["  arg %d was %s\n", { i, a.asString }]
	  if xa == nil then
	    Environment$env.printf["  arg %d.execute is nil\n", {i}]
	  else
	    Environment$env.printf["  arg %d.execute is %s\n", {i,xa.asString}]
d614 2
a615 1
	  Environment$env.printf["  arg %d.execute.asType is nil\n", {i}]
a871 1
	assert self$value !== nil
@


1.14
log
@Remove spurious oblit dump on operation not defined errors
@
text
@d79 13
d108 1
a108 1
	const theopdef <- tob.findOp[self$opname, self$nargs, 0] 
d113 2
a114 2
	env.ttypeCheck["invoc.check of \"%s\" on %d, got sig from ct\n",
	  { opst, self$ln}]
d259 1
a259 1
    def <- ob.findOp[self$opname, self$nargs, self$nress]
d416 1
a416 7
        const targetname <- self$target.asString
	var isself : Boolean <- targetname = "selflit"
	if !isself and targetname.getSlice[0, 3] = "sym" then
	  const tsy <- (view self$target as Sym)$mysym
	  isself <- tsy$isSelf 
	end if
	if isself then
d656 1
a656 1
    theopdef <- t.findOp[self$opname, self$nargs, 0]
d793 1
a793 1
	const theopdef <- tob.findOp[self$opname, self$nargs, 0]
@


1.13
log
@Implement calloids
@
text
@d788 5
a792 3
	  env.tassignTypes["invoc.getAT: can't find %s[%d] in oblit\n", 
	    { self$opname.asString, self$nargs }]
	  targetct.print[env$stdout, 0]
@


1.12
log
@Implement padded bytecodes (operands aligned)
@
text
@d481 7
a487 2
	bc.addCode["CALLOID"]
	bc.addValue[opnametooid.Lookup[ashasId$id.asString], 4]
@


1.11
log
@DIKU changes to support TS.of[Integer, String]
@
text
@d224 1
d355 3
@


1.10
log
@Do more work on inlining, and check more carefully
@
text
@d500 2
d505 1
a505 1
      if self$target$isNotManifest or self$nargs != 1 or
d513 3
a515 2
%	Environment$env.printf["invoc on line %d, s = %s\n",
%	  { self$ln, s : Any} ]
d518 3
a520 3
%
%	  Only because I'm tired of trying things that don't work
%
d529 3
a531 1
%	Environment$env.printf["makeNonManifest = %s\n", {makeNotManifest.asString}]
@


1.9
log
@Only cache the tree version of the answer for vector/immutablevector.of
a builtin type.
@
text
@a0 3

export Invoc

d206 8
d267 1
d271 10
d295 27
d607 4
a610 3
	    (tashasId$id == 0x100c | tashasid$id == 0x1012) &
	    (onashasid$id.asString = "of") &
	    (0x1000 <= aashasid$id) & (aashasid$id <= 0x1a00)
d850 2
@


1.8
log
@Prune memory usage
@
text
@d506 1
d563 4
d705 3
a707 2
	Environment$env.printf["Invoc inserting %s, %x %x %x\n",
	  {keystring, thecopy$id, thecopy$codeOID, thecopy$instCTOID : Any}]
d709 5
a713 1
      invoccache.Insert[keystring, thecopy$id, thecopy$codeOID, thecopy$instCTOID, nil]
@


1.7
log
@More objectflag corrections
@
text
@d576 1
a576 1
	elseif tarname != "oblit" then
d703 1
a703 1
      invoccache.Insert[keystring, thecopy$id, thecopy$codeOID, thecopy$instCTOID, r]
@


1.6
log
@type -> typeobject sed
@
text
@d330 1
a330 1
	      {(view thetype as ATLit)$f$isVector.asString}]
@


1.5
log
@Debugging
@
text
@a0 21
import Tree, FTree, Printable from "Jekyll"
import SymbolTable, STContext, STKind from "Jekyll"
import OpnameToOID from "Jekyll"
import hasId from "Jekyll"
import Sym from "Jekyll"
import Oblit from "Jekyll"
import OpSig from "Jekyll"
import OpName from "Jekyll"
import OpDef from "Jekyll"
import Block from "Jekyll"
import Param from "Jekyll"
import AssignStat from "Jekyll"
import Wherewidgit from "Jekyll"
import Seq from "Jekyll"
import Atlit from "Jekyll"
import Symdef from "Jekyll"
import Environment from "Jekyll"
import FormattedOutput from "Jekyll"
import InvocCache from "Jekyll"
import GlobalRef from "Jekyll"
import PrimStat from "Jekyll"
d2 1
a2 1
export Invoc to "Jekyll"
d107 1
a107 1
	  const hasinstat <- type t op getInstAT -> [Tree] end t
d153 1
a153 1
	  const hasconforms<- type t op conformsTo[Integer, Tree]->[Boolean] end t
d211 1
a211 1
    const bc <- view xct as type T
d224 1
a224 1
    const hasGenerateLValue <- type hasGenerateLValue
d227 1
a227 1
    const hasGetStr <- type X function getStr -> [String] end X
d230 1
a230 1
    const hasInstSize <- type t function getInstanceSize -> [Integer] end t
d235 1
a235 1
    const hasThisObject <- type t function getThisObject -> [Tree] end t
d323 2
a324 2
	  const t <- (view thetype as type t op getInstCT -> [Tree] end t)$instCT
	  const u <- view t as type t operation getCodeOID -> [Integer] end t
d328 1
a328 1
	      {(view thetype as type t op getID -> [Integer] end t)$id, instSize}]
d385 1
a385 1
    const bc <- view xct as type T
d394 1
a394 1
      const gs <- type gs
d409 1
a409 1
	  targetCT <- (view targetType as type t op getInstCT -> [Tree] end t )$instCT
d456 1
a456 1
    const HASISAF <- type HASISAF op isAFunction[Tree,Integer,Integer]->[Boolean] end HASISAF
d550 1
a550 1
      const hasIntId <- type t function getId -> [Integer] end t
d731 1
a731 1
	  const hasinstat <- type t op getInstAT -> [Tree] end t
d759 1
a759 1
	      r <- (view r as type t op getInstAT -> [Tree] end t).getInstAT
@


1.4
log
@Make generate return something (currently nothing interesting)
@
text
@d270 2
d273 6
a278 1
    if stat == nil then return end if
@


1.3
log
@Fixed an "invoke nil" bug, now generate message
@
text
@d231 1
d290 1
a290 1
	self$target.generate[bc]
d298 1
a298 1
	  self$args(0).generate[bc]
d300 1
a300 1
	  self$args(1).generate[bc]
d303 1
a303 1
	  if self$args !== nil then self$args.generate[bc] end if
d306 1
a306 1
	if self$args !== nil then self$args.generate[bc] end if
d368 1
a368 1
	(view rsy$value as Tree).generate[bc]
d378 1
a378 1
	  rsym.generate[bc]
d382 1
a382 1
	  self$target.generate[bc]
d397 2
a398 1
  export operation generate [xct : Printable]
d438 1
a438 1
	self$args.generate[xct]
d440 1
a440 1
      self$target.generate[xct]
@


1.2
log
@Implemented inlining of trivial "fetch" operations
@
text
@d764 10
a773 3
	  r <- itsType.execute.asType
	  if r.asString = "builtinlit" then
	    r <- (view r as type t op getInstAT -> [Tree] end t).getInstAT
a774 1
	  env.tassignTypes["invoc.getAT:  answer is %s\n", {r.asString}]
@


1.1
log
@Initial revision
@
text
@d90 3
d203 1
a203 1
  export operation findStatement [def : Tree] -> [ans : PrimStat]
d211 15
a225 1
	ans <- view stat as PrimStat
d242 1
a242 1
    var stat : PrimStat
d254 1
d269 1
a269 1
    stat <- findStatement[def]
d272 32
a303 26
    % Check that if there is 1 result that it is also the left of the
    % primstat  

    % Check that the args are in the same order as the prim vals
    
    instSize <- ob$instanceSize  

    if stat$xvar !== nil then
      % all things are assumed vars
      generatedSize <- 8
    end if
    bc.pushSize[generatedSize]	

    if stat$xself !== nil then
      self$target.generate[bc]
    end if

    if instSize == ~8 and stat$number !== nil then
      first <- (view stat$number(0) as hasGetStr)$str
      if first = "SET" then
	assert stat$vals.upperbound = 1
	assert self$args.upperbound = 1
	self$args(0).generate[bc]
	bc.pushSize[8]
	self$args(1).generate[bc]
	bc.popSize
d307 9
a315 18
    else
      if self$args !== nil then self$args.generate[bc] end if
    end if
      
    if stat$number !== nil then
      const limit <- stat$number.upperbound
      for i : Integer <- stat$number.lowerbound while i <= limit by i <- i + 1
	const v <- view stat$number(i) as hasGetStr
	const s <- v$str
	if s(0) >= '0' and s(0) <= '9' then
	  const primno <- Integer.Literal[s]
	  bc.addValue[primno, 1]
	else
	  if s = "SET" and instSize = ~8 then
	    bc.addCode["SETV"]
	  elseif s = "GET" and instSize = ~8 then
	    bc.addCode["GETV"]
	    generatedSize <- 8
d317 8
a324 1
	    bc.addCode[s]
d326 24
d351 5
d357 21
a377 20
      end for
    end if
    bc.popSize
    if nResults > 0 then
      % Worry about if the context needs a different size
      if bc$size = 4 and generatedSize = 8 then
	bc.addCode["POOP"]
      elseif bc$size = 8 and generatedSize = 4 then
	const thetype <- sig$results(0)(1).asType
	const t <- (view thetype as type t op getInstCT -> [Tree] end t)$instCT
	const u <- view t as type t operation getCodeOID -> [Integer] end t
	if t == nil then
	  Environment$env.printf["inlined invoc botch, thetype = %s, theopname = %s, thetarget = %s\n", {thetype.asString, self$opname.asString, ob.asString}]
	  Environment$env.printf["  the type id = %#x instSize = %d\n", 
	    {(view thetype as type t op getID -> [Integer] end t)$id, instSize}]
	  Environment$env.printf["  the type.isVector = %s\n", 
	    {(view thetype as ATLit)$f$isVector.asString}]
	  Environment$env.printf["  the type.name = %s\n", 
	    {(view thetype as ATLit)$name.asString}]
	  bc.fetchLiteral[0x80000000]
d379 11
a389 1
	  bc.fetchLiteral[u$codeOID]
@
