head	1.58;
access;
symbols
	105alpha:1.57
	104alpha:1.56
	103alpha:1.56
	102alpha:1.56
	101alpha:1.56
	100alpha:1.56
	DIKU_0:1.41
	carlton_start:1.34
	immel_start:1.12;
locks; strict;


1.58
date	2007.06.11.01.37.15;	author norm;	state Exp;
branches;
next	1.57;

1.57
date	98.08.11.19.29.56;	author norm;	state Exp;
branches;
next	1.56;

1.56
date	98.02.09.18.16.37;	author norm;	state Exp;
branches;
next	1.55;

1.55
date	97.01.22.00.03.20;	author norm;	state Exp;
branches;
next	1.54;

1.54
date	96.09.03.04.14.47;	author norm;	state Exp;
branches;
next	1.53;

1.53
date	96.03.28.23.05.29;	author norm;	state Exp;
branches;
next	1.52;

1.52
date	96.03.19.22.43.30;	author norm;	state Exp;
branches;
next	1.51;

1.51
date	95.11.23.17.14.17;	author norm;	state Exp;
branches;
next	1.50;

1.50
date	95.06.23.22.16.28;	author norm;	state Exp;
branches;
next	1.49;

1.49
date	95.06.22.04.45.16;	author norm;	state Exp;
branches;
next	1.48;

1.48
date	95.06.12.17.28.42;	author norm;	state Exp;
branches;
next	1.47;

1.47
date	95.04.04.05.08.43;	author norm;	state Exp;
branches;
next	1.46;

1.46
date	95.03.04.07.08.22;	author norm;	state Exp;
branches;
next	1.45;

1.45
date	94.12.06.20.12.48;	author norm;	state Exp;
branches;
next	1.44;

1.44
date	94.10.04.05.34.24;	author norm;	state Exp;
branches;
next	1.43;

1.43
date	94.10.01.07.55.40;	author norm;	state Exp;
branches;
next	1.42;

1.42
date	94.09.16.21.03.55;	author norm;	state Exp;
branches;
next	1.41;

1.41
date	94.08.22.23.43.50;	author norm;	state Exp;
branches;
next	1.40;

1.40
date	94.08.17.16.51.25;	author norm;	state Exp;
branches;
next	1.39;

1.39
date	94.06.10.05.21.58;	author norm;	state Exp;
branches;
next	1.38;

1.38
date	94.06.08.15.24.42;	author norm;	state Exp;
branches;
next	1.37;

1.37
date	94.03.02.19.00.09;	author norm;	state Exp;
branches;
next	1.36;

1.36
date	94.02.01.16.46.15;	author norm;	state Exp;
branches;
next	1.35;

1.35
date	93.12.20.21.09.40;	author norm;	state Exp;
branches;
next	1.34;

1.34
date	93.07.20.18.38.13;	author norm;	state Exp;
branches;
next	1.33;

1.33
date	93.07.15.08.39.03;	author norm;	state Exp;
branches;
next	1.32;

1.32
date	93.06.16.05.20.24;	author norm;	state Exp;
branches;
next	1.31;

1.31
date	93.06.15.15.29.04;	author norm;	state Exp;
branches;
next	1.30;

1.30
date	93.06.09.22.17.57;	author norm;	state Exp;
branches;
next	1.29;

1.29
date	93.06.05.07.45.34;	author norm;	state Exp;
branches;
next	1.28;

1.28
date	93.03.23.04.47.15;	author norm;	state Exp;
branches;
next	1.27;

1.27
date	93.03.21.06.33.03;	author norm;	state Exp;
branches;
next	1.26;

1.26
date	93.03.11.00.13.54;	author norm;	state Exp;
branches;
next	1.25;

1.25
date	93.03.01.03.14.48;	author norm;	state Exp;
branches;
next	1.24;

1.24
date	93.02.25.00.18.06;	author norm;	state Exp;
branches;
next	1.23;

1.23
date	93.02.18.01.07.19;	author norm;	state Exp;
branches;
next	1.22;

1.22
date	93.02.17.17.18.09;	author norm;	state Exp;
branches;
next	1.21;

1.21
date	93.02.17.00.09.07;	author norm;	state Exp;
branches;
next	1.20;

1.20
date	93.01.27.04.41.59;	author norm;	state Exp;
branches;
next	1.19;

1.19
date	92.12.23.15.30.15;	author norm;	state Exp;
branches;
next	1.18;

1.18
date	92.12.12.05.03.16;	author norm;	state Exp;
branches;
next	1.17;

1.17
date	92.12.12.04.13.21;	author norm;	state Exp;
branches;
next	1.16;

1.16
date	92.12.11.01.08.40;	author norm;	state Exp;
branches;
next	1.15;

1.15
date	92.12.10.21.16.03;	author norm;	state Exp;
branches;
next	1.14;

1.14
date	92.11.25.04.43.37;	author norm;	state Exp;
branches;
next	1.13;

1.13
date	92.08.27.21.15.08;	author norm;	state Exp;
branches;
next	1.12;

1.12
date	92.06.03.15.01.45;	author norm;	state Exp;
branches;
next	1.11;

1.11
date	92.03.27.15.35.51;	author norm;	state Exp;
branches;
next	1.10;

1.10
date	91.05.18.12.04.57;	author norm;	state Exp;
branches;
next	1.9;

1.9
date	91.04.22.22.55.11;	author norm;	state Exp;
branches;
next	1.8;

1.8
date	91.04.22.22.55.09;	author norm;	state Exp;
branches;
next	1.7;

1.7
date	91.04.22.22.55.07;	author norm;	state Exp;
branches;
next	1.6;

1.6
date	91.04.22.22.55.05;	author norm;	state Exp;
branches;
next	1.5;

1.5
date	91.04.22.22.55.03;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	91.04.22.22.55.01;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	91.04.22.22.54.59;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	91.04.22.22.54.57;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	91.04.22.22.54.56;	author norm;	state Exp;
branches;
next	;


desc
@
@


1.58
log
@Check in current version
@
text
@
export Oblit

const oblit <- class Oblit (OTree) [xxsfname : Tree, xxname : Tree, xxdecls : Tree, xxops : Tree]
    field codeOID : Integer
    field id : Integer
    field st  : SymbolTable
    field sfname : Tree <- xxsfname
    field xsetq : Tree
    field name : Tree <- xxname
    field myat : Tree
    field xparam : Tree
    field decls : Tree <- xxdecls
    field ops : Tree <- xxops
    field instanceSize : Integer <- 0
    field vectorBrand : Character
    var instct : ObLit
    var instat : Tree

    export operation setBuiltinID [t : Tree]
      const ts <- view t as hasStr
      const thestr : String <- ts.getStr
      const theid <- Integer.Literal[thestr]
      codeOID <- theid + 0x400

      if 0x1000 <= theid and theid <= 0x1040 then
	id <- theid
	ObjectTable.Define[id, self]
	if id = 0x100c then		% VECTOR
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~1
	elseif id = 0x1012 then		% IMMUTABLEVECTOR
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~1
	end if
      elseif 0x1400 <= theid and theid <= 0x1440 then
	if theid = 0x140c then			% VECTOR
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~1
	elseif theid = 0x1412 then		% IMMUTABLEVECTOR
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~1
	elseif theid = 0x1416 then		% VECTOROFCHAR
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~1
	  vectorBrand <- 'c'
	elseif theid = 0x140b then		% STRING
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~1
	  vectorBrand <- 'c'
	elseif theid = 0x140f then		% NODELIST
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~4
	  vectorBrand <- 'X'
	elseif theid = 0x1413 then		% BITCHUNK
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~1
	  vectorBrand <- 'b'
	elseif theid = 0x1419 then		% COPVECTOR
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~4
	  vectorBrand <- 'X'
	elseif theid = 0x141b then		% AOPVECTOR
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~4
	  vectorBrand <- 'X'
	elseif theid = 0x141d then		% APARAMLIST
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~4
	  vectorBrand <- 'x'
	elseif theid = 0x141e then		% VECTOROFINT
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~4
	  vectorBrand <- 'd'
	elseif theid = 0x1421 then		% IVECTOROFANY
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~8
	  vectorBrand <- 'v'
	elseif theid = 0x1423 then		% IVECTOROFINT
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~4
	  vectorBrand <- 'd'
	elseif theid = 0x1427 then		% LITERALLIST
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~4
	  vectorBrand <- 'l'
	elseif theid = 0x1428 then		% VECTOROFANY
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~8
	  vectorBrand <- 'v'
	elseif theid = 0x1429 then		% IVECTOROFSTRING
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~4
	  vectorBrand <- 'X'
	elseif theid = 0x142a then		% VECTOROFSTRING
	  f <- f.setBit[xisVector, true]
	  instanceSize <- ~4
	  vectorBrand <- 'X'
	end if
	ObjectTable.Define[codeOID, self]
      end if
    end setBuiltinID

    export function upperbound -> [r : Integer]
      r <- 5
    end upperbound
    export function getElement [i : Integer] -> [r : Tree]
      if i = 0 then
	r <- sfname
      elseif i = 1 then
	r <- xparam
      elseif i = 2 then
	r <- xsetq
      elseif i = 3 then
	r <- name
      elseif i = 4 then
	r <- decls
      elseif i = 5 then
	r <- ops
      end if
    end getElement
    export operation setElement [i : Integer, r : Tree]
      if i = 0 then
	sfname <- r
      elseif i = 1 then
	xparam <- r
      elseif i = 2 then
	xsetq <- r
      elseif i = 3 then
	name <- r
      elseif i = 4 then
	decls <- r
      elseif i = 5 then
	ops <- r
      end if
    end setElement
    export operation copy [i : Integer] -> [r : Tree]
      var nsfname, nname, ndecls, nops : Tree
      var newob : Oblit
      if sfname !== nil then nsfname <- sfname.copy[i] end if
      if name !== nil then nname <- name.copy[i] end if
      if decls !== nil then ndecls <- decls.copy[i] end if
      if ops !== nil then nops <- ops.copy[i] end if
      newob <- oblit.create[ln, nsfname, nname, ndecls, nops]
      newob$isImmutable <- f.getBit[xisImmutable]
      newob$isVector <- f.getBit[xisVector]
      newob$isMonitored <- f.getBit[xisMonitored]
      newob$isSynchronized <- f.getBit[xisSynchronized]
      newob$monitorMayBeElided <- f.getBit[xmonitorMayBeElided]
      newob$typesAreAssigned <- false
      newob$typesHaveBeenChecked <- false
      newob$alreadyGenerated <- false
      newob$queuedForGeneration <- false
      r <- newob
    end copy
    
  export operation flatten [ininvoke : Boolean, indecls : Tree] -> [r : Tree, outdecls : Tree]
    outdecls <- indecls
    if ininvoke then
      const sid <- newid.newid
      const asym : Sym <- sym.create[self$ln, sid]
      const c : constdecl <- constdecl.create[self$ln, asym, nil, self]
      if outdecls == nil then 
	outdecls <- seq.singleton[c]
      else
	outdecls.rcons[c]
      end if
      r <- sym.create[self$ln, sid]
    else
      r <- self
    end if
  end flatten

    operation iremoveSugar -> [r : Oblit]
      ops <- sugar.doFields[decls, ops]
      r <- self
    end iremoveSugar

    export operation setATType 
      if f.getBit[xisVector] then
	var et : Ident <- Environment$env$ITable.Lookup["nv", 999]
	var s : Symbol <- st.Lookup[ln, et, false]
	if s !== nil then
	  var thetype : Tree <- view s$value as Tree
	  if thetype !== nil then thetype <- thetype.asType end if
	  if thetype == nil then
	    Environment$env.pass["Vector.NV's value is nil\n",nil]
	  else
	    Environment$env.pass["Vector.NV is %s\n", {thetype.asString}]
	    if nameof thetype = "anatlit" then
	      (view thetype as ATLit)$instct <- self
	      Environment$env.pass["Setting instct to %s\n", { self.asString }]
	    end if
	  end if
	else
	  Environment$env.printf["Couldn't find NV for a vector", nil]
	end if
      end if
      if f.getBit[xisVector] and instanceSize = 0 then
	var et : Ident <- Environment$env$ITable.Lookup["elementtype", 999]
	var s : Symbol <- st.Lookup[ln, et, false]
	if s !== nil then
	  var thetype : Tree <- view s$value as Tree
	  var xx : hasVariableSize
	  if thetype !== nil then thetype <- thetype.asType end if
	  if thetype == nil then
	    Environment$env.pass["Vector.elementtype's value is nil\n",nil]
	  else
	    Environment$env.pass["Vec.etype is %s\n", {thetype.asString}]
	    xx <- view thetype as hasVariableSize
	    Environment$env.pass["Vec.etype size is %d\n", {xx.variableSize}]
	    if nameof thetype = "anatlit" then
	      const rr <- view thetype as ATLit
	      Environment$env.pass["Vec.eType.name %s\n", {rr$name.asString}]
	    end if
	    instanceSize <- ~xx.variableSize
	    vectorBrand <- xx.getBrand
	  end if
	else
	  Environment$env.printf["Couldn't find elementtype for a vector", nil]
	end if

      end if
    end setATType

    export operation doAllocation 
      var a, b, c : Integer
      a, b, c <- st.Allocate[0, 0, 0, nil]
    end doAllocation

    export operation findOp [itsname : Ident, isSelf : Boolean, nargs : Integer, nress : Integer] -> [r : OpDef, index : Integer]
      const ystring : String <- itsname$name
      const env <- Environment$env

      if ops !== nil then
	for i : Integer <- 3 while i <= ops.upperbound by i <- i + 1
	  const xop <- view ops[i] as OpDef
	  const xsig <- view xop$sig as OpSig
	  const xname <- xsig$name
	  const xstring : String <- xname$name
	  var xnargs : Integer
	  if xsig$params == nil then 
	    xnargs <- 0
	  else
	    xnargs <- xsig$params.upperbound + 1
	  end if
	  if xstring = ystring and (nargs == nil or xnargs = nargs) then
	    if xop$isExported or isSelf then
	      r <- xop
	      index <- i
	    end if
	    return
	  end if
	end for
      end if
    end findOp
    operation needInitially -> [r : Boolean]
      r <- false
      if f.getBit[xisMonitored] and !f.getBit[xmonitorMayBeElided] or f.getBit[xisSynchronized] then
	r <- true
	return
      end if
      if ops[0] !== nil then
	r <- true
	return
      end if
      if decls !== nil then
	for i : Integer <- 0 while i <= decls.upperbound by i <- i + 1
	  const d <- decls[i]
	  if d$isNotManifest then
	    r <- true
	    return
	  end if
	end for
      end if
      if xsetq !== nil then
	for i : Integer <- 0 while i <= xsetq.upperbound by i <- i + 1
	  const d <- xsetq[i]
	  if d$isNotManifest then
	    r <- true
	    return
	  end if
	end for
      end if
    end needInitially

  export operation assignTypes 
    if !self$typesAreAssigned then
      const namesym <- (view self$name as Sym)$mysym
      self$typesAreAssigned <- true
      if namesym !== nil then
	namesym$ATInfo <- self.getAT
	namesym$CTInfo <- self
      end if
      FTree.assignTypes[self]
      if myat !== nil then myat.assignTypes end if
    end if
  end assignTypes

  export operation print [s : OutStream, indent : Integer]
    s.putstring["oblit @@"]
    s.putint[ln, 0]
    s.putchar[' ']
    if self$id !== nil then
      s.putstring["id = "]
      s.putstring[self$id.asString]
      s.putchar[' ']
    end if
    if self$codeOID !== nil then
      s.putstring["codeoid = "]
      s.putstring[self$id.asString]
      s.putchar[' ']
    end if
    self.printFlags[s]
    if myat !== nil then
      s.putchar['\n']
      for i : Integer <- 0 while i < indent + 2 by i <- i + 1
	s.putchar[' ']
      end for
      s.putstring["at"]
      s.putchar[':']
      myat.print[s, indent]
    end if
    FTree.print[s, indent, self]
  end print

  export operation printsummary
    var t : Integer
    const env <- Environment$env
    primitive self [t] <- []
    env.printf["oblit at %x named %S on line %d ", 
      { t, (view self$name as Sym)$mysym$myident, ln }]
    if self$id !== nil then
      env.printf["id = %x ", { self$id} ]
    end if
    if self$codeOID !== nil then
      env.printf["codeoid = %x ", { self$codeoid} ]
    end if
    self.printFlags[env$stdout]
    env.printf["\n", nil]
  end printsummary

  export operation isAFunction [itsname:Ident, nargs:Integer, nress:Integer] -> [r : Boolean]
    var xop : OpDef
    var index : Integer
    xop, index <- self.findOp[itsname, true, nargs, nress]
    if xop == nil then
      r <- false
    else
      r <- (view xop$sig as OpSig)$isFunction
    end if
  end isAFunction

  export operation findInvocResult [itsname:Ident, nargs:Integer, nress:Integer] -> [ans : Tree]
    var xop : OpDef
    var index : Integer
    xop, index <- self.findOp[itsname, true, nargs, nress]
    if xop !== nil then
      const xbody <- xop$body
      const xstats <- (view xbody as Block)$stats
      if xstats !== nil and xstats.upperbound = 0 then
	const stat <- xstats[0]
	if nameof stat = "anassignstat" then
	  const xassign <- view stat as Assignstat
	  const r <- xassign$right
	  const l <- xassign$left
	
	  if r.upperbound = 0 and l !== nil and l.upperbound = 0 then
	    ans <- r[0]
	  end if
	end if
      end if
    end if
  end findInvocResult
    
  export operation buildSetq [s : Symbol] -> [r : Symbol]
    r <- setq.build[s, self]
  end buildSetq

  operation myatid -> [r : Integer]
    const myatashasid <- view myat as hasID
    r <- myatashasid.getId
  end myatid

  export operation generate [ct : Printable]
    const sfnameashasStr <- view self$sfname as hasStr
    const nameashasId <- view self$name as hasIdent
    const BCType <- ByteCode
    if nameof ct = "actcode" then
      const ctasct <- view ct as CTCode
      const temp <- Template.create

      if self$instanceSize = 0 then 
	self$instanceSize <- self$st$instanceSize 
      end if
      ctasct$instanceSize <- self$instanceSize

      % These are the kinds of objects whose data is stored as literal
      % data rather than as a pointer.
      if self$codeOID = 0x1803 or self$codeOID = 0x1804 or self$codeOID = 0x1806 or self$codeOID = 0x180a then
	ctasct$instanceFlags <- 0
      else
	ctasct$instanceFlags <- 0x20000000
      end if
      if self$isImmutable then
	ctasct$instanceFlags <- ctasct$instanceFlags + 0x40000000
      end if
      ctasct$name <- nameashasId$id$name
      ctasct$filename <- sfnameashasStr.getStr

      Environment$env.tgenerate["Generating oblit name = %s codeOID = %#x\n",
	{ nameashasId$id$name, self$codeOID : Any} ]
      ctasct$id <- self$codeOID

      if self$isVector then
	temp.isVector[self$vectorBrand]
      elseif self$instanceSize = 0 and ! self$isImmutable then
	temp.addOne['d', "pad@@O4"]
	self$instanceSize <- 4
	ctasct$instanceSize <- self$instanceSize
      elseif self$codeOID = 0x1805 then % Condition
	assert self$instanceSize = 8
	temp.addOne['x', "myObject@@O4"]
	temp.addOne['q', "waitingQueue@@O8"]
      else
	self$st.writeTemplate[temp, 'O']
      end if
      ctasct$templ <- temp
      if Environment$env$generateATs and myat !== nil then
	ctasct$mytype <- RefByID.create[self.myatid]
      end if

      % Generate recovery ops[1], process ops[2] and ops
      for i : Integer <- 1 while i <= ops.upperbound by i <- i + 1
	const theop <- ops[i]
	if theop !== nil then
	  theop.generate[ct]
	end if
      end for

      % do the initially
      if self.needInitially then
	begin
	  const ove <- opvectore.create["initially"]
	  const mybc <- bytecode.create[ctasct$literals]
	  const ov <- ctasct$opVec
	  const templ <- Template.create
	  var nparams : Integer <- 0
	  const returnlabel <- mybc.declareLabel
	  const sq <- self$xsetq
	  const init <- ops[0]

	  mybc.nest[returnlabel]
	  ove$templ <- templ
	  ov[0] <- ove
  

	  % Generate the template
	  if init !== nil then
	    const hasBody <- typeobject t function getBody -> [Tree] end t
	    const initst <- (view (view init as hasbody)$body as hasst)$st
	    initst.writeTemplate[templ, 'L']
	  end if

	  mybc.lineNumber[0]

	  % Generate the prolog (allocate space for locals)
	  mybc.setLocalSize[st$localSize]
  
	  % Generate the monitor creation, if necessary
	  if Environment$env$generateconcurrent and f.getBit[xisMonitored] and !f.getBit[xmonitorMayBeElided] then
	    mybc.addCode["MONINIT"]
	  end if

	  if Environment$env$generateconcurrent and f.getBit[xisSynchronized] then
	    mybc.addCode["SYNCHINIT"]
	  end if

	  % Generate the setq (parameter passing) code
	  if sq !== nil then

	    % Count the actual parameters
	    for i : Integer <- 0 while i <= sq.upperbound by i <- i + 1
	      const s <- view sq[i] as Setq
	      const p <- view s$param as Sym
	      const inn  <- view s$inner as Sym
	      const psym <- p$mysym
	      const isym <- inn$mysym

	      if s$isNotManifest then % or if it is a typevariable
		nparams <- nparams + 1
% We should do initiallies just like we do invocations, then we don't need a
% recursive interpreter (we can use the stack directly)
%		if psym$base = 'A' then
%		  psym$base <- 'L'
%		  psym$offset <- ~8 - psym$offset
%		end if
		if isym$isUsedOutsideInitially then
		  mybc.pushSize[inn$mysym$size]
		  p.generate[mybc]
		  inn.generateLValue[mybc]
		  mybc.popSize
		else
		  isym$base   <- psym$base
		  isym$offset <- psym$offset
		end if
	      end if
	    end for
	  end if

	  ove$nargs <- nparams

	  if self$decls !== nil then self$decls.generate[mybc] end if
	  if ops[0] !== nil then
	    ops[0].generate[mybc]
	  end if
	  
	  % Generate the epilog (return and pop args)
	  mybc.lineNumber[self$ln]
	  mybc.defineLabel[returnlabel]
	  mybc.addCode["QUIT"]
	  mybc.addValue[nparams, 1]
  
	  ove$code <- mybc.getString
	  ove$others <- mybc$others
	  begin
	    const lninfo <- mybc.getLNInfo
	    if lninfo !== nil then
	      templ.addLineNumbers[lninfo]
	    end if
	  end
	end
      end if
    elseif self$generateOnlyCT then
      % we are generating a closure, so we just push the ConcreteType
      const bc <- view ct as BCType
      bc.fetchLiteral[self$codeOID]
      bc.finishExpr[4, 0x1818, 0x1618]
    elseif self$isExported then
      self.generateSelf[ct]
    else
      const bc <- view ct as BCType
      const sq <- self$xsetq
      % We need to treat this as an expression, and do a creation

      bc.addCode["PUSHNIL"]
      if sq !== nil then
	bc.pushSize[8]
	for i : Integer <- 0 while i <= sq.upperbound by i <- i + 1
	  const s <- view sq[i] as Setq
	  const o <- view s$outer as Sym
	  if s$isNotManifest then	% or if it is a type variable
	    o.generate[ct]
	  end if
	end for
	bc.popSize
      end if

      bc.fetchLiteral[self$codeOID]
      if self$isVector then
	bc.addCode["LDAB"]
	bc.addValue[0, 1]
	bc.addCode["CREATEVEC"]
      else
	bc.addCode["CREATE"]
      end if
      bc.finishExpr[4, self$codeOID, self.myatid]
    end if
  end generate

  export operation generateSelf [xct : Printable]
    const bc <- view xct as ByteCode
    self.makeMeManifest
    bc.fetchLiteral[self$id]
    bc.finishExpr[4, codeoid, self.myatid]
  end generateSelf

  export operation makeMeManifest 
    if self$id == nil then
      self$id <- nextOID.nextOID
    end if
  end makeMeManifest

  export operation findThingsToGenerate[q : Any]
    if ! self$queuedForGeneration then
      const qt <- view q as aot
      qt.addUpper[self]
      if self$codeOID == nil then
	self$codeOID <- nextOID.nextOID
      end if
      self$queuedForGeneration <- true
      if myat !== nil then
	myat.findThingsToGenerate[q]
      end if
      FTree.findThingsToGenerate[q, self]
    end if
  end findThingsToGenerate

  export operation areMyImportsManifestOrExported -> [badname : String]
    if self$xsetq !== nil then
      for i : Integer <- 0 while i <= self$xsetq.upperbound by i <- i + 1
	const t <- self$xsetq[i]
	const s <- view t as Setq
	if s$isNotManifest then
	  badname <- (view s$inner as Sym)$mysym$myident$name
	  if Environment$env$explainNonManifests then
	    Environment$env.printf["Oblit %s imports nonmanifest symbol %s\n",
	      { (view name as Sym)$mysym$myident$name, badname } ]
	  end if
	end if
      end for
    end if
  end areMyImportsManifestOrExported

  export operation findManifests -> [changed : Boolean]
    changed <- false
    if self$isNotManifest then
      % I'm already decided
    else
      if ! self$isImmutable then
	self$isNotManifest <- true
	self$name$isNotManifest <- true
	changed <- true
      elseif self$st$depth > 2 and (codeoid != nil and codeoid < 0x1a00 or self$isVector) then
	self$isNotManifest <- true
	self$name$isNotManifest <- true
	changed <- true
      else
	if self.areMyImportsManifestOrExported !== nil then
	  self$isNotManifest <- true
	  self$name$isNotManifest <- true
	  changed <- true
	end if
      end if
    end if
    if myat !== nil then changed <- myat.findManifests | changed end if
    changed <- FTree.findManifests[self] | changed
  end findManifests
  
  export operation execute -> [r : Tree]
    if !self$isNotManifest then
      r <- self
    end if
  end execute

  export function asType -> [r : Tree]
%   assert !self$isNotManifest
    if self$isImmutable then
      var s : Tree
      s <- self.findInvocResult[OpName.Literal["getsignature"], nil, 1]
      if s !== nil then
	r <- s.execute
	if r == nil then
	  Environment$env.printf["oblit.astype: execute on %s failed\n",
	    { s.asString}]
	  s.print[Environment$env$stdout, 0]
	else
	  r <- r.asType
	end if
      end if
    end if
    if r == nil and self$id !== nil then
      % We have explicitly exclude Array, Vector, and ImmutableVector from
      % consideration here, as they are not types.
      if 0x1000 <= id and id <= 0x1040 and id != 0x1002 and id != 0x100c and id != 0x1012 then
	r <- builtinlit.create[self$ln, id + 0x600 - 0x1000]
      end if
    end if
  end asType

  export operation evaluateManifests 
    % If I am a closure, then ensure that my setq's are all manifest
    if self$generateOnlyCT then
      if self$xsetq !== nil then
	const upb : Integer <- self$xsetq.upperbound
	var   lwb : Integer <- 0
	if self$xparam !== nil then lwb <- self$xparam.upperbound + 1 end if
	for i : Integer <- lwb while i <= upb by i <- i + 1
	  begin
	    const t <- self$xsetq[i]
	    const s <- view t as Setq
	    if s$isNotManifest then
	      Environment$env.SemanticError[self$ln, "Import of non manifest symbol \"%s\" into closure", { (view s$outer as Sym)$id$name }]
	    end if
	  end
	end for
      end if
    end if
    if ! self$isNotManifest then
      % I am in fact manifest, and need to be created now
      const t <- view self$name as Sym
      if t$mysym$value == nil then
	t$mysym$value <- self
      end if
      self.makeMeManifest
    end if
    if self$codeOID == nil then
      self$codeOID <- nextOID.nextOID
    end if
    if myat !== nil then myat.evaluateManifests end if
    FTree.evaluateManifests[self]
  end evaluateManifests

  export operation removeSugar [ob : Tree] -> [r : Oblit]
    var foo : Tree
    if !self$hasBeenDesugared then
      self$hasBeenDesugared <- true
      r <- self.iremoveSugar[]
      foo <- FTree.removeSugar[r, self]
      assert foo == r
    else
      r <- self
    end if
  end removeSugar

  export operation defineSymbols[pst : SymbolTable]
    const nst <- SymbolTable.create[pst, CObLit]
    const s <- nst.Define[ln, (view self$name as hasIdent)$id, SConst, false]
    nst$mytree <- self
    nst$kind <- SParam
    s$isSelf <- true
    s$value  <- self
    self$st <- nst
    for i : Integer <- 3 while i <= ops.upperbound by i <- i + 1
      const idef <- view ops[i] as OpDef
      const isig <- idef$sig
      const opisname : String <- isig$name$name
      const opisnargs : Integer <- isig$nargs
      const opisnress : Integer <- isig$nress
      for j : Integer <- i + 1 while j <= ops.upperbound by j <- j + 1
	const jdef <- view ops[j] as OpDef
	const jsig <- jdef$sig
	const opjsname : String <- jsig$name$name
	const opjsnargs : Integer <- jsig$nargs
	const opjsnress : Integer <- jsig$nress
	% TODO:  This should also check number of results when we properly 
	% overload on them
	%
	% i.e. and opisnress = opjsnress
	if opisname = opjsname and opisnargs = opjsnargs then
	  Environment$env.SemanticError[jsig$ln, "Operation %s[%d] is multiply defined", { opisname, opisnargs }]
	end if
      end for
    end for
    if self$isImmutable then
      if ops[1] !== nil then
	Environment$env.SemanticError[ln, 
	  "Immutable objects are not allowed recovery sections", nil]
      end if
      if ops[2] !== nil then
	Environment$env.SemanticError[ln, 
	  "Immutable objects are not allowed processes", nil]      
      end if
    end if
    if self$isMonitored then
      if ops[2] !== nil then
	Environment$env.SemanticError[ln, 
	  "Monitored objects are not allowed processes", nil]      
      end if
    end if
    FTree.defineSymbols[nst, self]

    % Go through and pretend that those symbol tables in the 
    % process and recovery are opdefs

    for i : Integer <- 1 while i < 3 by i <- i + 1
      const theop <- ops[i]
      if theop !== nil then
	const hasBody <- typeobject t function getBody -> [Tree] end t
	const thest <- (view (view theop as hasbody)$body as hasst)$st
	thest$context <- COpDef
      end if
    end for

  end defineSymbols

  export operation checkBuiltinInstAT
    if id !== nil or codeOID !== nil then
      const myinstct <- view self.getInstCT as Oblit
  
      Environment$env.pass["Check builtin inst AT\n", nil]
      if myinstct !== nil then
	const myinstid <- myinstct.getCodeOID
	if myinstid !== nil and myinstid <= 0x2000 and
	   myinstid != 0x180c and myinstid != 0x1812 then	% It is a builtin
	  const myinstat <- self.getInstAT
	  Environment$env.pass[" Looking at a builtin %x\n", {myinstid}]
	  if myinstat !== nil then
	    const myinstctsat <- myinstct$myat
	    if myinstctsat !== nil then
	      Environment$env.pass["  Found a %s as myinstct's at\n",
		{nameof myinstctsat}]
	    end if
	    myinstct$myat <- myinstat
	  end if
	end if
      end if
    end if
  end checkBuiltinInstAT
      
  export operation resolveSymbols [pst : SymbolTable, nexp : Integer]
    if self$generateOnlyCT and self$xparam !== nil then
      const ps <- self$xparam
      var asetq : Any
      for i : Integer <- 0 while i <= ps.upperbound by i <- i + 1
	const p <- view ps[i] as Param
	const s <- view p$xsym as Sym
	const sb <- s$mysym
	asetq <- setq.build[sb, self]
      end for
    end if
    FTree.resolveSymbols[self$st, self, 0]
    self.checkBuiltinInstAT
  end resolveSymbols

  export operation typeValue -> [r : Any]
  end typeValue

  export operation getAT -> [r : Tree]
    if self$myat == nil then
      if self$generateOnlyCT then
	self$myat <- builtinlit.create[self$ln, 0x18].getInstAT
      else
	const namehasid <- view self$name as hasIdent
	const nameid <- namehasid$id
	const newid <- Environment.getEnv.getITable.Lookup[nameid$name||"type", 999]
	const sigs <- seq.create[self$ln]
	var theOps : Tree <- self$ops
    
	Environment$env.tassignTypes["oblit.getAT on %s\n", {self$name.asString}]
	if theops !== nil then
	  for i : Integer <- 3 while i <= theops.upperbound by i <- i + 1
	    const xop <- view theops[i] as OpDef
	    const xsig <- view xop$sig as OpSig
	    if xop$isExported then
%	      Environment$env.pass["  op %d %s is exported\n", 
%		{i, xsig$name.asString}]

% if use copy
	      if Environment$env$doingIdsEarly then
		sigs.rcons[xsig.copy[0]]
	      else
		sigs.rcons[xsig.copy[2]]
	      end if
% else
%	      sigs.rcons[xsig]
% end if
	    else
%	      Environment$env.pass["  op %d %s is not exported\n", 
%		{i, xsig$name.asString}]
	    end if
	  end for
	end if
	const newat <- atlit.create[ln, self$sfname.copy[0], Sym.create[ln, newid], sigs]
	if id !== nil then
	  if 0x1000 <= id and id <= 0x1040 then
	    newat$id <- id + 0x200
	  end if
	end if
	if codeoid !== nil then
	  if 0x1800 <= codeoid and codeoid <= 0x1840 then
	    newat$id <- codeoid - 0x200
	  end if
	end if
	if Environment$env$doingIdsEarly then
	  const junk <- newat.removeSugar[nil]
	  if st == nil then 
	    newat.defineSymbols[st]
	    newat.resolveSymbols[st, 0]
	  else
	    newat.defineSymbols[st$outer] 
	    newat.resolveSymbols[st$outer, 0]
	  end if
	end if
	newat.makeMeManifest
	newat$isimmutable <- self$isimmutable
	newat$isVector <- self$isVector
	self$myat <- newat
	const namesym <- (view self$name as Sym)$mysym
	if namesym !== nil then
	  namesym$ATInfo <- newat
	  namesym$CTInfo <- self
	end if
      end if
    end if
    r <- self$myat
  end getAT

  export operation getCT -> [r : Tree]
    if self$generateOnlyCT then
      r <- builtinlit.create[self$ln, 0x18].getInstCT
    else
      r <- self
    end if
  end getCT

  export function getInstCT -> [r : Tree]
    if !self$knowinstct then
      if self$generateOnlyCT then
	% I don't know!!!!  nil will do for now
      else
	instct <- view self.findInvocResult[opname.literal["create"], nil, 1] as ObLit
      end if
      self$knowinstct <- true
    end if
    r <- instct
  end getInstCT

  export function getInstAT -> [r : Tree]
    if !self$knowinstat then
      instat <- self.findInvocResult[opname.literal["getsignature"], nil, 1]
      if instat !== nil then
	instat <- instat.execute.asType
      end if
      self$knowinstat <- true
    end if
    r <- instat
  end getInstAT

  export function getinstCTOID -> [r : Integer]
    const x <- self$instCT
    if x !== nil and nameof x = "anoblit" then
      const y <- view x as hasIDs
      r <- y$codeOID
    end if
  end getinstCTOID

  export function getinstATOID -> [r : Integer]
    const x <- self$instAT
    if x !== nil then
      const xx <- view x as hasID
      r <- xx$ID
    end if
  end getinstATOID

  export operation getATOID -> [oid : Integer]
    const x <- view self.getAT as hasID
    oid <- x$id
  end getATOID

  export operation setATOID [oid : Integer]
    const x <- view self.getAT as typeobject t
      operation setID [Integer]
    end t
    if x == nil then
      Environment$env.pass["Can't set atOID of %S to %#x", {self$name, oid}]
    else
      x$id <- oid
    end if
  end setATOID

  export operation setinstCTOID [oid : Integer]
    const x <- view self$instCT as typeobject t
      operation setCodeOID [Integer]
    end t
    if x == nil then
      Environment$env.pass["Can't set instctoid of %s to %#x", {self$name.asString, oid}]
    else
      x$codeOID <- oid
    end if
  end setinstCTOID

  export operation setinstATOID [oid : Integer]
    const x <- view self$instAT as typeobject t
      operation setID [Integer]
    end t
    if x == nil then
      Environment$env.pass["Can't set instatoid of %s to %#x", {self$name.asString, oid}]
    else
      x$ID <- oid
    end if
  end setinstATOID

  operation pruneList[list : Tree]
    if list !== nil then
      for i : Integer <- 0 while i <= list.upperbound by i <- i + 1
	const p <- list[i] 
	const stype <- p.asType
	const ttype <- view stype as hasID
	const typeid <- ttype$id

	list[i] <- globalref.create[p$ln, typeid, 0x1609, nil, nil, nil]
      end for
    end if
  end pruneList

  export operation prune 
    if self$isPruned then return end if
    self$isPruned <- true

    const namesym <- view name as Sym
    namesym.prune
    (view myat as ATlit).prune
    xsetq <- nil
    decls <- nil

    if ops !== nil and ops.upperbound >= 0 then
      ops[0] <- nil
      ops[1] <- nil
      ops[2] <- nil

      for i : Integer <- 3 while i <= ops.upperbound by i <- i + 1
	const xdef <- view ops[i] as OpDef
	const xsig <- view xdef$sig as OpSig

	if xdef$isInlineable then
	  % can't prune anything, really
	else
	  % I can prune the signature only if the operation is not inlineable
	  self.prunelist[xsig$params]
	  self.prunelist[xsig$results]
	  xdef$body <- nil
	  xdef$st <- nil
	  xsig$st <- nil
	end if
      end for
    end if
  end prune

  export function asString -> [r : String]
    r <- "oblit"
  end asString
end Oblit
@


1.57
log
@Fix storage allocation bug in process and recovery sections
@
text
@d148 1
d259 1
a259 1
      if f.getBit[xisMonitored] and !f.getBit[xmonitorMayBeElided] then
d475 4
d755 6
@


1.56
log
@Cleaned up
@
text
@d751 13
@


1.55
log
@Many changes
@
text
@d601 4
a604 1
	  exit
@


1.54
log
@Fix attached for builtins
@
text
@d86 1
a86 1
	  vectorBrand <- 'd'
a416 1
	Environment$env.Warning[self$ln, "Mutable object with no state", nil]
d420 4
d485 1
a485 1
	      if psym$isNotManifest then % or if it is a typevariable
d547 1
a547 1
	  if o$isNotManifest then	% or if it is a type variable
@


1.53
log
@Flatten invocations to reduce jibberish on the stack
@
text
@d54 1
a54 1
	  vectorBrand <- 'x'
d62 1
a62 1
	  vectorBrand <- 'x'
d66 1
a66 1
	  vectorBrand <- 'x'
d94 1
a94 1
	  vectorBrand <- 'x'
d98 1
a98 1
	  vectorBrand <- 'x'
@


1.52
log
@Stop using mutable objects with no state, changed the name of instanceFlags
@
text
@d156 17
d695 8
a702 3
    r <- self.iremoveSugar[]
    foo <- FTree.removeSugar[r, self]
    assert foo == r
@


1.51
log
@New builtins
@
text
@d383 1
a383 1
	ctasct$instanceTagMask <- 0
d385 4
a388 1
	ctasct$instanceTagMask <- 0x20000000
d399 5
@


1.50
log
@Implement defered type checking of manifest invocs
@
text
@d87 12
@


1.49
log
@Implement unavailable handers
@
text
@d794 1
@


1.48
log
@Handle exported mutable objects and getting their ids assigned
@
text
@d427 1
a427 12
	  begin
	    const localSize : Integer <- self$st$localSize
	    if localSize > 0 then
	      if localSize < 255 * 4 then
		mybc.addCode["LINKB"]
		mybc.addValue[localSize / 4, 1]
	      else
		mybc.addCode["LINK"]
		mybc.addValue[localSize, 2]
	      end if
	    end if
	  end
d794 7
a800 2
	  newat.defineSymbols[st$outer]
	  newat.resolveSymbols[st$outer, 0]
@


1.47
log
@Fix serious GC bugs, add a new builtin
@
text
@d266 1
d285 9
d599 1
d663 1
d779 5
a783 1
	      sigs.rcons[xsig.copy[2]]
d793 4
a796 6
	begin
	  const newat <- atlit.create[ln, self$sfname.copy[0], Sym.create[ln, newid], sigs]
	  if id !== nil then
	    if 0x1000 <= id and id <= 0x1040 then
	      newat$id <- id + 0x200
	    end if
d798 4
a801 4
	  if codeoid !== nil then
	    if 0x1800 <= codeoid and codeoid <= 0x1840 then
	      newat$id <- codeoid - 0x200
	    end if
d803 14
a816 12
	  newat.makeMeManifest
	  newat$isimmutable <- self$isimmutable
	  newat$isVector <- self$isVector
	  self$myat <- newat
	end
	begin
	  const namesym <- (view self$name as Sym)$mysym
	  if namesym !== nil then
	    namesym$ATInfo <- r		% Merge: perhaps self$myat?
	    namesym$CTInfo <- self
	  end if
	end
d879 1
a879 1
      Environment$env.pass["Can't set atOID of %s to %#x", {self$name.asString, oid}]
@


1.46
log
@Fixed a long standing problem with manifest invocs
@
text
@d83 4
@


1.45
log
@Clean up generating the second things in references
@
text
@d283 1
a283 1
  export operation printsummary [s : OutStream]
d285 1
a285 1
    s.putstring["oblit at "]
d287 2
a288 6
    s.putint[t, 0]
    s.putstring[" named "]
    s.putstring[(view self$name as Sym)$mysym$myident.asString]
    s.putstring[" on line "]
    s.putint[ln, 0]
    s.putchar[' ']
d290 1
a290 3
      s.putstring["id = "]
      s.putstring[self$id.asString]
      s.putchar[' ']
d293 1
a293 3
      s.putstring["codeoid = "]
      s.putstring[self$id.asString]
      s.putchar[' ']
d295 2
a296 1
    self.printFlags[s]
@


1.44
log
@Detect exported non-manifest objects that import non-manifest ones
@
text
@d497 1
a497 1
      if bc$size != 4 then bc.fetchVariableSecondThing[0x1818, 0x1618] end if
d526 1
a526 1
      if bc$size != 4 then bc.fetchVariableSecondThing[self$codeOID, self.myatid] end if
d534 1
a534 2
    const size : Integer <- bc$size
    if size != 4 then bc.fetchVariableSecondThing[codeoid, self.myatid] end if
@


1.43
log
@Improved constant type assignment
@
text
@d498 2
d532 1
d559 13
d585 6
a590 13
      elseif self$xsetq !== nil then
	for i : Integer <- 0 while i <= self$xsetq.upperbound by i <- i + 1
	  begin
	    const t <- self$xsetq[i]
	    const s <- view t as Setq
	    if s$isNotManifest then
	      self$isNotManifest <- true
	      self$name$isNotManifest <- true
	      changed <- true
	      exit
	    end if
	  end
	end for
d753 1
a753 1
	self$myat <- builtinlit.create[self$ln, 18].getInstAT
d812 1
a812 1
      r <- builtinlit.create[self$ln, 18].getInstCT
@


1.42
log
@Inserted a number of additional type checks, put line numbers in literals
@
text
@d24 2
d84 1
a85 1
      codeOID <- theid + 0x400
@


1.41
log
@August 94 Checkpoint II
@
text
@d22 1
a22 1
      const thestr <- ts.getStr
d196 1
a196 1
      const ystring <- itsname$name
d204 1
a204 1
	  const xstring <- xname$name
d419 1
a419 1
	    const localSize <- self$st$localSize
d529 1
a529 1
    const size <- bc$size
d608 3
a610 1
      if 0x1000 <= id and id <= 0x1040 then
d666 3
a668 3
      const opisname <- isig$name$name
      const opisnargs <- isig$nargs
      const opisnress <- isig$nress
d672 3
a674 3
	const opjsname <- jsig$name$name
	const opjsnargs <- jsig$nargs
	const opjsnress <- jsig$nress
@


1.40
log
@Checkpoint of DIKU August 94 changes
@
text
@d17 2
a18 2
    field instct : ObLit
    field instat : Tree
d661 31
@


1.39
log
@Reinstalled support for monitored objects and conditions
@
text
@d17 2
d26 1
d131 4
d146 1
a146 1
	var s : Symbol <- st.Lookup[et, false]
d165 1
a165 1
	var s : Symbol <- st.Lookup[et, false]
d195 3
a197 2
    export operation findOp [name : Tree, isSelf : Boolean, nargs : Integer, nress : Integer] -> [r : OpDef, index : Integer]
      const ystring <- (view name as OpName)$id$name
d203 2
a204 2
	  const xname <- view xsig$name as OpName
	  const xstring <- xname$id$name
d304 1
a304 1
  export operation isAFunction [name:Tree, nargs:Integer, nress:Integer] -> [r : Boolean]
d307 1
a307 1
    xop, index <- self.findOp[name, true, nargs, nress]
d315 1
a315 1
  export operation findInvocResult [name:Tree, nargs:Integer, nress:Integer] -> [ans : Tree]
d318 1
a318 1
    xop, index <- self.findOp[name, true, nargs, nress]
d415 2
d529 2
a530 5
    begin
      const size <- bc$size
      const id <- self$codeOID
      if size != 4 then bc.fetchVariableSecondThing[id, self.myatid] end if
    end
d541 1
a541 1
      const qt <- view q as Array.of[Tree]
a592 7
    if self$id !== nil then
      const id <- self$id
      if 0x1000 <= id and id <= 0x1040 then
	r <- builtinlit.create[self$ln, id + 0x600 - 0x1000]
	return
      end if
    end if
d595 1
a595 1
      s <- self.findInvocResult[OpName.Literal["getsignature"],nil,1]
d607 5
d655 1
a655 1
    const s <- nst.Define[(view self$name as hasIdent)$id, SConst, false]
d775 7
a781 6
    var theopdef, thebody, thestats, thestat, theexps, theexp : Tree

    if self$generateOnlyCT then
      % I don't know!!!!  nil will do for now
    else
      r <- self.findInvocResult[opname.literal["create"], nil, 1]
d783 1
d787 6
a792 5
    var theopdef, thebody, thestats, thestat, theexps, theexp : Tree

    r <- self.findInvocResult[opname.literal["getsignature"], nil, 1]
    if r !== nil then
      r <- r.execute.asType
d794 1
d813 16
d850 46
@


1.38
log
@First attempt at abcons
@
text
@d126 2
d215 4
d421 5
@


1.37
log
@Prepare to generate ab/cons and invokes by index
@
text
@d19 1
a19 3
      const ts <- view t as typeobject X
	function getStr -> [String]
      end X
d159 1
a159 5
	  const t <- typeobject t
	    function variableSize->[Integer]
	    function getBrand    ->[Character]
	  end t
	  var xx : t
d165 1
a165 1
	    xx <- view thetype as t
d204 1
a206 1
	    index <- 1
d327 5
a332 3
    const hasStr <- typeobject X
      function getStr -> [String]
    end X
d334 2
a335 10
    const nameashasId <- view self$name as hasId
    const BCType <- typeobject X
      operation addCode [String]
      operation addValue [Integer, Integer]
      operation fetchLiteral [Integer]
      operation fetchVariableSecondThing[Integer, Integer]
      operation pushSize [Integer]
      operation popSize
      function  getSize -> [Integer]
    end X
d366 1
a366 2
	const myatashasid <- view myat as typeobject t function getID -> [Integer] end t
	ctasct$mytype <- RefByID.create[myatashasid.getID]
a396 1
	    const hasst <- typeobject t function getST -> [SymbolTable] end t
d501 1
a501 1
      if bc$size != 4 then bc.fetchVariableSecondThing[self$codeOID, 0x1601] end if
d511 1
a511 1
      if size != 4 then bc.fetchVariableSecondThing[id, 0x1601] end if
d639 1
a639 1
    const s <- nst.Define[(view self$name as hasId)$id, SConst, false]
d695 1
a695 1
	const namehasid <- view self$name as typeobject X function getid->[Ident] end X
d780 1
a780 3
      const y <- view x as typeobject t
	function getCodeOID -> [Integer]
      end t
a785 3
    const xtype <- typeobject t
      function getID -> [Integer]
    end t
d788 1
a788 3
      var xx : xtype
%     Environment$env.printf["oblit.getInstAT -> %s\n", {x.asString}]
      xx <- view x as xtype
@


1.36
log
@Preparatory work for Ab/Cons
@
text
@d192 1
a192 1
    export operation findOp [name : Tree, isSelf : Boolean, nargs : Integer, nress : Integer] -> [r : OpDef]
d212 1
d297 3
a299 1
    const xop <- self.findOp[name, true, nargs, nress]
d308 3
a310 1
    const xop <- self.findOp[name, true, nargs, nress]
@


1.35
log
@Finalized merge with Mark Immels version
@
text
@d338 1
d483 1
a483 1
      if bc$size != 4 then bc.fetchLiteral[0x1818] end if
d510 1
a510 1
      if bc$size != 4 then bc.fetchLiteral[self$codeOID] end if
d520 1
a520 1
      if size != 4 then bc.fetchLiteral[id] end if
@


1.34
log
@Fix the definition of what objects are manifest
@
text
@d264 1
a264 1
      s.putstring["id = "]
d271 24
d351 2
d749 1
a749 1
	    namesym$ATInfo <- r
@


1.33
log
@Nested immutable objects are non-manifest only if builtin
@
text
@d527 1
a527 1
      elseif self$st$depth > 2 and codeoid != nil and codeoid < 0x1a00 then
@


1.32
log
@Convert to the new subscript syntax a[b]
@
text
@d527 1
a527 1
      elseif self$st$depth > 2 then
@


1.31
log
@Eliminate a[b] as shorthand for self.a[b]
@
text
@d197 1
a197 1
	  const xop <- view ops(i) as OpDef
d218 1
a218 1
      if ops(0) !== nil then
d224 1
a224 1
	  const d <- decls(i)
d233 1
a233 1
	  const d <- xsetq(i)
d286 1
a286 1
	const stat <- xstats(0)
d293 1
a293 1
	    ans <- r(0)
d350 1
a350 1
      % Generate recovery ops(1), process ops(2) and ops
d352 1
a352 1
	const theop <- ops(i)
d368 1
a368 1
	  const init <- ops(0)
d372 1
a372 1
	  ov(0) <- ove
d402 1
a402 1
	      const s <- view sq(i) as Setq
d432 2
a433 2
	  if ops(0) !== nil then
	    ops(0).generate[mybc]
d466 1
a466 1
	  const s <- view sq(i) as Setq
d534 1
a534 1
	    const t <- self$xsetq(i)
d589 1
a589 1
	    const t <- self$xsetq(i)
d659 1
a659 1
	const p <- view ps(i) as Param
d686 1
a686 1
	    const xop <- view theops(i) as OpDef
@


1.30
log
@Install a new Builtin IVectorOfInt
@
text
@d614 1
a614 1
    r <- iremoveSugar[]
@


1.29
log
@Byte load/stores, literals on CT basis
@
text
@d72 1
a72 1
	elseif theid = 0x1421 then		% VECTOROFANY
d76 4
a342 3
	if self$codeOID == 0x1818 then
	  temp.isVector['d']
	end if
@


1.28
log
@Fix building ats for closures
@
text
@a305 10
    const CTType <- typeobject X
      operation setInstanceSize [Integer]
      operation setInstanceTagMask [Integer]
      operation setID [Integer]
      operation setName [String]
      function  getName -> [String]
      operation setFileName [String]
      operation getOpVec -> [OpVector]
      operation setTempl [Template]
    end X
d315 1
a315 1
      const ctasct <- view ct as CTType
d339 3
d345 2
a346 1
	ctasct$mytype <- RefByID.create[myat.getID]
d361 1
a361 1
	  const mybc <- bytecode.create
d386 7
a392 2
	      mybc.addCode["LINK"]
	      mybc.addValue[localSize, 2]
d476 2
a477 2
	bc.addCode["LDAS"]
	bc.addValue[0, 2]
@


1.27
log
@Clean up trace output
@
text
@d351 1
a351 1
      if Environment$env$generateATs then
d673 4
a676 4
    if self$generateOnlyCT then
      r <- builtinlit.create[self$ln, 18].getInstAT
    else
      if self$myat == nil then
d720 7
a727 8
      r <- self$myat
      begin
	const namesym <- (view self$name as Sym)$mysym
	if namesym !== nil then
	  namesym$ATInfo <- r
	  namesym$CTInfo <- self
	end if
      end
d729 1
@


1.26
log
@Redefine STContext and STKind, eliminate Symref and Symdef
@
text
@d341 1
a341 1
      Environment$env.pass["Generating oblit name = %s codeOID = %#x\n",
d683 1
a683 1
	Environment$env.pass["oblit.getAT on %s\n", {self$name.asString}]
@


1.25
log
@Fixed printing
@
text
@d620 2
a621 2
    const nst <- SymbolTable.create[pst, STContext.CObLit]
    const s <- nst.Define[(view self$name as hasId)$id, STKind.SConst, false]
d623 1
a623 1
    nst$kind <- STKind.SParam
d704 1
a704 1
	  const newat <- atlit.create[ln, self$sfname.copy[0], symdef.create[ln, newid], sigs]
@


1.24
log
@Fix conforms expressions, fix a bug in inline expansion
@
text
@d251 3
a253 1
    s.putstring["oblit "]
d265 1
a265 6
    if indent == 0 then
      FTree.print[s, indent, self]
    else
      s.putstring[self.asString]
      s.putstring["\n"]
    end if
@


1.23
log
@Implemented more of .* invokes
@
text
@d633 24
d669 1
d681 2
a682 2
	const id <- namehasid$id
	const newid <- Environment.getEnv.getITable.Lookup[id$name||"type", 999]
d708 10
@


1.22
log
@Implement new builtins: ivectorofany, risa
@
text
@d24 1
a24 1
      if 0x1000 <= theid and theid <= 0x1020 then
d33 1
a33 1
      elseif 0x1400 <= theid and theid <= 0x1420 then
@


1.21
log
@Generate type objects for concretetypes
@
text
@d72 4
@


1.20
log
@Execute invocations found in idb
@
text
@d350 3
d510 3
@


1.19
log
@Use nameof rather than asString
@
text
@d500 1
a500 1
    if ! self$alreadyGenerated then
d506 1
a507 1
      self$alreadyGenerated <- true
@


1.18
log
@Get rid of return on generate
@
text
@d139 1
a139 1
	    if thetype.asString = "atlit" then
d165 1
a165 1
	    if thetype.asString = "atlit" then
d282 1
a282 1
	if stat.asString = "assignstat" then
d323 1
a323 1
    if ct.asString = "ct" then
d433 1
d443 1
a443 1
	      templ.addLineNumbers[mybc.getLNInfo]
d719 1
a719 1
    if x !== nil and x.asString = "oblit" then
@


1.17
log
@Fix parsing of operations, initiallies and recoveries
@
text
@d299 1
a299 2
  export operation generate [ct : Printable] -> [rct : None]
    var junk : Any
d355 1
a355 1
	  junk <- theop.generate[ct]
d414 1
a414 1
		  junk <- p.generate[mybc]
d427 1
a427 1
	  if self$decls !== nil then junk <- self$decls.generate[mybc] end if
d429 1
a429 1
	    junk <- ops(0).generate[mybc]
d464 1
a464 1
	    junk <- o.generate[ct]
d625 1
a625 1
      var junk : Any
d630 1
a630 1
	junk <- setq.build[sb, self]
@


1.16
log
@Removed all monitors
@
text
@d4 1
a4 1
const oblit <- class Oblit (OTree) [xxsfname : Tree, xxname : Tree, xxexport : Tree, xxdecls : Tree, xxinitially : Tree, xxops : Tree, xxprocess : Tree]
a12 1
    field xexport : Tree <- xxexport
a13 1
    field yinitially : Tree <- xxinitially
a14 1
    field xprocess : Tree <- xxprocess
d78 1
a78 1
      r <- 8
d90 1
a90 1
	r <- xexport
a91 4
	r <- decls
      elseif i = 6 then
	r <- yinitially
      elseif i = 7 then
a92 2
      elseif i = 8 then
	r <- xprocess
d105 1
a105 1
	xexport <- r
a106 4
	decls <- r
      elseif i = 6 then
	yinitially <- r
      elseif i = 7 then
a107 2
      elseif i = 8 then
	xprocess <- r
d111 1
a111 2
      var nsfname, nname, nxexport, ndecls, nyinitially : Tree
      var nops, nxprocess : Tree
a114 1
      if xexport !== nil then nxexport <- xexport.copy[i] end if
a115 1
      if yinitially !== nil then nyinitially <- yinitially.copy[i] end if
d117 1
a117 3
      if xprocess !== nil then nxprocess <- xprocess.copy[i] end if
      newob <- oblit.create[ln, nsfname, nname, nxexport,
	ndecls, nyinitially, nops, nxprocess]
d188 1
a188 1
	for i : Integer <- 0 while i <= ops.upperbound by i <- i + 1
d210 1
a210 1
      if yinitially !== nil then
d352 7
a358 2
      if self$ops !== nil then junk <- self$ops.generate[ct] end if
      if self$xprocess !== nil then junk <- self$xprocess.generate[ct] end if
d370 1
d378 1
a378 2
	  if self$yinitially !== nil then
	    const init <- self$yinitially
d429 2
a430 2
	  if self$yinitially !== nil then
	    junk <- self$yinitially.generate[mybc]
d653 1
a653 1
	  for i : Integer <- 0 while i <= theops.upperbound by i <- i + 1
@


1.15
log
@Got rid of monitors and fix
@
text
@a4 1
  monitor
d9 1
a9 1
    field setq : Tree
d12 1
a12 1
    field param : Tree
d87 1
a87 1
	r <- param
d89 1
a89 1
	r <- setq
d108 1
a108 1
	param <- r
d110 1
a110 1
	setq <- r
d243 3
a245 3
      if setq !== nil then
	for i : Integer <- 0 while i <= setq.upperbound by i <- i + 1
	  const d <- setq(i)
a252 1
  end monitor
d384 1
a384 1
	  const sq <- self$setq
d470 1
a470 1
      const sq <- self$setq
d539 2
a540 2
      elseif self$setq !== nil then
	for i : Integer <- 0 while i <= self$setq.upperbound by i <- i + 1
d542 1
a542 1
	    const t <- self$setq(i)
d591 2
a592 2
      if self$setq !== nil then
	const upb : Integer <- self$setq.upperbound
d594 1
a594 1
	if self$param !== nil then lwb <- self$param.upperbound + 1 end if
d597 1
a597 1
	    const t <- self$setq(i)
d639 2
a640 2
    if self$generateOnlyCT and self$param !== nil then
      const ps <- self$param
@


1.14
log
@Implement change to "new" keyword.
@
text
@d4 1
a4 1
const oblit <- class Oblit (OTree) [xxsfname : Tree, xxname : Tree, xxexport : Tree, xxdecls : Tree, xxmonitor : Tree, xxops : Tree, xxprocess : Tree]
d16 1
a16 1
    field ymonitor : Tree <- xxmonitor
d98 1
a98 1
	r <- ymonitor
d119 1
a119 1
	ymonitor <- r
d127 1
a127 1
      var nsfname, nname, nxexport, ndecls, nymonitor : Tree
d134 1
a134 1
      if ymonitor !== nil then nymonitor <- ymonitor.copy[i] end if
d138 1
a138 1
	ndecls, nymonitor, nops, nxprocess]
d208 9
a216 7
      for j : Integer <- 0 while j <= 1 by j <- j + 1
	var theops : Tree
	if j = 0 then 
	  theops <- ops 
	else
	  if ymonitor == nil then
	    theops <- nil
d218 1
a218 1
	    theops <- (view ymonitor as XMonitor)$ops
d220 3
a222 12
	end if
	if theops !== nil then
	  for i : Integer <- 0 while i <= theops.upperbound by i <- i + 1
	    const xop <- view theops(i) as OpDef
	    const xsig <- view xop$sig as OpSig
	    const xname <- view xsig$name as OpName
	    const xstring <- xname$id$name
	    var xnargs : Integer
	    if xsig$params == nil then 
	      xnargs <- 0
	    else
	      xnargs <- xsig$params.upperbound + 1
d224 4
a227 9
	    if xstring = ystring and (nargs == nil or xnargs = nargs) then
	      if xop$isExported or isSelf then
		r <- xop
	      end if
	      return
	    end if
	  end for
	end if
      end for
d231 1
a231 1
      if ymonitor !== nil then
a373 1
      if self$ymonitor !== nil then junk <- self$ymonitor.generate[ct] end if
a386 1
	  var reallyhasamonitor : Boolean <- false
d394 6
a399 16
	  if self$ymonitor !== nil then
	    var init : Tree
	    const y <- self$ymonitor
	    if y.asString = "xmonitor" then
	      const m <- view y as XMonitor
	      reallyhasamonitor <- ! m$mayBeElided
	      init <- m$xinitially
	    else
	      init <- y
	    end if
	    if init !== nil then
	      const hasBody <- typeobject t function getBody -> [Tree] end t
	      const hasst <- typeobject t function getST -> [SymbolTable] end t
	      const initst <- (view (view init as hasbody)$body as hasst)$st
	      initst.writeTemplate[templ, 'L']
	    end if
a410 5
	  % Generate the monitor creation, if necessary
	  if Environment$env$generateconcurrent and reallyhasamonitor then
	    mybc.addCode["MONINIT"]
	  end if

d446 2
a447 5
	  if self$ymonitor !== nil then
	    const nm <- view self$ymonitor as typeobject X
	      operation generateInitially [ct : Printable]
	    end X
	    nm.generateInitially[mybc]
a666 4
	var monOps : tree
	if self$ymonitor !== nil then 
	  monOps <- (view self$ymonitor as XMonitor)$ops 
	end if
d669 19
a687 23
	loop
	  if theops !== nil then
	    for i : Integer <- 0 while i <= theops.upperbound by i <- i + 1
	      const xop <- view theops(i) as OpDef
	      const xsig <- view xop$sig as OpSig
	      if xop$isExported then
  %	      Environment$env.pass["  op %d %s is exported\n", 
  %		{i, xsig$name.asString}]
  
  % if use copy
		sigs.rcons[xsig.copy[2]]
  % else
  %	      sigs.rcons[xsig]
  % end if
	      else
  %	      Environment$env.pass["  op %d %s is not exported\n", 
  %		{i, xsig$name.asString}]
	      end if
	    end for
	  end if
	  exit when theOps == monOps
	  theOps <- monOps
	end loop
@


1.13
log
@Fix an off by one in finding manifests
@
text
@d13 1
a13 1
%   field instat : Tree
d82 1
a82 1
      r <- 7
d88 2
d91 1
a91 1
      elseif i = 2 then
d93 1
a93 1
      elseif i = 3 then
d95 1
a95 1
      elseif i = 4 then
d97 1
a97 1
      elseif i = 5 then
d99 1
a99 1
      elseif i = 6 then
d101 1
a101 1
      elseif i = 7 then
d109 2
d112 1
a112 1
      elseif i = 2 then
d114 1
a114 1
      elseif i = 3 then
d116 1
a116 1
      elseif i = 4 then
d118 1
a118 1
      elseif i = 5 then
d120 1
a120 1
      elseif i = 6 then
d122 1
a122 1
      elseif i = 7 then
d497 5
d623 17
d665 1
d673 10
d690 45
a734 9
    if self$myat == nil then
      const namehasid <- view self$name as typeobject X function getid->[Ident] end X
      const id <- namehasid$id
      const newid <- Environment.getEnv.getITable.Lookup[id$name||"type", 999]
      const sigs <- seq.create[self$ln]
      var theOps : Tree <- self$ops
      var monOps : tree
      if self$ymonitor !== nil then 
	monOps <- (view self$ymonitor as XMonitor)$ops 
d736 6
a741 21
  
      Environment$env.pass["oblit.getAT on %s\n", {self$name.asString}]
      loop
	if theops !== nil then
	  for i : Integer <- 0 while i <= theops.upperbound by i <- i + 1
	    const xop <- view theops(i) as OpDef
	    const xsig <- view xop$sig as OpSig
	    if xop$isExported then
%	      Environment$env.pass["  op %d %s is exported\n", 
%		{i, xsig$name.asString}]

% if use copy
	      sigs.rcons[xsig.copy[2]]
% else
%	      sigs.rcons[xsig]
% end if
	    else
%	      Environment$env.pass["  op %d %s is not exported\n", 
%		{i, xsig$name.asString}]
	    end if
	  end for
a742 9
	exit when theOps == monOps
	theOps <- monOps
      end loop
      begin
	const newat <- atlit.create[ln, self$sfname.copy[0], symdef.create[ln, newid], sigs]
	newat.makeMeManifest
	newat$isimmutable <- self$isimmutable
	newat$isVector <- self$isVector
	self$myat <- newat
a744 8
    r <- self$myat
    begin
      const namesym <- (view self$name as Sym)$mysym
      if namesym !== nil then
	namesym$ATInfo <- r
	namesym$CTInfo <- self
      end if
    end
d748 5
a752 1
    r <- self
d758 5
a762 1
    r <- self.findInvocResult[opname.literal["create"], nil, 1]
@


1.12
log
@Hide unexported operations from the outside
@
text
@d565 1
a565 1
	for i : Integer <- 0 while i < self$setq.upperbound by i <- i + 1
@


1.11
log
@Better printing
@
text
@d201 1
a201 1
    export operation findOp [name : Tree, nargs : Integer, nress : Integer] -> [r : OpDef]
d228 3
a230 1
	      r <- xop
d297 1
a297 1
    const xop <- self.findOp[name, nargs, nress]
d306 1
a306 1
    const xop <- self.findOp[name, nargs, nress]
@


1.10
log
@Get rid of objectflags, use otree
@
text
@d275 12
@


1.9
log
@Execute initiallies on the interpreter stack
@
text
@d4 1
a4 1
const oblit <- class Oblit (Tree) [xxsfname : Tree, xxname : Tree, xxexport : Tree, xxdecls : Tree, xxmonitor : Tree, xxops : Tree, xxprocess : Tree]
a5 1
    field f : ObjectFlags <- ObjectFlags.create
a21 8
    export operation setAlreadyGenerated [a : Boolean]
      f$alreadyGenerated <- a
    end setAlreadyGenerated

    export function getAlreadyGenerated -> [r : Boolean]
      r <- f$alreadyGenerated
    end getAlreadyGenerated

d31 1
a31 1
	  f$isVector <- true
d34 1
a34 1
	  f$isVector <- true
d39 1
a39 1
	  f$isVector <- true
d42 1
a42 1
	  f$isVector <- true
d45 1
a45 1
	  f$isVector <- true
d49 1
a49 1
	  f$isVector <- true
d53 1
a53 1
	  f$isVector <- true
d57 1
a57 1
	  f$isVector <- true
d61 1
a61 1
	  f$isVector <- true
d65 1
a65 1
	  f$isVector <- true
d69 1
a69 1
	  f$isVector <- true
d73 1
a73 1
	  f$isVector <- true
d135 2
a136 2
      newob$f$isImmutable <- f$isImmutable
      newob$f$isVector <- f$isVector
d146 1
a146 1
      if f$isVector then
d165 1
a165 1
      if f$isVector and instanceSize = 0 then
a200 6
    export operation getIsNotManifest -> [r : Boolean]
      r <- f$isNotManifest
    end getIsNotManifest
    export operation setIsNotManifest [r : Boolean]
      f$isNotManifest <- r
    end setIsNotManifest
d263 1
a263 1
    if !self$f$typesAreAssigned then
d265 1
a265 1
      self$f$typesAreAssigned <- true
d361 1
a361 1
      if self$f$isVector then
d498 1
a498 1
      if self$f$isVector then
d526 1
a526 1
    if ! self$f$alreadyGenerated then
d533 1
a533 1
      self$f$alreadyGenerated <- true
d539 1
a539 1
    if self$f$isNotManifest then
d542 2
a543 2
      if ! self$f$isImmutable then
	self$f$isNotManifest <- true
d547 1
a547 1
	self$f$isNotManifest <- true
d556 1
a556 1
	      self$f$isNotManifest <- true
d569 1
a569 1
    if !self$f$isNotManifest then
d575 1
a575 1
%   assert !self$f$isNotManifest
d583 1
a583 1
    if self$f$isImmutable then
d600 1
a600 1
    if ! self$f$isNotManifest then
d677 2
a678 2
	newat$f$isimmutable <- self$f$isimmutable
	newat$f$isVector <- self$f$isVector
@


1.8
log
@type -> typeobject sed
@
text
@d450 6
a455 4
		if psym$base = 'A' then
		  psym$base <- 'L'
		  psym$offset <- ~8 - psym$offset
		end if
d499 1
@


1.7
log
@First attempt to deal with code generation with type variables
@
text
@a0 24
import Tree, FTree, Printable from "Jekyll"
import Environment from "Jekyll"
import Symbol, SymbolTable, STContext, STKind from "Jekyll"
import Ident from "Jekyll"
import ObjectFlags from "Jekyll"
import hasId from "Jekyll"
import OpVector from "Jekyll"
import OpVectorE, Template from "Jekyll"
import CreateOne from "Jekyll"
import ByteCode from "Jekyll"
import Sugar from "Jekyll"
import Atlit from "Jekyll"
import Symdef from "Jekyll"
import Setq from "Jekyll"
import OpDef from "Jekyll"
import OpSig from "Jekyll"
import OpName from "Jekyll"
import XMonitor from "Jekyll"
import Block from "Jekyll"
import Assignstat from "Jekyll"
import Sym from "Jekyll"
import nextOID from "Jekyll"
import BuiltinLit from "Jekyll"
import Seq from "Jekyll"
d2 1
a2 1
export Oblit to "Jekyll"
d32 1
a32 1
      const ts <- view t as type X
d179 1
a179 1
	  const t <- type t
d332 1
a332 1
    const hasStr <- type X
d337 1
a337 1
    const CTType <- type X
d347 1
a347 1
    const BCType <- type X
d416 2
a417 2
	      const hasBody <- type t function getBody -> [Tree] end t
	      const hasst <- type t function getST -> [SymbolTable] end t
d471 1
a471 1
	    const nm <- view self$ymonitor as type X
d652 1
a652 1
      const namehasid <- view self$name as type X function getid->[Ident] end X
d726 1
a726 1
      const y <- view x as type t
d734 1
a734 1
    const xtype <- type t
d747 1
a747 1
    const x <- view self$instCT as type t
d758 1
a758 1
    const x <- view self$instAT as type t
@


1.6
log
@Implemented (a first cut at) concurrency
@
text
@d472 1
a472 1
	      if psym$isNotManifest then
d526 1
a526 1
	  if o$isNotManifest then
@


1.5
log
@Debugging
@
text
@d421 1
d434 1
d456 6
@


1.4
log
@Make generate return something (currently nothing interesting)
@
text
@d483 2
@


1.3
log
@Don't allocate space for imported symbols not used outside initially
@
text
@d354 2
a355 1
  export operation generate [ct : Printable]
d407 3
a409 3
      if self$ymonitor !== nil then self$ymonitor.generate[ct] end if
      if self$ops !== nil then self$ops.generate[ct] end if
      if self$xprocess !== nil then self$xprocess.generate[ct] end if
d472 1
a472 1
		  p.generate[mybc]
d483 1
a483 1
	  if self$decls !== nil then self$decls.generate[mybc] end if
d517 1
a517 1
	    o.generate[ct]
@


1.2
log
@Implemented templates for vectors
@
text
@d91 1
a91 1
	  instanceSize <- ~4
a405 1
      if self$setq !== nil then self$setq.generate[ct] end if
d459 5
a463 3
	      const inn <- view s$inner as Sym
	      const sy<- p$mysym
	      if sy$isNotManifest then
d465 3
a467 3
		if sy$base = 'A' then
		  sy$base <- 'L'
		  sy$offset <- ~8 - sy$offset
d469 9
a477 4
		mybc.pushSize[inn$mysym$size]
		p.generate[mybc]
		inn.generateLValue[mybc]
		mybc.popSize
@


1.1
log
@Initial revision
@
text
@d45 1
d80 1
d84 1
d88 1
d92 1
d96 1
d100 1
d104 5
d205 1
d220 1
d368 1
d380 2
d399 3
a401 3
      begin
	const temp <- Template.create
	ctasct$templ <- temp
d403 3
a405 1
      end
@
