head	1.65;
access;
symbols
	105alpha:1.64
	104alpha:1.64
	103alpha:1.64
	102alpha:1.64
	101alpha:1.64
	100alpha:1.64
	DIKU_0:1.50
	carlton_start:1.43
	immel_start:1.18;
locks; strict;


1.65
date	2007.06.11.01.38.32;	author norm;	state Exp;
branches;
next	1.64;

1.64
date	98.03.02.16.38.38;	author norm;	state Exp;
branches;
next	1.63;

1.63
date	98.02.09.18.16.44;	author norm;	state Exp;
branches;
next	1.62;

1.62
date	97.01.22.00.03.20;	author norm;	state Exp;
branches;
next	1.61;

1.61
date	96.03.28.23.05.29;	author norm;	state Exp;
branches;
next	1.60;

1.60
date	95.09.26.15.25.49;	author norm;	state Exp;
branches;
next	1.59;

1.59
date	95.06.23.22.16.28;	author norm;	state Exp;
branches;
next	1.58;

1.58
date	95.06.12.17.28.42;	author norm;	state Exp;
branches;
next	1.57;

1.57
date	95.04.04.05.08.43;	author norm;	state Exp;
branches;
next	1.56;

1.56
date	95.03.29.18.19.54;	author norm;	state Exp;
branches;
next	1.55;

1.55
date	95.03.04.07.08.22;	author norm;	state Exp;
branches;
next	1.54;

1.54
date	95.03.03.05.44.23;	author norm;	state Exp;
branches;
next	1.53;

1.53
date	95.02.09.00.40.16;	author norm;	state Exp;
branches;
next	1.52;

1.52
date	95.02.07.01.48.31;	author norm;	state Exp;
branches;
next	1.51;

1.51
date	94.09.16.21.03.55;	author norm;	state Exp;
branches;
next	1.50;

1.50
date	94.08.25.16.21.13;	author norm;	state Exp;
branches;
next	1.49;

1.49
date	94.08.22.23.43.53;	author norm;	state Exp;
branches;
next	1.48;

1.48
date	94.08.17.16.51.29;	author norm;	state Exp;
branches;
next	1.47;

1.47
date	94.06.08.15.24.42;	author norm;	state Exp;
branches;
next	1.46;

1.46
date	94.03.02.19.00.09;	author norm;	state Exp;
branches;
next	1.45;

1.45
date	94.02.01.16.46.15;	author norm;	state Exp;
branches;
next	1.44;

1.44
date	93.12.20.21.09.40;	author norm;	state Exp;
branches;
next	1.43;

1.43
date	93.07.20.18.39.23;	author norm;	state Exp;
branches;
next	1.42;

1.42
date	93.07.17.06.40.18;	author norm;	state Exp;
branches;
next	1.41;

1.41
date	93.06.25.15.52.18;	author norm;	state Exp;
branches;
next	1.40;

1.40
date	93.06.16.05.20.24;	author norm;	state Exp;
branches;
next	1.39;

1.39
date	93.06.15.15.29.04;	author norm;	state Exp;
branches;
next	1.38;

1.38
date	93.06.11.03.18.51;	author norm;	state Exp;
branches;
next	1.37;

1.37
date	93.06.10.15.51.27;	author norm;	state Exp;
branches;
next	1.36;

1.36
date	93.06.02.22.58.11;	author mueller;	state Exp;
branches;
next	1.35;

1.35
date	93.03.21.06.33.03;	author norm;	state Exp;
branches;
next	1.34;

1.34
date	93.03.12.17.20.38;	author norm;	state Exp;
branches;
next	1.33;

1.33
date	93.03.11.20.39.39;	author norm;	state Exp;
branches;
next	1.32;

1.32
date	93.03.11.00.57.40;	author norm;	state Exp;
branches;
next	1.31;

1.31
date	93.03.11.00.15.30;	author norm;	state Exp;
branches;
next	1.30;

1.30
date	93.03.06.19.48.05;	author norm;	state Exp;
branches;
next	1.29;

1.29
date	93.03.04.19.14.38;	author norm;	state Exp;
branches;
next	1.28;

1.28
date	93.03.02.21.16.38;	author norm;	state Exp;
branches;
next	1.27;

1.27
date	93.01.27.04.41.59;	author norm;	state Exp;
branches;
next	1.26;

1.26
date	92.12.24.18.53.12;	author norm;	state Exp;
branches;
next	1.25;

1.25
date	92.12.23.15.30.15;	author norm;	state Exp;
branches;
next	1.24;

1.24
date	92.12.16.21.27.42;	author norm;	state Exp;
branches;
next	1.23;

1.23
date	92.12.12.05.03.16;	author norm;	state Exp;
branches;
next	1.22;

1.22
date	92.12.12.04.13.21;	author norm;	state Exp;
branches;
next	1.21;

1.21
date	92.12.10.17.07.31;	author norm;	state Exp;
branches;
next	1.20;

1.20
date	92.11.25.04.43.37;	author norm;	state Exp;
branches;
next	1.19;

1.19
date	92.07.29.22.32.00;	author norm;	state Exp;
branches;
next	1.18;

1.18
date	92.04.07.21.12.25;	author norm;	state Exp;
branches;
next	1.17;

1.17
date	92.04.07.18.09.23;	author norm;	state Exp;
branches;
next	1.16;

1.16
date	92.04.06.18.20.27;	author norm;	state Exp;
branches;
next	1.15;

1.15
date	91.08.03.09.26.35;	author norm;	state Exp;
branches;
next	1.14;

1.14
date	91.06.01.18.09.57;	author norm;	state Exp;
branches;
next	1.13;

1.13
date	91.05.22.15.30.17;	author norm;	state Exp;
branches;
next	1.12;

1.12
date	91.05.14.15.54.59;	author norm;	state Exp;
branches;
next	1.11;

1.11
date	91.04.22.22.56.40;	author norm;	state Exp;
branches;
next	1.10;

1.10
date	91.04.22.22.56.37;	author norm;	state Exp;
branches;
next	1.9;

1.9
date	91.04.22.22.56.35;	author norm;	state Exp;
branches;
next	1.8;

1.8
date	91.04.22.22.56.32;	author norm;	state Exp;
branches;
next	1.7;

1.7
date	91.04.22.22.56.30;	author norm;	state Exp;
branches;
next	1.6;

1.6
date	91.04.22.22.56.28;	author norm;	state Exp;
branches;
next	1.5;

1.5
date	91.04.22.22.56.26;	author norm;	state Exp;
branches;
next	1.4;

1.4
date	91.04.22.22.56.25;	author norm;	state Exp;
branches;
next	1.3;

1.3
date	91.04.22.22.56.23;	author norm;	state Exp;
branches;
next	1.2;

1.2
date	91.04.22.22.56.21;	author norm;	state Exp;
branches;
next	1.1;

1.1
date	91.04.22.22.56.19;	author norm;	state Exp;
branches;
next	;


desc
@
@


1.65
log
@Check in current version
@
text
@

const Compiler <- immutable object Compiler
  const CType <- typeobject CType
    operation compile[fileName : String]
    operation eval[code : String]
    operation load[filename : String]
    operation option[name : String, value : Boolean]
    operation setup [OutStream]
    function getenv -> [r : Environment]
  end CType
  export function getSignature -> [r : Signature]
    r <- CType
  end getSignature
  export operation create -> [r : CType]
    r <- object aCompiler
      const it <- IdentTable.create
      var stdout : OutStream
      var fstdout : FormattedOutput
      var scan : Scanner

      const myenv <- object myenv
	  field externalDirectory : Directory
	  field fileName : Tree
	  field itable : IdentTable
	  field nextnumber : Integer
	  field nErrors : Integer <- 0
	  field root : Tree
	  field verbose : Boolean <- false
	  field tracegenerate : Boolean <- false
	  field executenow : Boolean <- false
	  field generatebuiltin : Boolean <- false
	  field tracegeneratedbuiltin : Boolean <- false
	  field tracegeneratedimports : Boolean <- false
	  field traceparse : Boolean <- false
	  field dumpremovesugar : Boolean <- false
	  field dumpassigntypes : Boolean <- false
	  field traceassigntypes : Boolean <- false
	  field dumpevaluatemanifests : Boolean <- false
	  field traceevaluatemanifests : Boolean <- false
	  field optimizeinvocexecute : Boolean <- false
	  field dumpsymbols : Boolean <- false
	  field tracesymbols : Boolean <- false
	  field tracepasses : Boolean <- false
	  field compilingbuiltins : Boolean <- false
	  field compilingcompiler : Boolean <- false
	  field generateviewchecking : Boolean <- true
	  field tracetoplevel : Boolean <- true
	  field tracetypecheck : Boolean <- false
	  field traceallocation : Boolean <- false
	  field traceinline : Boolean <- false
	  field tracesizes : Boolean <- false
	  field dotypecheck : Boolean <- true
	  field warnShadows : Boolean <- true
	  field why : Boolean <- true
	  field fn : String <- "no file name"
	  field scan : Scanner
	  field rootst : SymbolTable
	  field exportTree : Boolean <- true
	  field explainNonManifests : Boolean <- false
	  field perFile : Boolean <- true
	  field nameSpaceFile : String <- nil
	  field traceCode : Boolean <- false
	  field doCompilation : Boolean <- true
	  field doGeneration : Boolean <- true
	  field generateConcurrent : Boolean <- false
	  field generateDebugInfo : Boolean <- true
	  field generateATs : Boolean <- true
	  field padByteCodes : Boolean <- true
	  field useAbCons : Boolean <- false
	  field needMoreEvaluateManifest : Boolean <- true
	  field implicitlyDefineExternals : Boolean <- false
	  field thisObject : Tree <- nil
	  field conformtable : IIBTable <- IIBTable.create[128]
	  field fstdout : FormattedOutput
	  field stdout : OutStream
	  field doingIdsEarly : Boolean <- false
	  const defer <- record defer
	    var p : Invoc
	    var aparam : Any
	    var apsym : Any
	    var avalue : Any
	    var i : Integer
	  end defer
	  const alldefers <- Array.of[defer].empty
  
	  export function getInvoc -> [r : InvocType]
	    r <- Invoc
	  end getInvoc

	  export function getAtlit -> [r : AtlitType]
	    r <- Atlit
	  end getAtlit

	  export function getAny -> [r : Tree]
	    r <- BuiltinLit.create[0, 1]$instAT
	  end getAny

	  export operation newid -> [r : Integer]
	    r <- nextnumber nextnumber <- nextnumber + 1
	  end newid

	  export operation error [s : String]
	    const line : String <- scan.line
	    nErrors <- nErrors + 1
	    fstdout.printf["\"%s\", line %d: syntax error\n", { fn, scan.lineNumber }]
	    if s != "syntax error" then
	      fstdout.printf[s, nil]
	      stdout.putchar['\n']
	    end if
	    if line.length = 0 or line[0] == Character.literal[0] then
	      stdout.putstring["<EOF>\n"]
	    else
	      if line[line.upperbound] = '\0' then
		fstdout.printf["%s\n", {line[0, line.upperbound]}]
	      elseif line[line.upperbound] != '\n' then
		fstdout.printf["%s\n", {line}]
	      else
		fstdout.printf["%s", {line}]
	      end if
	    end if
	    for i : Integer <- 0 while i < scan.position and i < line.length by i <- i + 1
	      if line[i] == '\t' then
		stdout.putchar['\t']
	      else
		stdout.putchar[' ']
	      end if
	    end for
	    stdout.putstring["^\n"]
	  end error

	  export operation errorf [s : String, v : RISA]
	    const line : String <- scan.line
	    nErrors <- nErrors + 1
	    fstdout.printf["Syntax Error \"%s\", line %d\n", { fn, scan.lineNumber }]
	    if s != "syntax error" then
	      fstdout.printf[s, v]
	      stdout.putchar['\n']
	    end if
	    if line[0] == Character.literal[255] then
	      stdout.putstring["<EOF>\n"]
	    else
	      fstdout.printf["%s", {line}]
	    end if
	    for i : Integer <- 0 while i < scan.position by i <- i + 1
	      if line[i] == '\t' then
		stdout.putchar['\t']
	      else
		stdout.putchar[' ']
	      end if
	    end for
	    stdout.putstring["^\n"]
	  end errorf

	  export operation warningf [s : String, v : RISA]
	    const line : String <- scan.line
	    fstdout.printf["\"%s\", line %d Warning: ", { fn, scan.lineNumber }]
	    if s != "syntax error" then
	      fstdout.printf[s, v]
	    end if
	    stdout.putchar['\n']
	    if line[0] == Character.literal[255] then
	      stdout.putstring["<EOF>\n"]
	    else
	      fstdout.printf["%s", {line}]
	    end if
	    for i : Integer <- 0 while i < scan.position by i <- i + 1
	      if line[i] == '\t' then
		stdout.putchar['\t']
	      else
		stdout.putchar[' ']
	      end if
	    end for
	    stdout.putstring["^\n"]
	  end warningf

	  export operation SemanticError [ln : Integer, s : String, v : RISA]
	    nErrors <- nErrors + 1
	    fstdout.printf["\"%s\", line %d: ", { fn, ln }]
	    fstdout.printf[s, v]
	    stdout.putchar['\n']
	  end SemanticError

	  export operation Warning [ln : Integer, s : String, v : RISA]
	    fstdout.printf["\"%s\", line %d Warning: ", { fn, ln }]
	    fstdout.printf[s, v]
	    stdout.putchar['\n']
	  end Warning

	  export operation Info [ln : Integer, s : String, v : RISA]
	    fstdout.printf["\"%s\", line %d: ", { fn, ln }]
	    fstdout.printf[s, v]
	    stdout.putchar['\n']
	  end Info
	  
	export operation pass [s : String, v : RISA]
	  if self$tracepasses then
	    self$fstdout.printf[s, v]
	  end if
	end pass

	export operation tassignTypes [s : String, v : RISA]
	  if self$traceassigntypes then
	    self$fstdout.printf[s, v]
	  end if
	end tassignTypes

	export operation tinline [s : String, v : RISA]
	  if self$traceinline then
	    self$fstdout.printf[s, v]
	  end if
	end tinline

	export operation ttypeCheck [s : String, v : RISA]
	  if self$tracetypecheck then
	    self$fstdout.printf[s, v]
	  end if
	end ttypeCheck

	export operation tgenerate [s : String, v : RISA]
	  if self$tracegenerate then
	    self$fstdout.printf[s, v]
	  end if
	end tgenerate

	export operation tAllocation [s : String, v : RISA]
	  if self$traceAllocation then
	    self$fstdout.printf[s, v]
	  end if
	end tAllocation

	export operation printf [s : String, v : RISA]
	  self$fstdout.printf[s, v]
	end printf

	export operation done[theWholeParseTree : Tree]
	  const q : AoT <- AoT.create[~10]
	  const VofCT <- Vector.of[ConcreteType]
	  var   vct : VofCT
	  const VofCO <- Vector.of[CreateOne]
	  var   vco : VofCO
	  var ctct : CTCode
	  var ct : typeobject T
	    function  fetchIndex -> [Integer]
	    operation getIndex[Integer, CPQueue]
	    operation cpoint [OutStream]
	    function  asString -> [String]
	    operation generateBuiltin -> [Any]
	  end T
	  const hasDoAllocation <- typeobject hasDoAllocation
	    operation doAllocation
	  end hasDoAllocation
	  var da : hasDoAllocation
	  var evalPasses : Integer
	  var findManifestPasses : Integer <- 0
	  var myCP : CP
  
	  self$root <- theWholeParseTree
	  % Parsing
  
	  if verbose then self.pass["Done parsing\n", nil] end if
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
  
	  if self$traceparse then
	    self$root.print[self$stdout, 0]
	  end if
  
	  % Remove Sugar
  
	  self.pass["Removing sugar ...\n", nil]
	  self$root <- self$root.removeSugar[nil]
	  if verbose then self.pass["Done removing sugar\n", nil] end if
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
  
	  if self$dumpremovesugar then
	    self$root.print[self$stdout, 0]
	  end if
  
	  % Define Symbols
  
	  if self$rootst == nil then
	    self$rootst <- builtinlit.init
	  else
	    self$rootst.reInitialize
	  end if
  
	  self.pass["Defining symbols ...\n", nil]
	  self$root.defineSymbols[self$rootst]
	  if verbose then self.pass["Done defining symbols\n", nil] end if
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
  
	  invoccache.resetForSourceFile[(view filename as Literal)$str]

	  % Resolve Symbols
  
	  self.pass["Resolving symbols ...\n", nil]
	  self$root.resolveSymbols[self$rootst, 0]
	  if verbose then self.pass["Done resolving symbols\n", nil] end if
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
  
	  if self$tracesymbols then
	    self$root.print[self$stdout, 0]
	  end if
  
	  % Assign ids (the first time)
	  doingIdsEarly <- true

	  self.pass["Assigning ids ...\n", nil]
	  self$root.assignIds[self$rootst]
	  if verbose then self.pass["Done assigning ids\n", nil] end if
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
	  doingIdsEarly <- false
  
	  % Do manifest objects
  
	  self.pass["Finding manifest objects ...\n", nil]
	  findManifestPasses <- 1
	  loop
	    self.pass["  Pass %d\n", {findManifestPasses}]
	    exit when !self$root.findManifests
	    findManifestPasses <- findManifestPasses + 1
	  end loop
	  if verbose then self.pass["Done finding manifest objects\n", nil] end if
	  
	  self.pass["Evaluating manifest objects ...\n", nil]
	  if self$dumpevaluatemanifests then
	    self$root.print[self$stdout, 0]
	  end if
  
	  evalPasses <- 1
	  self$needMoreEvaluateManifest <- true
	  loop
	    exit when ! self$needMoreEvaluateManifest
	    exit when evalPasses > findManifestPasses + 10
	    if evalPasses = findManifestPasses + 10 then
	      self$tracepasses <- true
	      self$traceevaluatemanifests <- true
	    end if
	    self.pass["  Pass %d\n", {evalPasses}]
	    self$needMoreEvaluateManifest <- false
	    self$root.evaluateManifests
	    evalPasses <- evalPasses + 1
	    exit when self.getnErrors[] > 0
	  end loop
	  if evalPasses > findManifestPasses + 10 then
	    self.SemanticError[1, "Something is surely wrong, probably a circular definition\nof a symbol.  Look for a declaration like const sconst <- SConst and\nfix it.  Remember that Emerald is not case sensitive", nil]
	  end if
	  if verbose then self.pass["Done manifest objects\n", nil] end if
  
	  if self$dumpevaluatemanifests then
	    self$root.print[self$stdout, 0]
	  end if
  
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
	  
	  % Type Assignment
  
	  self.pass["Assigning types ...\n", nil]
	  if self$dumpassigntypes then
	    self$root.print[self$stdout, 0]
	  end if
	  self$root.assignTypes
	  if verbose then self.pass["Done assigning types\n", nil] end if
%	  if self.getnErrors[] > 0 then
%	    if self$verbose then
%	      self$root.print[self$stdout, 0]
%	    end if
%	    return
%	  end if
  
	  % Type Checking
  
	  self.pass["Doing type checking ...\n", nil]
	  if self$dotypecheck or self$useAbCons then
	    self$root.typeCheck
	    loop
	      exit when alldefers.empty
	      const t : defer <- alldefers.removeUpper
	      t$p.doDeferredTypeCheck[t$aparam, t$apsym, t$avalue, t$i]
	    end loop
	  end if
	  if verbose then self.pass["Done type checking\n", nil] end if
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
  
	  % Assign Ids again (just in case)
  
	  self.pass["Assigning ids ...\n", nil]
	  self$root.assignIds[self$rootst]
	  if verbose then self.pass["Done assigning ids\n", nil] end if
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
  
	  self.pass["Finding things to generate ...\n", nil]
	  self$root.findThingsToGenerate[q]
	  if verbose then self.pass["Done finding things to generate\n", nil] end if
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
  
	  if ! self$executeNow and ! self$doCompilation then
	    const t <- q.removeLower
	  end if
	  if self$doGeneration and ! self$executeNow then
	    myCP <- CP.create[self$fn, self$perfile]
	  end if
  
	  if self$generateBuiltin then
	    vct <- VofCT.create[q.upperbound + 1]
	    vco <- VofCO.create[q.upperbound + 1]
	  end if

	  % Do allocation

	  for i : Integer <- q.lowerbound while i <= q.upperbound by i<-i+1
	    const qq <- q[i]
	    const qqname <- nameof qq
  
	    self.pass["Allocating object #%d %s...\n", {i, qqname : Any}]
  
	    if qqname = "anoblit" or qqname = "acomp" then
	      if self$tracepasses then
		if qqname = "acomp" then
		  stdout.putstring["A compilation\n"]
		else
		  (view qq as Oblit).printsummary
		end if
	      end if
	      % Allocation
    
	      da <- view qq as hasDoAllocation
	      da.doAllocation
	      if verbose then self.tallocation["Done allocation\n", nil] end if
	      if self.getnErrors[] > 0 then
		if self$verbose then
		  qq.print[self$stdout, 0]
		end if
		return
	      end if
	    end if
	  end for

	  for oindex : Integer <- q.lowerbound while oindex <= q.upperbound by oindex <- oindex + 1
	    const qq <- q[oindex]
	    const qqname <- nameof qq
	    var theCT : ConcreteType
	    var theAT : Signature
	    var o : ObLit
	    ct <- nil
  
	    self.pass["Generating object #%d %s...\n", {oindex, qqname : Any}]
  
	    if qqname = "anoblit" or qqname = "acomp" then
	      if self$tracepasses then
		if qqname = "acomp" then
		  stdout.putstring["A compilation\n"]
		else
		  (view qq as Oblit).printsummary
		end if
	      end if

	      if qqname = "anoblit" then
		o <- view qq as oblit
	      end if

	      % Code Generation

	      if self$doGeneration and (qqname = "acomp" or !o$alreadyGenerated) then

		if qqname = "anoblit" then
		  self.tgenerate["  Name = %s Id = %#x codeOID = %#x\n",
		    { o$name.asString, o$id, o$codeOID : Any}]
		  if o$id !== nil then
		    const c <- CreateOne.create[o$codeOID, o$id]
		    if self$executeNow then
		      vco[oindex] <- c
		    else
		      myCP.CP[c]
		    end if
		  end if
		end if
    
		ctct <- CTCode.create
		ct <- ctct
		self.pass["Doing code generation ...\n", nil]
		if self$tracegenerate then qq.print[self$stdout, 0] end if
		self$thisObject <- qq
		qq.generate[ctct]
		if self$generateBuiltin then
		  theCT <- ctct.generateBuiltin
		  vct[oindex] <- theCT
		end if
		if self$tracegeneratedBuiltin then
		  if !self$generateBuiltin then
		    theCT <- ctct.generateBuiltin
		  end if
		  self.printf["Generated code named %s, file %s, template %s\n",
		    {theCT.getName, theCT.getFileName, theCT.getTemplate}]
		  for i : Integer <- 0 while i <= theCT.getOps.upperbound by i<-i+1
		    const xx <- theCT.getOps[][i]
		    if xx !== nil then
		      self.printf["  Op %d is %s[%d]->[%d]\n",
			{ i, xx.getName, xx.getNArgs, xx.getNRess}]
		    end if
		  end for
		end if
		if self$tracegeneratedImports then
		  const c <- view qq as oblit
		  self.printf["CT named %s imports:\n", { c$name.asString : Any}]
		  Setq.display[c$xsetq]
		end if
		if verbose then self.tgenerate["Done code generation\n", nil] end if
	      end if
	    else
	      if self$doGeneration and self$generateATs then
		const a <- view qq as atlit
		self.tgenerate["  Name = %s Id = %#x\n",
		  { a$name.asString, a$id : Any}]

		ct <- ATCode.create
		self.tgenerate["Doing abstracttype generation ...\n", nil]
		  if self$tracegenerate then qq.print[self$stdout, 0] end if
		self$thisObject <- qq
		qq.generate[ct]

		if self$generateBuiltin then
		  theAT <- view ct.generateBuiltin as Signature
		end if
		if self$tracegeneratedBuiltin then
		  if !self$generateBuiltin then
		    theAT <- view ct.generateBuiltin as Signature
		  end if
		  self.printf["Generated signature named %s, file %s\n",
		    { theAT.getName, theAT.getFileName }]
		  for i : Integer <- 0 while i <= theAT.getOps.upperbound by i<-i+1
		    const xx <- theAT.getOps[][i]
		    if xx !== nil then
		      self.printf["  Op %d is %s[%d]->[%d]\n",
			{ i, xx.getName, xx.getNArgs, xx.getNRess}]
		    end if
		  end for
		end if
		if self$tracegeneratedImports then
		  self.printf["AT named %s imports:\n", { a$name.asString : Any}]
		  Setq.display[a$xsetq]
		end if

		if verbose then self.tgenerate["Done abstracttype generation\n", nil] end if
	      else
		ct <- nil
	      end if
	    end if
  
	    if self.getnErrors[] > 0 then
	      if self$verbose then
		qq.print[self$stdout, 0]
	      end if
	      return
	    end if
	    if !self$executeNow and ct !== nil then
	      myCP.CP[ct]
	    end if
	  end for
	  if self$generateBuiltin then
	    %
	    % Before we start making objects that the new concrete types
	    % describe, force them into the old generation, by doing two
	    % garbage collections in a row.
	    %
	    primitive "GCOLLECT" [] <- []
	    primitive "GCOLLECT" [] <- []
	    for i : Integer <- 0 while i <= vct.upperbound by i <- i + 1
	      const theCT <- vct[i]
	      if theCT !== nil then
		% Fix its literals
		primitive "DOCTLITERALS" [] <- [theCT]
	      end if
	    end for
	    for i : Integer <- 0 while i <= vco.upperbound by i <- i + 1
	      const theCO : CreateOne <- vco[i]
	      if theCO !== nil then
		% We need to create one
		var theObject : Any
		const theCT <- vct[i]
		const theID <- theCO$id
		assert theCT !== nil
		primitive "XCREATE" [theObject] <- [theCT, theObject]
		primitive "INSTALLINOID" [] <- [theID, theObject]
	      end if
	    end for
	  end if
	  if self$doGeneration then
	    if self$executeNow then
	      % build the thing
	      const theCompilationCT <- vct[0]
	      var result : Any
	      if self$tracetoplevel then
		self.printf["Executing %s\n", {self$fn}]
	      end if
	      primitive "XCREATE" [result] <- [theCompilationCT, result]
	    else
	      myCP.finish
	    end if
	  end if
	  self$thisObject <- nil

	  % Environment Exports
  
	  self.pass["Doing environment exports ...\n", nil]
	  self$root.doEnvExports[nil]
	  if verbose then self.pass["Done environment exports\n", nil] end if
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
  
	  if verbose then self.pass["Trashing symbol tables ...\n", nil] end if
	  self$rootst.discard
	  if verbose then self.pass["Done trashing symbol tables\n", nil] end if
	  self$root <- nil
	  myenv$root <- nil
	  myenv$thisObject <- nil

	  if self$tracesizes then
	    var xxx : Any <- self$rootst
	    primitive var "CALCSIZE" [] <- [xxx]
	    xxx <- InvocCache
	    primitive var "CALCSIZE" [] <- [xxx]
	    xxx <- aCompiler
	    primitive var "CALCSIZE" [] <- [xxx]
	  end if

	end done
  
	export function getln -> [r : Integer]
	  r <- self$scan.lineNumber
	end getln
  
	export operation checkNames [a : Tree, b : Tree]
	  const la <- view a as hasIdent
	  const lb <- view b as hasIdent
	  if la$id !== lb$id then
	    self.warningf["Name %s should be %s", { lb$id$name, la$id$name} ]
	  end if
	end checkNames
  
	export operation checkNamesbyid [a : Ident, b : Ident]
	  if a !== b then
	    self.warningf["Name %s should be %s", { b$name, a$name} ]
	  end if
	end checkNamesbyid
  
	export operation distribute
		[tm: TreeMaker, l : Tree, t : Tree, v :Tree] -> [r : Tree]
	  if l.upperbound > 0 then
	    r <- sseq.create[l$ln]
	  end if
	  for i : Integer <- l.lowerbound while i <= l.upperbound by i <- i + 1
	    begin
	      const elem <- l[i]
	      const temp <- tm.create[elem$ln, elem, t, v]
	      if l.upperbound > 0 then
		r.rcons[temp]
	      else
		r <- temp
	      end if
	    end
	  end for
	end distribute
	export operation scheduleDeferredTypeCheck [t : Tree, aparam : Any, apsym : Any, avalue : Any, i : Integer]
	  const adefer : defer <- defer.create[
	    view t as Invoc, aparam, apsym, avalue, i]
	  alldefers.addupper[adefer]
	end scheduleDeferredTypeCheck
      end myenv

      export function getenv -> [r : Environment]
	r <- myenv
      end getenv
      export operation setup [xstdout : OutStream]
	stdout <- xstdout
	fstdout <- FormattedOutput.toStream[stdout]

	% Set the environment
	myenv$itable <- it
	myenv$nextNumber <- 1
	myenv$nErrors <- 0
	myenv$stdout <- stdout
	myenv$fstdout <- fstdout

	% Set my process environment
	primitive var "SETENV" [] <- [myenv]
      end setup

      export operation option[name : String, value : Boolean]
	if name = "verbose" then
	  myenv$verbose <- value
	elseif name = "exporttree" then
	  myenv$exportTree <- value
	elseif name = "explainNonManifests" then
	  myenv$explainNonManifests <- value
	elseif name = "perfile" then
	  myenv$perfile <- value
	elseif name = "tracecode" then
	  myenv$tracecode <- value
	elseif name = "docompilation" then
	  myenv$docompilation <- value
	elseif name = "dogeneration" then
	  myenv$dogeneration <- value
	elseif name = "generatebuiltin" then
	  myenv$generatebuiltin <- value
	elseif name = "executenow" then
	  myenv$generatebuiltin <- value
	  myenv$executenow <- value
	elseif name = "generateconcurrent" then
	  myenv$generateConcurrent <- value
	elseif name = "generatedebuginfo" then
	  myenv$generateDebugInfo <- value
	elseif name = "generateats" then
	  myenv$generateAts <- value
	elseif name = "padbytecodes" then
	  myenv$padByteCodes <- value
	elseif name = "useabcons" then
	  myenv$useAbCons <- value
	elseif name = "implicitlydefineexternals" then
	  myenv$implicitlyDefineExternals <- value
	elseif name = "tracegenerate" then
	  myenv$tracegenerate <- value
	elseif name = "tracegeneratedbuiltin" then
	  myenv$tracegeneratedbuiltin <- value
	elseif name = "tracegeneratedimports" then
	  myenv$tracegeneratedimports <- value
	elseif name = "traceparse" then
	  myenv$traceparse <- value
	elseif name = "dumpremovesugar" then
	  myenv$dumpremovesugar <- value
	elseif name = "traceassigntypes" then
	  myenv$traceassigntypes <- value
	elseif name = "optimizeinvocexecute" then
	  myenv$optimizeinvocexecute <- value
	elseif name = "tracetypecheck" then
	  myenv$tracetypecheck <- value
	elseif name = "traceallocation" then
	  myenv$traceallocation <- value
	elseif name = "tracetoplevel" then
	  myenv$tracetoplevel <- value
	elseif name = "traceinline" then
	  myenv$traceinline <- value
	elseif name = "tracesizes" then
	  myenv$tracesizes <- value
	elseif name = "dotypecheck" then
	  myenv$dotypecheck <- value
	elseif name = "warnshadows" then
	  myenv$warnshadows <- value
	elseif name = "why" then
	  myenv$why <- value
	elseif name = "dumpassigntypes" then
	  myenv$dumpassigntypes <- value
	elseif name = "tracesymbols" then
	  myenv$tracesymbols <- value
	elseif name = "dumpsymbols" then
	  myenv$dumpsymbols <- value
	elseif name = "traceevaluatemanifests" then
	  myenv$traceevaluatemanifests <- value
	elseif name = "dumpevaluatemanifests" then
	  myenv$dumpevaluatemanifests <- value
	elseif name = "tracepasses" then
	  myenv$tracepasses <- value
	elseif name = "compilingbuiltins" then
	  myenv$compilingbuiltins <- value
	elseif name = "compilingcompiler" then
	  myenv$compilingcompiler <- value
	elseif name = "generateviewchecking" then
	  myenv$generateviewchecking <- value
	else
	  fstdout.printf["Undefined variable \"%s\"\n", {name}]
	end if
      end option

      export operation load[filename : String]
	myenv$namespacefile <- filename
	if myenv$rootst == nil then
	  myenv$rootst <- builtinlit.init
	end if
	xexport.load[filename]
	invoccache.load[filename]
	nextoid.load[filename]
	OpNameToOID.load[filename]
      end load

      export operation eval[code : String]
	const f <- StringStream.create[code]
	var myparser : ParserCreator
	var parseResult : Integer
	const oldexecutenow <- myenv$executeNow
	const oldgeneratebuiltin <- myenv$generateBuiltin
	myenv$executeNow <- true
	myenv$generateBuiltin <- true

	if myenv$tracetoplevel then
	  fstdout.printf["Evaluating \"%s\"\n", {code}]
	end if

	if scan == nil then
	  scan <- scanner.create[f, it]
	else
	  scan.reset[f]
	end if

	% Reset the environment
	myenv$fileName <- Literal.StringL[0, "stdin"]
	myenv$nextNumber <- 1
	myenv$nErrors <- 0
	myenv$fn <- "stdin"
	myenv$scan <- scan

	myparser <- parsercreator.create[myenv]

	myenv.pass["Parsing ...\n", nil]
	parseresult <- myparser.parse[scan]
	myenv$executeNow <- oldExecuteNow
	myenv$generateBuiltin <- oldgenerateBuiltin
      end eval
      
      export operation compile[fileName : String]
	var f : InStream
	begin
	  f <- InStream.fromUnix[fileName, "r"]
	  failure f <- nil end failure
	end

	if f == nil then
	  fstdout.printf["Can't open \"%s\"\n", { fileName }]
	else
	  var myparser : ParserCreator
	  var parseResult : Integer
  
	  if scan == nil then
	    scan <- scanner.create[f, it]
	  else
	    scan.reset[f]
	  end if
  
	  if myenv$tracetoplevel then
	    fstdout.printf["Compiling %s\n", {fileName}]
	    fstdout.flush
	  end if
	  % Reset the environment
	  myenv$fileName <- Literal.StringL[0, fileName]
	  myenv$nextNumber <- 1
	  myenv$nErrors <- 0
	  myenv$fn <- fileName
	  myenv$scan <- scan
  
	  myparser <- parsercreator.create[myenv]
  
	  myenv.pass["Parsing ...\n", nil]
	  parseresult <- myparser.parse[scan]
	  f.close
	end if
      end compile

    end aCompiler
  end create
end Compiler
export Compiler
@


1.64
log
@'./EC'
@
text
@d34 1
d548 5
d584 4
d606 7
a616 1
		const ops <- theCT.getOps
a617 7
		for j : Integer <- 0 while j <= ops.upperbound by j <- j + 1
		  const anop <- ops[j]
		  if anop !== nil then
		    const code <- anop.getCode
		    primitive "DOLITERALS" [] <- [code]
		  end if
		end for
d774 2
@


1.63
log
@Cleaned up
@
text
@d79 3
a81 3
	    var aparam : Param
	    var apsym : Symbol
	    var avalue : Tree
d704 1
a704 1
	export operation scheduleDeferredTypeCheck [t : Tree, aparam : Tree, apsym : Symbol, avalue : Tree, i : Integer]
d706 1
a706 1
	    view t as Invoc, view aparam as Param, apsym, avalue, i]
@


1.62
log
@Many changes
@
text
@d59 1
d734 2
@


1.61
log
@Flatten invocations to reduce jibberish on the stack
@
text
@d40 1
d104 1
a104 1
	    fstdout.printf["Syntax Error \"%s\", line %d\n", { fn, scan.lineNumber }]
d768 2
a862 3
	  if fileName[0] != '/' then
	    fstdout.printf["  You may want an absolute path name\n", nil]
	  end if
@


1.60
log
@Make type stuff work
@
text
@d688 1
a688 1
	    r <- seq.create[l$ln]
@


1.59
log
@Implement defered type checking of manifest invocs
@
text
@d88 4
@


1.58
log
@Handle exported mutable objects and getting their ids assigned
@
text
@d75 8
d399 5
d698 5
@


1.57
log
@Fix serious GC bugs, add a new builtin
@
text
@d74 1
d311 2
a312 1
  
d322 1
@


1.56
log
@Get rid of split, and make execute now and eval work again
@
text
@d44 1
d772 2
@


1.55
log
@Fixed a long standing problem with manifest invocs
@
text
@d94 1
a94 1
	    if line[0] == Character.literal[0] then
d99 2
d105 1
a105 1
	    for i : Integer <- 0 while i < scan.position by i <- i + 1
a572 12
	    for i : Integer <- 0 while i <= vco.upperbound by i <- i + 1
	      const theCO : CreateOne <- vco[i]
	      if theCO !== nil then
		% We need to create one
		var theObject : Any
		const theCT <- vct[i]
		const theID <- theCO$id
		assert theCT !== nil
		primitive "XCREATE" [theObject] <- [theCT, theObject]
		primitive "INSTALLINOID" [] <- [theID, theObject]
	      end if
	    end for
d586 12
@


1.54
log
@Use new streams code
@
text
@d288 2
a422 2
	  invoccache.resetForSourceFile[(view filename as Literal)$str]

d441 1
a441 1
		  (view qq as Oblit).printsummary[self$stdout]
d473 1
a473 1
		  (view qq as Oblit).printsummary[self$stdout]
@


1.53
log
@Turn on compiler debugging info if manifest evals fail
@
text
@d822 6
a827 1
	const f <- InStream.fromUnix[fileName, "r"]
d836 1
a836 1

d842 1
a842 1

d853 1
a853 1

d855 1
a855 1

@


1.52
log
@Even better semantics checks, avoid invoking nil, fix class
@
text
@d337 4
@


1.51
log
@Inserted a number of additional type checks, put line numbers in literals
@
text
@d56 1
a56 1
	  field exportTree : Boolean <- false
@


1.50
log
@Generate code for view as, new bytecode VIEW
@
text
@d87 1
a87 1
	    const line <- scan.line
d114 1
a114 1
	    const line <- scan.line
d137 1
a137 1
	    const line <- scan.line
d218 1
a218 1
	  const q <- AoT.create[~10]
d803 1
a803 1
	myenv$fileName <- Literal.StringL["stdin"]
d839 1
a839 1
	  myenv$fileName <- Literal.StringL[fileName]
@


1.49
log
@August 94 Checkpoint II
@
text
@d44 1
d765 2
@


1.48
log
@Checkpoint of DIKU August 94 changes
@
text
@d50 1
d97 1
a97 1
		fstdout.printf["%s\n", {line.getSlice[0, line.upperbound]}]
d366 6
a371 6
	  if self.getnErrors[] > 0 then
	    if self$verbose then
	      self$root.print[self$stdout, 0]
	    end if
	    return
	  end if
d746 2
@


1.47
log
@First attempt at abcons
@
text
@a37 1
	  field doselfs : Boolean <- true
d43 1
d50 1
d72 1
a72 1
	  export function getInvoc -> [r : TreeMaker]
d169 6
d215 2
a216 3
	export operation done[a : Tree]
	  const AofT <- Array.of[Tree]
	  const q <- AofT.create[~10]
d233 1
a233 1
	  var i : Integer
d237 1
a237 1
	  self$root <- a
d330 1
a330 1
	  i <- 1
d334 2
a335 2
	    exit when i > findManifestPasses + 10
	    self.pass["  Pass %d\n", {i}]
d338 2
a339 1
	    i <- i + 1
d341 1
a341 1
	  if i > findManifestPasses + 10 then
d415 1
a415 1
	  invoccache.resetForSourceFile[(view filename as stringlit)$str]
d422 2
a426 4
	    var theCT : ConcreteType
	    var theAT : Signature
	    var o : ObLit
	    ct <- nil
d428 1
a428 1
	    self.pass["Generating object #%d %s...\n", {i, qqname : Any}]
a439 2
	      self.pass["Doing allocation ...\n", nil]
	      
d449 2
d452 19
d485 1
a485 1
		      vco[i] <- c
d500 1
a500 1
		  vct[i] <- theCT
d523 1
d583 2
a584 2
		for i : Integer <- 0 while i <= ops.upperbound by i<-i+1
		  const anop <- ops[i]
d650 6
d745 2
a756 2
	elseif name = "doselfs" then
	  myenv$doselfs <- value
d759 2
d773 2
d797 1
a797 1
	myenv$fileName <- stringlit.create[1, "stdin"]
d833 1
a833 1
	  myenv$fileName <- stringlit.create[1, fileName]
@


1.46
log
@Prepare to generate ab/cons and invokes by index
@
text
@a2 4
const hasId <- typeobject hasId
  function getID -> [Ident]
end hasId

d75 3
a77 3
	  export function getBuiltinLit -> [r : typeobject x op create[Integer, Integer] -> [Tree] end x]
	    r <- BuiltinLit
	  end getBuiltinLit
d215 1
a215 7
	  var ctct : typeobject T
	    function  fetchIndex -> [Integer]
	    operation getIndex[Integer, CPQueue]
	    operation cpoint [OutStream]
	    function  asString -> [String]
	    operation generateBuiltin -> [ConcreteType]
	  end T
d618 2
a619 2
	  const la <- view a as hasId
	  const lb <- view b as hasId
@


1.45
log
@Preparatory work for Ab/Cons
@
text
@d67 1
a67 1
	  field useCalloids : Boolean <- true
d378 1
a378 1
	  if self$dotypecheck then
d437 5
a441 1
	        (view qq as Oblit).printsummary[self$stdout]
d698 2
a699 2
	elseif name = "usecalloids" then
	  myenv$useCalloids <- value
@


1.44
log
@Finalized merge with Mark Immels version
@
text
@d437 1
a437 1
	        qq.printsummary[self$stdout]
d521 1
a521 1
		    const xx <- theAT.getOps[i]
@


1.43
log
@Better clean up of junk
@
text
@d436 3
a438 1
  
@


1.42
log
@Generate code for the results of manifest invocs when recompiling
@
text
@d599 7
a605 8
	  if !self$exportTree then
	    if verbose then self.pass["Trashing symbol tables ...\n", nil] end if
	    begin
%	      (view self$root as Comp)$st.discard
	    end 
	    if verbose then self.pass["Done trashing symbol tables\n", nil] end if
	  end if
  
a614 3
	  self$root <- nil
	  myenv$root <- nil
	  myenv$thisObject <- nil
@


1.41
log
@Type checking errors repaired
@
text
@d418 2
@


1.40
log
@Convert to the new subscript syntax a[b]
@
text
@d14 1
d487 1
a487 1
		    const xx <- theCT.getOps[i]
@


1.39
log
@Eliminate a[b] as shorthand for self.a[b]
@
text
@d94 1
a94 1
	    if line(0) == Character.literal[0] then
d97 1
a97 1
	      if line(line.upperbound) = '\0' then
d104 1
a104 1
	      if line(i) == '\t' then
d121 1
a121 1
	    if line(0) == Character.literal[255] then
d127 1
a127 1
	      if line(i) == '\t' then
d143 1
a143 1
	    if line(0) == Character.literal[255] then
d149 1
a149 1
	      if line(i) == '\t' then
d423 1
a423 1
	    const qq <- q(i)
d462 1
a462 1
		      vco(i) <- c
d477 1
a477 1
		  vct(i) <- theCT
d486 1
a486 1
		    const xx <- theCT.getOps(i)
d516 1
a516 1
		    const xx <- theAT.getOps(i)
d542 1
a542 1
	      const theCO : CreateOne <- vco(i)
d546 1
a546 1
		const theCT <- vct(i)
d554 1
a554 1
	      const theCT <- vct(i)
d560 1
a560 1
		  const anop <- ops(i)
d572 1
a572 1
	      const theCompilationCT <- vct(0)
d637 1
a637 1
	      const elem <- l(i)
d785 1
a785 1
	  if fileName(0) != '/' then
@


1.38
log
@Add type checking of externs and extern decls
@
text
@d244 1
a244 1
	  if getnErrors[] > 0 then
d260 1
a260 1
	  if getnErrors[] > 0 then
d282 1
a282 1
	  if getnErrors[] > 0 then
d294 1
a294 1
	  if getnErrors[] > 0 then
d310 1
a310 1
	  if getnErrors[] > 0 then
d352 1
a352 1
	  if getnErrors[] > 0 then
d367 1
a367 1
	  if getnErrors[] > 0 then
d381 1
a381 1
	  if getnErrors[] > 0 then
d393 1
a393 1
	  if getnErrors[] > 0 then
d403 1
a403 1
	  if getnErrors[] > 0 then
d441 1
a441 1
	      if getnErrors[] > 0 then
d530 1
a530 1
	    if getnErrors[] > 0 then
d575 1
a575 1
		printf["Executing %s\n", {self$fn}]
d589 1
a589 1
	  if getnErrors[] > 0 then
d626 1
a626 1
	    warningf["Name %s should be %s", { lb$id$name, la$id$name} ]
@


1.37
log
@Implement external dictionary for symbol lookups
@
text
@d68 1
d74 1
a74 1
	  export operation getInvoc -> [r : TreeMaker]
d78 4
d695 2
@


1.36
log
@fromUnix calls changed to new syntax
@
text
@d26 1
d44 1
d73 4
d553 1
d643 4
a646 1
    
d716 2
@


1.35
log
@Clean up trace output
@
text
@d763 1
a763 1
	const f <- InStream.fromUnix[fileName, 0, 0666]
@


1.34
log
@Create AT objects under the control of executenow
@
text
@d47 1
d184 12
d232 1
a232 1
	  self.pass["Done parsing\n", nil]
d248 1
a248 1
	  self.pass["Done removing sugar\n", nil]
d270 1
a270 1
	  self.pass["Done defining symbols\n", nil]
d282 1
a282 1
	  self.pass["Done resolving symbols\n", nil]
d298 1
a298 1
	  self.pass["Done assigning ids\n", nil]
d315 1
a315 1
	  self.pass["Done finding manifest objects\n", nil]
d335 1
a335 1
	  self.pass["Done manifest objects\n", nil]
d355 1
a355 1
	  self.pass["Done assigning types\n", nil]
d369 1
a369 1
	  self.pass["Done type checking\n", nil]
d381 1
a381 1
	  self.pass["Done assigning ids\n", nil]
d391 1
a391 1
	  self.pass["Done finding things to generate\n", nil]
d429 1
a429 1
	      self.pass["Done allocation\n", nil]
d446 1
a446 1
		  self.pass["  Name = %s Id = %#x codeOID = %#x\n",
d482 1
a482 1
		self.pass["Done code generation\n", nil]
d487 1
a487 1
		self.pass["  Name = %s Id = %#x\n",
d490 1
a490 1
		self.pass["Doing abstracttype generation ...\n", nil]
d513 1
a513 1
		self.pass["Done abstracttype generation\n", nil]
d576 1
a576 1
	  self.pass["Done environment exports\n", nil]
d585 1
a585 1
	    self.pass["Trashing symbol tables ...\n", nil]
d589 1
a589 1
	    self.pass["Done trashing symbol tables\n", nil]
d692 2
@


1.33
log
@Flush stdout after logging messages
@
text
@d206 1
d402 1
d481 19
@


1.32
log
@Detect problems with consts defined in terms of themselves
@
text
@d745 1
@


1.31
log
@Forgot the increment
@
text
@d212 1
d295 1
a295 1
	  i <- 1
d297 1
a297 1
	    self.pass["  Pass %d\n", {i}]
d299 1
a299 1
	    i <- i + 1
d312 1
d318 3
@


1.30
log
@Separated the interactive cli from the compiler proper
@
text
@d314 1
@


1.29
log
@Allow " in eval arguments
@
text
@d9 5
a13 1
    operation doit[Any, Any]
d21 3
d67 2
a68 2
	  var fstdout : FormattedOutput
	  var stdout : OutStream
d73 1
a73 12
	  export function getStdout -> [r : OutStream]
	    r <- stdout
	  end getStdout
	  export operation setStdout [a : OutStream]
	    stdout <- a
	  end setStdout
	  export function getFStdout -> [r : FormattedOutput]
	    r <- fstdout
	  end getFStdout
	  export operation setFStdout [a : FormattedOutput]
	    fstdout <- a
	  end setFStdout
d100 1
d123 1
d145 1
d152 1
d158 1
d164 1
d170 1
d176 1
d182 1
d186 1
d596 4
a600 63
      recovery
	var i : InStream
	var o : OutStream
	primitive "SYS" "GETSTDIN" 0 [i] <- []
	primitive "SYS" "GETSTDOUT" 0 [o] <- []
	self.doit[i, o]
      end recovery

      operation Split [s : String] -> [x : String, y : String, z : String]
	var first, last : Integer
	var c : Character
    
	first <- 0
	last <- 0
	for which : Integer <- 0 while which < 3 by which <- which + 1
	  loop
	    exit when first >= s.length
	    c <- s(first)
	    exit when c != ' ' and c != '\^I' and c != '\n'
	    first <- first + 1
	  end loop
	  if first >= s.length then return end if
	  last <- first + 1
	  if c = '"' then
	    first <- first + 1
	    loop
	      exit when last >= s.length
	      c <- s(last)
	      exit when c = '\n'
	      last <- last + 1
	    end loop
	    if s(last - 1) = '"' then
	      last <- last - 1
	    end if
	  else
	    loop
	      exit when last >= s.length
	      c <- s(last)
	      exit when c = ' ' or c = '\^I' or c = '\n'
	      last <- last + 1
	    end loop
	  end if
	  if which = 0 then
	    x <- s.getSlice[first, last - first]
	  elseif which = 1 then
	    y <- s.getSlice[first, last - first]
	  else
	    z <- s.getSlice[first, last - first]
	  end if
	  first <- last + 1
	end for
      end Split
    
      export operation doit[astdin : Any, astdout : Any]
	const stdin <- view astdin as InStream
	const stdout <- view astdout as OutStream
	var input : String
	var first, second, third : String
	var inputfile : InStream
	const fstdout <- FormattedOutput.ToStream[stdout]
	const inputFiles <- Array.of[InStream].create[~8]
	var scan : Scanner
    
d610 1
a610 127
	inputfile <- stdin
    
	loop
	  if inputfile == stdin and stdin.isatty then
	    stdout.putString["Command: "]
	    stdout.flush
	  end if
	  if inputfile.eos then
	    inputfile.close
	    if inputFiles.upperbound >= 0 then
	      inputFile <- inputFiles.removeUpper
	    else
	      exit
	    end if
	  else
	    input <- inputfile.getString
	    first, second, third <- self.Split[input]
	    if first == nil then
	      % do nothing
	    elseif first = "q" or first = "quit" or first = "exit" then 
	      stdin.close
	      exit
	    elseif first = "checkpoint" then
	      var a : Any <- self
	      if second == nil then
		fstdout.printf["Checkpoint requires a file name\n", nil]
	      else
		fstdout.printf["Checkpointing to \"%s\" ...", {second}];
		fstdout.flush
		primitive var "CHECKPOINT" [] <- [a, second]
		fstdout.printf["done.\n", nil];
	      end if
	    elseif first = "set" or first = "unset" then
	      const value <- first = "set"
	      if second == nil then
		fstdout.printf["%s requires a variable name\n", {first}]
	      else
		if second = "verbose" then
		  myenv$verbose <- value
		elseif second = "exporttree" then
		  myenv$exportTree <- value
		elseif second = "perfile" then
		  myenv$perfile <- value
		elseif second = "tracecode" then
		  myenv$tracecode <- value
		elseif second = "docompilation" then
		  myenv$docompilation <- value
		elseif second = "dogeneration" then
		  myenv$dogeneration <- value
		elseif second = "generatebuiltin" then
		  myenv$generatebuiltin <- value
		elseif second = "executenow" then
		  myenv$generatebuiltin <- value
		  myenv$executenow <- value
		elseif second = "generateconcurrent" then
		  myenv$generateConcurrent <- value
		elseif second = "generatedebuginfo" then
		  myenv$generateDebugInfo <- value
		elseif second = "generateats" then
		  myenv$generateAts <- value
		elseif second = "padbytecodes" then
		  myenv$padByteCodes <- value
		elseif second = "usecalloids" then
		  myenv$useCalloids <- value
		elseif second = "tracegenerate" then
		  myenv$tracegenerate <- value
		elseif second = "tracegeneratedbuiltin" then
		  myenv$tracegeneratedbuiltin <- value
		elseif second = "traceparse" then
		  myenv$traceparse <- value
		elseif second = "dumpremovesugar" then
		  myenv$dumpremovesugar <- value
		elseif second = "traceassigntypes" then
		  myenv$traceassigntypes <- value
		elseif second = "tracetypecheck" then
		  myenv$tracetypecheck <- value
		elseif second = "tracetoplevel" then
		  myenv$tracetoplevel <- value
		elseif second = "traceinline" then
		  myenv$traceinline <- value
		elseif second = "tracesizes" then
		  myenv$tracesizes <- value
		elseif second = "dotypecheck" then
		  myenv$dotypecheck <- value
		elseif second = "dumpassigntypes" then
		  myenv$dumpassigntypes <- value
		elseif second = "tracesymbols" then
		  myenv$tracesymbols <- value
		elseif second = "traceevaluatemanifests" then
		  myenv$traceevaluatemanifests <- value
		elseif second = "dumpevaluatemanifests" then
		  myenv$dumpevaluatemanifests <- value
		elseif second = "doselfs" then
		  myenv$doselfs <- value
		elseif second = "tracepasses" then
		  myenv$tracepasses <- value
		else
		  fstdout.printf["Undefined variable \"%s\"\n", {second}]
		end if
	      end if
	    elseif first = "load" then
	      myenv$namespacefile <- second
	      if myenv$rootst == nil then
		myenv$rootst <- builtinlit.init
	      end if
	      xexport.load[second]
	      invoccache.load[second]
	    elseif first = "source" then
	      const thefile <- InStream.fromUnix[second, 0, 0]
	      if thefile == nil then
		fstdout.printf["Can't open \"%s\"\n", {second}]
	      else
		inputFiles.addUpper[inputfile]
		inputfile <- thefile
	      end if
	    elseif first = "eval" then
	      const f <- StringStream.create[second]
	      var myparser : ParserCreator
	      var parseResult : Integer
	      const oldexecutenow <- myenv$executeNow
	      const oldgeneratebuiltin <- myenv$generateBuiltin
	      myenv$executeNow <- true
	      myenv$generateBuiltin <- true
      
	      if myenv$tracetoplevel then
		fstdout.printf["Evaluating \"%s\"\n", {second}]
	      end if
d612 64
a675 5
	      if scan == nil then
		scan <- scanner.create[f, it]
	      else
		scan.reset[f]
	      end if
d677 8
a684 6
	      % Reset the environment
	      myenv$fileName <- stringlit.create[1, "stdin"]
	      myenv$nextNumber <- 1
	      myenv$nErrors <- 0
	      myenv$fn <- "stdin"
	      myenv$scan <- scan
d686 8
a693 1
	      myparser <- parsercreator.create[myenv]
d695 3
a697 20
	      myenv.pass["Parsing ...\n", nil]
	      parseresult <- myparser.parse[scan]
	      myenv$executeNow <- oldExecuteNow
	      myenv$generateBuiltin <- oldgenerateBuiltin
	    elseif second == nil then
	      const f <- InStream.fromUnix[first, 0, 0666]
	      if f == nil then
		fstdout.printf["Can't open \"%s\"\n", { first }]
		if first(0) != '/' then
		  fstdout.printf["  You may want an absolute path name\n", nil]
		end if
	      else
		var myparser : ParserCreator
		var parseResult : Integer
      
		if scan == nil then
		  scan <- scanner.create[f, it]
		else
		  scan.reset[f]
		end if
d699 20
a718 9
		if myenv$tracetoplevel then
		  fstdout.printf["Compiling %s\n", {first}]
		end if
		% Reset the environment
		myenv$fileName <- stringlit.create[1, first]
		myenv$nextNumber <- 1
		myenv$nErrors <- 0
		myenv$fn <- first
		myenv$scan <- scan
d720 6
a725 10
		myparser <- parsercreator.create[myenv]
      
		myenv.pass["Parsing ...\n", nil]
		parseresult <- myparser.parse[scan]
		f.close
		primitive "GCOLLECT" [] <- []
	      end if
	    else
	      fstdout.printf["Invalid command \"%s\"\n", {first}]
	    end if
d727 28
a754 3
	end loop
	stdout.close
      end doit
@


1.28
log
@Implement eval
@
text
@d619 1
a619 1
	      exit when c = '"' or c = '\n'
d622 3
@


1.27
log
@Execute invocations found in idb
@
text
@d86 1
a86 1
	    if line(0) == Character.literal[255] then
d89 5
a93 1
	      fstdout.printf["%s", {line}]
d614 17
a630 7
	  loop
	    exit when last >= s.length
	    c <- s(last)
	    exit when c = ' ' or c = '\^I' or c = '\n'
	    last <- last + 1
	  end loop
	  if which =0 then
d775 32
@


1.26
log
@Installed experimental bytecodes
@
text
@d385 1
d405 5
a409 1
    
d411 3
a413 3
    
	      if self$doGeneration then
	
a414 1
		  const o <- view qq as oblit
@


1.25
log
@Use nameof rather than asString
@
text
@d671 1
a671 1
		primitive var "SCHECKPOINT" [] <- [a, second]
@


1.24
log
@Store the AT of exported symbols, do allocation for inlining
@
text
@d47 1
a47 1
	  field perFile : Boolean <- false
d383 1
a383 1
	    const qqname <- qq.asString
d389 1
a389 1
	    if qqname = "oblit" or qqname = "comp" then
d409 1
a409 1
		if qqname = "oblit" then
d666 8
a673 1
	      primitive var "CHECKPOINT" [] <- [a]
@


1.23
log
@Get rid of return on generate
@
text
@d184 1
a184 1
	  var ct : typeobject T
d191 6
a358 1
	if self$doGeneration then
d372 1
a372 1
	  if ! self$executeNow then
d380 1
d385 1
a392 15
	      if qqname = "oblit" then
		const o <- view qq as oblit
		self.pass["  Name = %s Id = %#x codeOID = %#x\n",
		  { o$name.asString, o$id, o$codeOID : Any}]
		if o$id !== nil then
		  const c <- CreateOne.create[o$codeOID, o$id]
		  if self$executeNow then
		    vco(i) <- c
		  else
		    myCP.CP[c]
		  end if
		end if
	      end if
  
  
d407 14
a420 12
	      ct <- CTCode.create
	      self.pass["Doing code generation ...\n", nil]
	      if self$tracegenerate then qq.print[self$stdout, 0] end if
	      self$thisObject <- qq
	      qq.generate[ct]
	      if self$generateBuiltin then
		theCT <- ct.generateBuiltin
		vct(i) <- theCT
	      end if
	      if self$tracegeneratedBuiltin then
		if !self$generateBuiltin then
		  theCT <- ct.generateBuiltin
d422 14
a435 7
		self.printf["Generated code named %s, file %s, template %s\n",
		  {theCT.getName, theCT.getFileName, theCT.getTemplate}]
		for i : Integer <- 0 while i <= theCT.getOps.upperbound by i<-i+1
		  const xx <- theCT.getOps(i)
		  if xx !== nil then
		    self.printf["  Op %d is %s[%d]->[%d]\n",
		      { i, xx.getName, xx.getNArgs, xx.getNRess}]
d437 11
a447 1
		end for
a448 1
	      self.pass["Done code generation\n", nil]
d450 1
a450 1
	      if self$generateATs then
d477 1
a477 1
	      const theCO <- vco(i)
d503 11
a513 6
	  if self$executeNow then
	    % build the thing
	    const theCompilationCT <- vct(0)
	    var result : Any
	    if self$tracetoplevel then
	      printf["Executing %s\n", {self$fn}]
a514 3
	    primitive "XCREATE" [result] <- [theCompilationCT, result]
	  else
	    myCP.finish
d517 1
a517 1
	end if
d533 1
a533 1
	      (view self$root as Comp)$st.discard
@


1.22
log
@Fix parsing of operations, initiallies and recoveries
@
text
@a377 1
	    var junk : Any
d419 1
a419 1
	      junk <- qq.generate[ct]
d448 1
a448 1
		junk <- qq.generate[ct]
@


1.21
log
@Removed all monitors
@
text
@d30 1
d225 4
d572 7
a578 7
%	recovery
%	  var i : InStream
%	  var o : OutStream
%	  primitive "SYS" "GETSTDIN" 0 [i] <- []
%	  primitive "SYS" "GETSTDOUT" 0 [o] <- []
%	  self.doit[i, o]
%	end recovery
d694 2
@


1.20
log
@Implement change to "new" keyword.
@
text
@a18 1
	monitor
a152 1
	end monitor
d567 7
a573 9
      monitor
	recovery
	  var i : InStream
	  var o : OutStream
	  primitive "SYS" "GETSTDIN" 0 [i] <- []
	  primitive "SYS" "GETSTDOUT" 0 [o] <- []
	  self.doit[i, o]
	end recovery
      end monitor
@


1.19
log
@Evaluate manifests in multiple passes
@
text
@d63 1
a63 1
	  export operation new -> [r : Integer]
d65 1
a65 1
	  end new
@


1.18
log
@Implement calloids
@
text
@d57 1
d288 8
a295 1
	  self$root.evaluateManifests
@


1.17
log
@Implement padded bytecodes (operands aligned)
@
text
@d56 1
d677 2
@


1.16
log
@Option to not generate AT info
@
text
@d55 1
d674 2
@


1.15
log
@DIKU changes to support TS.of[Integer, String]
@
text
@d54 1
d428 13
a440 9
	      const a <- view qq as atlit
	      self.pass["  Name = %s Id = %#x\n",
		{ a$name.asString, a$id : Any}]
	      ct <- ATCode.create
	      self.pass["Doing abstracttype generation ...\n", nil]
		if self$tracegenerate then qq.print[self$stdout, 0] end if
	      self$thisObject <- qq
	      junk <- qq.generate[ct]
	      self.pass["Done abstracttype generation\n", nil]
d449 1
a449 1
	    if !self$executeNow then
d671 2
@


1.14
log
@Reuse the same scanner
@
text
@d34 1
d280 1
a280 1
	  if self$traceevaluatemanifests then
d287 4
d690 2
@


1.13
log
@Prune memory usage
@
text
@a514 1
	  myenv$scan <- nil
d599 1
a600 1
    
a715 1
		const scan <- scanner.create[f, it]
d719 6
a738 1
		myenv$scan <- nil
@


1.12
log
@Enabled attach declarations
@
text
@d40 1
d504 9
d514 3
d676 2
@


1.11
log
@Made generation of debugging info optional
@
text
@d722 1
@


1.10
log
@type -> typeobject sed
@
text
@d51 1
d647 2
@


1.9
log
@Init the root st on load
@
text
@a0 19
import Ident, IdentTable from "Jekyll"
import Scanner from "Jekyll"
import ParserCreator from "Jekyll"
import FormattedOutput from "Jekyll"
import Tree, Printable from "Jekyll"
import StringLit from "Jekyll"
import seq from "Jekyll"
import SymbolTable from "Jekyll"
import CTCode, CreateOne from "Jekyll"
import ATCode from "Jekyll"
import CP from "Jekyll"
import CPQueue from "Jekyll"
import TreeMaker, RISA, Environment from "Jekyll"
import Xexport from "Jekyll"
import InvocCache from "Jekyll"
import Comp from "Jekyll"
import Oblit from "Jekyll"
import ATlit from "Jekyll"
import IIBTable from "Jekyll"
d3 1
a3 1
const hasId <- type hasId
d8 1
a8 1
  const CType <- type CType
d178 1
a178 1
	  var ct : type T
d185 1
a185 1
	  const hasDoAllocation <- type hasDoAllocation
d730 1
a730 1
export Compiler to "Jekyll"
@


1.8
log
@Made checkpoint a command
@
text
@d697 3
a699 1
%	      myenv$rootst <- builtinlit.init
@


1.7
log
@Save the environment across checkpoints
@
text
@d555 10
d638 3
d697 1
a697 1
	      myenv$rootst <- builtinlit.init
@


1.6
log
@First cut at a checkpointable compiler
@
text
@a20 1
export Compiler to "Jekyll"
d27 3
a29 3
  const CompilerType <- type CompilerType
    operation doit[InStream, OutStream]
  end CompilerType
d31 1
a31 1
    r <- CompilerType
d33 1
a33 1
  export operation create -> [r : CompilerType]
d37 59
a95 131
      operation Split [s : String] -> [x : String, y : String, z : String]
	var first, last : Integer
	var c : Character
    
	first <- 0
	last <- 0
	for which : Integer <- 0 while which < 3 by which <- which + 1
	  loop
	    exit when first >= s.length
	    c <- s(first)
	    exit when c != ' ' and c != '\^I' and c != '\n'
	    first <- first + 1
	  end loop
	  if first >= s.length then return end if
	  last <- first + 1
	  loop
	    exit when last >= s.length
	    c <- s(last)
	    exit when c = ' ' or c = '\^I' or c = '\n'
	    last <- last + 1
	  end loop
	  if which =0 then
	    x <- s.getSlice[first, last - first]
	  elseif which = 1 then
	    y <- s.getSlice[first, last - first]
	  else
	    z <- s.getSlice[first, last - first]
	  end if
	  first <- last + 1
	end for
      end Split
    
      export operation doit[stdin : InStream, stdout : OutStream]
	var input : String
	var first, second, third : String
	const fstdout <- FormattedOutput.ToStream[stdout]
	var inputfile : InStream
	const inputFiles <- Array.of[InStream].create[~8]
    
	const myenv <- object myenv
	  monitor
	    field fileName : Tree
	    field itable : IdentTable
	    field nextnumber : Integer
	    field nErrors : Integer <- 0
	    field root : Tree
	    field verbose : Boolean <- false
	    field tracegenerate : Boolean <- false
	    field executenow : Boolean <- false
	    field generatebuiltin : Boolean <- false
	    field tracegeneratedbuiltin : Boolean <- false
	    field traceparse : Boolean <- false
	    field dumpassigntypes : Boolean <- false
	    field traceassigntypes : Boolean <- false
	    field doselfs : Boolean <- true
	    field traceevaluatemanifests : Boolean <- false
	    field tracesymbols : Boolean <- false
	    field tracepasses : Boolean <- false
	    field tracetoplevel : Boolean <- true
	    field tracetypecheck : Boolean <- false
	    field traceinline : Boolean <- false
	    field dotypecheck : Boolean <- true
	    field fn : String <- "no file name"
	    field scan : Scanner
	    field rootst : SymbolTable
	    field exportTree : Boolean <- false
	    field perFile : Boolean <- false
	    field nameSpaceFile : String <- nil
	    field traceCode : Boolean <- false
	    field doCompilation : Boolean <- true
	    field doGeneration : Boolean <- true
	    field generateConcurrent : Boolean <- false
	    field thisObject : Tree <- nil
	    field conformtable : IIBTable <- IIBTable.create[128]
    
	    export operation new -> [r : Integer]
	      r <- nextnumber nextnumber <- nextnumber + 1
	    end new
	    export function getStdout -> [r : OutStream]
	      r <- stdout
	    end getStdout
	    export operation error [s : String]
	      const line <- scan.line
	      nErrors <- nErrors + 1
	      fstdout.printf["Syntax Error \"%s\", line %d\n", { fn, scan.lineNumber }]
	      if s != "syntax error" then
		fstdout.printf[s, nil]
		stdout.putchar['\n']
	      end if
	      if line(0) == Character.literal[255] then
		stdout.putstring["<EOF>\n"]
	      else
		fstdout.printf["%s", {line}]
	      end if
	      for i : Integer <- 0 while i < scan.position by i <- i + 1
		if line(i) == '\t' then
		  stdout.putchar['\t']
		else
		  stdout.putchar[' ']
		end if
	      end for
	      stdout.putstring["^\n"]
	    end error
	    export operation errorf [s : String, v : RISA]
	      const line <- scan.line
	      nErrors <- nErrors + 1
	      fstdout.printf["Syntax Error \"%s\", line %d\n", { fn, scan.lineNumber }]
	      if s != "syntax error" then
		fstdout.printf[s, v]
		stdout.putchar['\n']
	      end if
	      if line(0) == Character.literal[255] then
		stdout.putstring["<EOF>\n"]
	      else
		fstdout.printf["%s", {line}]
	      end if
	      for i : Integer <- 0 while i < scan.position by i <- i + 1
		if line(i) == '\t' then
		  stdout.putchar['\t']
		else
		  stdout.putchar[' ']
		end if
	      end for
	      stdout.putstring["^\n"]
	    end errorf
	    export operation warningf [s : String, v : RISA]
	      const line <- scan.line
	      fstdout.printf["\"%s\", line %d Warning: ", { fn, scan.lineNumber }]
	      if s != "syntax error" then
		fstdout.printf[s, v]
	      end if
d97 9
a105 2
	      if line(0) == Character.literal[255] then
		stdout.putstring["<EOF>\n"]
d107 1
a107 1
		fstdout.printf["%s", {line}]
d109 8
a116 12
	      for i : Integer <- 0 while i < scan.position by i <- i + 1
		if line(i) == '\t' then
		  stdout.putchar['\t']
		else
		  stdout.putchar[' ']
		end if
	      end for
	      stdout.putstring["^\n"]
	    end warningf
	    export operation SemanticError [ln : Integer, s : String, v : RISA]
	      nErrors <- nErrors + 1
	      fstdout.printf["\"%s\", line %d: ", { fn, ln }]
a118 10
	    end SemanticError
	    export operation Warning [ln : Integer, s : String, v : RISA]
	      fstdout.printf["\"%s\", line %d Warning: ", { fn, ln }]
	      fstdout.printf[s, v]
	      stdout.putchar['\n']
	    end Warning
	  end monitor
	  export operation pass [s : String, v : RISA]
	    if self$tracepasses then
	      fstdout.printf[s, v]
d120 4
a123 4
	  end pass
	  export operation tassignTypes [s : String, v : RISA]
	    if self$traceassigntypes then
	      fstdout.printf[s, v]
d125 13
a137 3
	  end tassignTypes
	  export operation tinline [s : String, v : RISA]
	    if self$traceinline then
d140 5
a144 4
	  end tinline
	  export operation ttypeCheck [s : String, v : RISA]
	    if self$tracetypecheck then
	      fstdout.printf[s, v]
d146 12
a157 2
	  end ttypeCheck
	  export operation printf [s : String, v : RISA]
d159 59
a217 31
	  end printf
	  export operation done[a : Tree]
	    const AofT <- Array.of[Tree]
	    const q <- AofT.create[~10]
	    const VofCT <- Vector.of[ConcreteType]
	    var   vct : VofCT
	    const VofCO <- Vector.of[CreateOne]
	    var   vco : VofCO
	    var ct : type T
	      function  fetchIndex -> [Integer]
	      operation getIndex[Integer, CPQueue]
	      operation cpoint [OutStream]
	      function  asString -> [String]
	      operation generateBuiltin -> [ConcreteType]
	    end T
	    const hasDoAllocation <- type hasDoAllocation
	      operation doAllocation
	    end hasDoAllocation
	    var da : hasDoAllocation
	    var i : Integer
	    var myCP : CP
    
	    self$root <- a
	    % Parsing
    
	    self.pass["Done parsing\n", nil]
	    if getnErrors[] > 0 then
	      if self$verbose then
		self$root.print[stdout, 0]
	      end if
	      return
d219 15
a233 3
    
	    if self$traceparse then
	      self$root.print[stdout, 0]
d235 17
a251 11
    
	    % Remove Sugar
    
	    self.pass["Removing sugar ...\n", nil]
	    self$root <- self$root.removeSugar[nil]
	    self.pass["Done removing sugar\n", nil]
	    if getnErrors[] > 0 then
	      if self$verbose then
		self$root.print[stdout, 0]
	      end if
	      return
d253 11
a263 7
    
	    % Define Symbols
    
	    if self$rootst == nil then
	      self$rootst <- builtinlit.init
	    else
	      self$rootst.reInitialize
d265 15
a279 9
    
	    self.pass["Defining symbols ...\n", nil]
	    self$root.defineSymbols[self$rootst]
	    self.pass["Done defining symbols\n", nil]
	    if getnErrors[] > 0 then
	      if self$verbose then
		self$root.print[stdout, 0]
	      end if
	      return
d281 25
a305 11
    
	    % Resolve Symbols
    
	    self.pass["Resolving symbols ...\n", nil]
	    self$root.resolveSymbols[self$rootst, 0]
	    self.pass["Done resolving symbols\n", nil]
	    if getnErrors[] > 0 then
	      if self$verbose then
		self$root.print[stdout, 0]
	      end if
	      return
d307 14
a320 3
    
	    if self$tracesymbols then
	      self$root.print[stdout, 0]
d322 13
a334 11
    
	    % Assign ids (the first time)
    
	    self.pass["Assigning ids ...\n", nil]
	    self$root.assignIds[self$rootst]
	    self.pass["Done assigning ids\n", nil]
	    if getnErrors[] > 0 then
	      if self$verbose then
		self$root.print[stdout, 0]
	      end if
	      return
d336 11
a346 15
    
	    % Do manifest objects
    
	    self.pass["Finding manifest objects ...\n", nil]
	    i <- 1
	    loop
	      self.pass["  Pass %d\n", {i}]
	      exit when !self$root.findManifests
	      i <- i + 1
	    end loop
	    self.pass["Done finding manifest objects\n", nil]
	    
	    self.pass["Evaluating manifest objects ...\n", nil]
	    if self$traceevaluatemanifests then
	      self$root.print[stdout, 0]
d348 10
a357 9
    
	    self$root.evaluateManifests
	    self.pass["Done manifest objects\n", nil]
    
	    if getnErrors[] > 0 then
	      if self$verbose then
		self$root.print[stdout, 0]
	      end if
	      return
d359 25
a383 2
	    
	    % Type Assignment
d385 12
a396 9
	    self.pass["Assigning types ...\n", nil]
	    if self$dumpassigntypes then
	      self$root.print[stdout, 0]
	    end if
	    self$root.assignTypes
	    self.pass["Done assigning types\n", nil]
	    if getnErrors[] > 0 then
	      if self$verbose then
		self$root.print[stdout, 0]
d398 12
a409 13
	      return
	    end if
    
	    % Type Checking
    
	    self.pass["Doing type checking ...\n", nil]
	    if self$dotypecheck then
	      self$root.typeCheck
	    end if
	    self.pass["Done type checking\n", nil]
	    if getnErrors[] > 0 then
	      if self$verbose then
		self$root.print[stdout, 0]
a410 2
	      return
	    end if
d412 1
a412 1
	    % Assign Ids again (just in case)
d414 8
a421 6
	    self.pass["Assigning ids ...\n", nil]
	    self$root.assignIds[self$rootst]
	    self.pass["Done assigning ids\n", nil]
	    if getnErrors[] > 0 then
	      if self$verbose then
		self$root.print[stdout, 0]
d423 25
a447 1
	      return
d449 1
a449 5
    
	  if self$doGeneration then
	    self.pass["Finding things to generate ...\n", nil]
	    self$root.findThingsToGenerate[q]
	    self.pass["Done finding things to generate\n", nil]
d452 1
a452 1
		self$root.print[stdout, 0]
d456 2
a457 3
    
	    if ! self$executeNow and ! self$doCompilation then
	      const t <- q.removeLower
d459 35
a493 2
	    if ! self$executeNow then
	      myCP <- CP.create[self$fn, self$perfile]
d495 14
a508 4
    
	    if self$generateBuiltin then
	      vct <- VofCT.create[q.upperbound + 1]
	      vco <- VofCO.create[q.upperbound + 1]
d510 37
a546 65
	    for i : Integer <- q.lowerbound while i <= q.upperbound by i<-i+1
	      const qq <- q(i)
	      const qqname <- qq.asString
	      var junk : Any
	      var theCT : ConcreteType
    
	      self.pass["Generating object #%d %s...\n", {i, qqname : Any}]
    
	      if qqname = "oblit" or qqname = "comp" then
    
		% Allocation
      
		if qqname = "oblit" then
		  const o <- view qq as oblit
		  self.pass["  Name = %s Id = %#x codeOID = %#x\n",
		    { o$name.asString, o$id, o$codeOID : Any}]
		  if o$id !== nil then
		    const c <- CreateOne.create[o$codeOID, o$id]
		    if self$executeNow then
		      vco(i) <- c
		    else
		      myCP.CP[c]
		    end if
		  end if
		end if
    
    
		self.pass["Doing allocation ...\n", nil]
		
		da <- view qq as hasDoAllocation
		da.doAllocation
		self.pass["Done allocation\n", nil]
		if getnErrors[] > 0 then
		  if self$verbose then
		    qq.print[stdout, 0]
		  end if
		  return
		end if
      
		% Code Generation
      
		ct <- CTCode.create
		self.pass["Doing code generation ...\n", nil]
		if self$tracegenerate then qq.print[stdout, 0] end if
		self$thisObject <- qq
		junk <- qq.generate[ct]
		if self$generateBuiltin then
		  theCT <- ct.generateBuiltin
		  vct(i) <- theCT
		end if
		if self$tracegeneratedBuiltin then
		  if !self$generateBuiltin then
		    theCT <- ct.generateBuiltin
		  end if
		  self.printf["Generated code named %s, file %s, template %s\n",
		    {theCT.getName, theCT.getFileName, theCT.getTemplate}]
		  for i : Integer <- 0 while i <= theCT.getOps.upperbound by i<-i+1
		    const xx <- theCT.getOps(i)
		    if xx !== nil then
		      self.printf["  Op %d is %s[%d]->[%d]\n",
			{ i, xx.getName, xx.getNArgs, xx.getNRess}]
		    end if
		  end for
		end if
		self.pass["Done code generation\n", nil]
d548 1
a548 9
		const a <- view qq as atlit
		self.pass["  Name = %s Id = %#x\n",
		  { a$name.asString, a$id : Any}]
		ct <- ATCode.create
		self.pass["Doing abstracttype generation ...\n", nil]
		  if self$tracegenerate then qq.print[stdout, 0] end if
		self$thisObject <- qq
		junk <- qq.generate[ct]
		self.pass["Done abstracttype generation\n", nil]
d550 8
d559 23
a581 50
	      if getnErrors[] > 0 then
		if self$verbose then
		  qq.print[stdout, 0]
		end if
		return
	      end if
	      if !self$executeNow then
		myCP.CP[ct]
	      end if
	    end for
	    if self$generateBuiltin then
	      for i : Integer <- 0 while i <= vco.upperbound by i <- i + 1
		const theCO <- vco(i)
		if theCO !== nil then
		  % We need to create one
		  var theObject : Any
		  const theCT <- vct(i)
		  const theID <- theCO$id
		  assert theCT !== nil
		  primitive "XCREATE" [theObject] <- [theCT, theObject]
		  primitive "INSTALLINOID" [] <- [theID, theObject]
		end if
	      end for
	      for i : Integer <- 0 while i <= vct.upperbound by i <- i + 1
		const theCT <- vct(i)
		if theCT !== nil then
		  % Fix its literals
		  const ops <- theCT.getOps
		  for i : Integer <- 0 while i <= ops.upperbound by i<-i+1
		    const anop <- ops(i)
		    if anop !== nil then
		      const code <- anop.getCode
		      primitive "DOLITERALS" [] <- [code]
		    end if
		  end for
		end if
	      end for
	    end if
	    if self$executeNow then
	      % build the thing
	      const theCompilationCT <- vct(0)
	      var result : Any
	      if self$tracetoplevel then
		printf["Executing %s\n", {self$fn}]
	      end if
	      primitive "XCREATE" [result] <- [theCompilationCT, result]
	    else
	      myCP.finish
	    end if
	    self$thisObject <- nil
d583 3
a585 1
	    % Environment Exports
d587 8
a594 9
	    self.pass["Doing environment exports ...\n", nil]
	    self$root.doEnvExports[nil]
	    self.pass["Done environment exports\n", nil]
	    if getnErrors[] > 0 then
	      if self$verbose then
		self$root.print[stdout, 0]
	      end if
	      return
	    end if
a595 7
	    if !self$exportTree then
	      self.pass["Trashing symbol tables ...\n", nil]
	      begin
		(view self$root as Comp)$st.discard
	      end 
	      self.pass["Done trashing symbol tables\n", nil]
	    end if
a596 34
	    self$root <- nil
	  end done
    
	  export function getln -> [r : Integer]
	    r <- self$scan.lineNumber
	  end getln
    
	  export operation checkNames [a : Tree, b : Tree]
	    const la <- view a as hasId
	    const lb <- view b as hasId
	    if la$id !== lb$id then
	      warningf["Name %s should be %s", { lb$id$name, la$id$name} ]
	    end if
	  end checkNames
    
	  export operation distribute
		  [tm: TreeMaker, l : Tree, t : Tree, v :Tree] -> [r : Tree]
	    if l.upperbound > 0 then
	      r <- seq.create[l$ln]
	    end if
	    for i : Integer <- l.lowerbound while i <= l.upperbound by i <- i + 1
	      begin
		const elem <- l(i)
		const temp <- tm.create[elem$ln, elem, t, v]
		if l.upperbound > 0 then
		  r.rcons[temp]
		else
		  r <- temp
		end if
	      end
	    end for
	  end distribute
	end myenv
    
d601 3
a621 1
	    input <- input.getSlice[0, input.length - 1]
d625 1
a625 1
	    elseif first = "q" then 
d628 4
a631 46
	    elseif first = "set" then
	      if second = "verbose" or second = "v" then
		myenv$verbose <- true
	      elseif second = "exporttree" then
		myenv$exportTree <- true
	      elseif second = "perfile" then
		myenv$perfile <- true
	      elseif second = "tracecode" then
		myenv$tracecode <- true
	      elseif second = "docompilation" then
		myenv$docompilation <- true
	      elseif second = "dogeneration" then
		myenv$dogeneration <- true
	      elseif second = "generatebuiltin" then
		myenv$generatebuiltin <- true
	      elseif second = "executenow" then
		myenv$generatebuiltin <- true
		myenv$executenow <- true
	      elseif second = "generateconcurrent" then
		myenv$generateConcurrent <- true
	      elseif second = "tracegenerate" or second = "tg" then
		myenv$tracegenerate <- true
	      elseif second = "tracegeneratedbuiltin" then
		myenv$tracegeneratedbuiltin <- true
	      elseif second = "traceparse" then
		myenv$traceparse <- true
	      elseif second = "traceassigntypes" then
		myenv$traceassigntypes <- true
	      elseif second = "tracetypecheck" then
		myenv$tracetypecheck <- true
	      elseif second = "tracetoplevel" then
		myenv$tracetoplevel <- true
	      elseif second = "traceinline" then
		myenv$traceinline <- true
	      elseif second = "dotypecheck" then
		myenv$dotypecheck <- true
	      elseif second = "dumpassigntypes" then
		myenv$dumpassigntypes <- true
	      elseif second = "tracesymbols" then
		myenv$tracesymbols <- true
	      elseif second = "traceevaluatemanifests" or second = "tem" then
		myenv$traceevaluatemanifests <- true
	      elseif second = "doselfs" then
		myenv$doselfs <- true
	      elseif second = "tracepasses" then
		myenv$tracepasses <- true
d633 48
a680 1
		fstdout.printf["Undefined variable \"%s\"\n", {second}]
a681 49
	    elseif first = "unset" then
	      if second = "verbose" or second = "v" then
		myenv$verbose <- false
	      elseif second = "exporttree" then
		myenv$exportTree <- false
	      elseif second = "perfile" then
		myenv$perfile <- false
	      elseif second = "tracecode" then
		myenv$traceCode <- false
	      elseif second = "docompilation" then
		myenv$docompilation <- false
	      elseif second = "dogeneration" then
		myenv$dogeneration <- false
	      elseif second = "generatebuiltin" then
		myenv$generatebuiltin <- false
	      elseif second = "executenow" then
		myenv$generatebuiltin <- false
		myenv$executenow <- false
	      elseif second = "generateconcurrent" then
		myenv$generateConcurrent <- false
	      elseif second = "tracegenerate" or second = "tg" then
		myenv$tracegenerate <- false
	      elseif second = "tracegeneratedbuiltin" then
		myenv$tracegeneratedbuiltin <- false
	      elseif second = "traceparse" then
		myenv$traceparse <- false
	      elseif second = "traceassigntypes" then
		myenv$traceassigntypes <- false
	      elseif second = "tracetypecheck" then
		myenv$tracetypecheck <- false
	      elseif second = "tracetoplevel" then
		myenv$tracetoplevel <- false
	      elseif second = "traceinline" then
		myenv$traceinline <- false
	      elseif second = "dotypecheck" then
		myenv$dotypecheck <- false
	      elseif second = "dumpassigntypes" then
		myenv$dumpassigntypes <- false
	      elseif second = "tracesymbols" then
		myenv$tracesymbols <- false
	      elseif second = "traceevaluatemanifests" or second = "tem" then
		myenv$traceevaluatemanifests <- false
	      elseif second = "doselfs" then
		myenv$doselfs <- false
	      elseif second = "tracepasses" then
		myenv$tracepasses <- false
	      else
		fstdout.printf["Undefined variable \"%s\"\n", {second}]
	      end if
d695 1
a695 1
	    else
d724 2
d734 1
@


1.5
log
@New Emerald syntax for primitives
@
text
@d21 1
a21 1
export parsertest to "Jekyll"
d27 10
a36 1
const parsertest <- immutable object parsertest
d38 25
a62 92
  operation Split [s : String] -> [x : String, y : String, z : String]
    var first, last : Integer
    var c : Character

    first <- 0
    last <- 0
    for which : Integer <- 0 while which < 3 by which <- which + 1
      loop
	exit when first >= s.length
	c <- s(first)
	exit when c != ' ' and c != '\^I' and c != '\n'
	first <- first + 1
      end loop
      if first >= s.length then return end if
      last <- first + 1
      loop
	exit when last >= s.length
	c <- s(last)
	exit when c = ' ' or c = '\^I' or c = '\n'
	last <- last + 1
      end loop
      if which =0 then
	x <- s.getSlice[first, last - first]
      elseif which = 1 then
	y <- s.getSlice[first, last - first]
      else
	z <- s.getSlice[first, last - first]
      end if
      first <- last + 1
    end for
  end Split

  export operation doit[stdin : InStream, stdout : OutStream]
    var input : String
    var first, second, third : String
    const fstdout <- FormattedOutput.ToStream[stdout]
    const it <- IdentTable.create
    var inputfile : InStream
    const inputFiles <- Array.of[InStream].create[~8]

    const myenv <- object myenv
      monitor
	field fileName : Tree
	field itable : IdentTable
	field nextnumber : Integer
	field nErrors : Integer <- 0
	field root : Tree
	field verbose : Boolean <- false
	field tracegenerate : Boolean <- false
	field executenow : Boolean <- false
	field generatebuiltin : Boolean <- false
	field tracegeneratedbuiltin : Boolean <- false
	field traceparse : Boolean <- false
	field dumpassigntypes : Boolean <- false
	field traceassigntypes : Boolean <- false
	field doselfs : Boolean <- true
	field traceevaluatemanifests : Boolean <- false
	field tracesymbols : Boolean <- false
	field tracepasses : Boolean <- false
	field tracetoplevel : Boolean <- true
	field tracetypecheck : Boolean <- false
	field traceinline : Boolean <- false
	field dotypecheck : Boolean <- true
	field fn : String <- "no file name"
	field scan : Scanner
	field rootst : SymbolTable
	field exportTree : Boolean <- false
	field perFile : Boolean <- false
	field nameSpaceFile : String <- nil
	field traceCode : Boolean <- false
	field doCompilation : Boolean <- true
	field doGeneration : Boolean <- true
	field generateConcurrent : Boolean <- false
	field thisObject : Tree <- nil
	field conformtable : IIBTable <- IIBTable.create[128]

	export operation new -> [r : Integer]
	  r <- nextnumber nextnumber <- nextnumber + 1
	end new
	export function getStdout -> [r : OutStream]
	  r <- stdout
	end getStdout
	export operation error [s : String]
	  const line <- scan.line
	  nErrors <- nErrors + 1
	  fstdout.printf["Syntax Error \"%s\", line %d\n", { fn, scan.lineNumber }]
	  if s != "syntax error" then
	    fstdout.printf[s, nil]
	    stdout.putchar['\n']
	  end if
	  if line(0) == Character.literal[255] then
	    stdout.putstring["<EOF>\n"]
d64 1
a64 1
	    fstdout.printf["%s", {line}]
d66 133
a198 5
	  for i : Integer <- 0 while i < scan.position by i <- i + 1
	    if line(i) == '\t' then
	      stdout.putchar['\t']
	    else
	      stdout.putchar[' ']
d200 17
a216 8
	  end for
	  stdout.putstring["^\n"]
	end error
	export operation errorf [s : String, v : RISA]
	  const line <- scan.line
	  nErrors <- nErrors + 1
	  fstdout.printf["Syntax Error \"%s\", line %d\n", { fn, scan.lineNumber }]
	  if s != "syntax error" then
d218 31
a248 12
	    stdout.putchar['\n']
	  end if
	  if line(0) == Character.literal[255] then
	    stdout.putstring["<EOF>\n"]
	  else
	    fstdout.printf["%s", {line}]
	  end if
	  for i : Integer <- 0 while i < scan.position by i <- i + 1
	    if line(i) == '\t' then
	      stdout.putchar['\t']
	    else
	      stdout.putchar[' ']
d250 21
a270 18
	  end for
	  stdout.putstring["^\n"]
	end errorf
	export operation warningf [s : String, v : RISA]
	  const line <- scan.line
	  fstdout.printf["\"%s\", line %d Warning: ", { fn, scan.lineNumber }]
	  if s != "syntax error" then
	    fstdout.printf[s, v]
	  end if
	  stdout.putchar['\n']
	  if line(0) == Character.literal[255] then
	    stdout.putstring["<EOF>\n"]
	  else
	    fstdout.printf["%s", {line}]
	  end if
	  for i : Integer <- 0 while i < scan.position by i <- i + 1
	    if line(i) == '\t' then
	      stdout.putchar['\t']
d272 1
a272 1
	      stdout.putchar[' ']
d274 7
a280 244
	  end for
	  stdout.putstring["^\n"]
	end warningf
	export operation SemanticError [ln : Integer, s : String, v : RISA]
	  nErrors <- nErrors + 1
	  fstdout.printf["\"%s\", line %d: ", { fn, ln }]
	  fstdout.printf[s, v]
	  stdout.putchar['\n']
	end SemanticError
	export operation Warning [ln : Integer, s : String, v : RISA]
	  fstdout.printf["\"%s\", line %d Warning: ", { fn, ln }]
	  fstdout.printf[s, v]
	  stdout.putchar['\n']
	end Warning
      end monitor
      export operation pass [s : String, v : RISA]
	if self$tracepasses then
	  fstdout.printf[s, v]
	end if
      end pass
      export operation tassignTypes [s : String, v : RISA]
	if self$traceassigntypes then
	  fstdout.printf[s, v]
	end if
      end tassignTypes
      export operation tinline [s : String, v : RISA]
	if self$traceinline then
	  fstdout.printf[s, v]
	end if
      end tinline
      export operation ttypeCheck [s : String, v : RISA]
	if self$tracetypecheck then
	  fstdout.printf[s, v]
	end if
      end ttypeCheck
      export operation printf [s : String, v : RISA]
	fstdout.printf[s, v]
      end printf
      export operation done[a : Tree]
	const AofT <- Array.of[Tree]
	const q <- AofT.create[~10]
	const VofCT <- Vector.of[ConcreteType]
	var   vct : VofCT
	const VofCO <- Vector.of[CreateOne]
	var   vco : VofCO
	var ct : type T
	  function  fetchIndex -> [Integer]
	  operation getIndex[Integer, CPQueue]
	  operation cpoint [OutStream]
	  function  asString -> [String]
	  operation generateBuiltin -> [ConcreteType]
	end T
	const hasDoAllocation <- type hasDoAllocation
	  operation doAllocation
	end hasDoAllocation
	var da : hasDoAllocation
	var i : Integer
	var myCP : CP

	self$root <- a
	% Parsing

	self.pass["Done parsing\n", nil]
	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if

	if self$traceparse then
	  self$root.print[stdout, 0]
	end if

	% Remove Sugar

	self.pass["Removing sugar ...\n", nil]
	self$root <- self$root.removeSugar[nil]
	self.pass["Done removing sugar\n", nil]
	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if

	% Define Symbols

	if self$rootst == nil then
	  self$rootst <- builtinlit.init
	else
	  self$rootst.reInitialize
	end if

	self.pass["Defining symbols ...\n", nil]
	self$root.defineSymbols[self$rootst]
	self.pass["Done defining symbols\n", nil]
	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if

	% Resolve Symbols

	self.pass["Resolving symbols ...\n", nil]
	self$root.resolveSymbols[self$rootst, 0]
	self.pass["Done resolving symbols\n", nil]
	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if

	if self$tracesymbols then
	  self$root.print[stdout, 0]
	end if

	% Assign ids (the first time)

	self.pass["Assigning ids ...\n", nil]
	self$root.assignIds[self$rootst]
	self.pass["Done assigning ids\n", nil]
	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if

	% Do manifest objects

	self.pass["Finding manifest objects ...\n", nil]
	i <- 1
	loop
	  self.pass["  Pass %d\n", {i}]
	  exit when !self$root.findManifests
	  i <- i + 1
	end loop
	self.pass["Done finding manifest objects\n", nil]
	
	self.pass["Evaluating manifest objects ...\n", nil]
	if self$traceevaluatemanifests then
	  self$root.print[stdout, 0]
	end if

	self$root.evaluateManifests
	self.pass["Done manifest objects\n", nil]

	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if
	
	% Type Assignment

	self.pass["Assigning types ...\n", nil]
	if self$dumpassigntypes then
	  self$root.print[stdout, 0]
	end if
	self$root.assignTypes
	self.pass["Done assigning types\n", nil]
	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if

	% Type Checking

	self.pass["Doing type checking ...\n", nil]
	if self$dotypecheck then
	  self$root.typeCheck
	end if
	self.pass["Done type checking\n", nil]
	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if

	% Assign Ids again (just in case)

	self.pass["Assigning ids ...\n", nil]
	self$root.assignIds[self$rootst]
	self.pass["Done assigning ids\n", nil]
	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if

      if self$doGeneration then
	self.pass["Finding things to generate ...\n", nil]
	self$root.findThingsToGenerate[q]
	self.pass["Done finding things to generate\n", nil]
	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if

	if ! self$executeNow and ! self$doCompilation then
	  const t <- q.removeLower
	end if
	if ! self$executeNow then
	  myCP <- CP.create[self$fn, self$perfile]
	end if

	if self$generateBuiltin then
	  vct <- VofCT.create[q.upperbound + 1]
	  vco <- VofCO.create[q.upperbound + 1]
	end if
	for i : Integer <- q.lowerbound while i <= q.upperbound by i<-i+1
	  const qq <- q(i)
	  const qqname <- qq.asString
	  var junk : Any
	  var theCT : ConcreteType

	  self.pass["Generating object #%d %s...\n", {i, qqname : Any}]

	  if qqname = "oblit" or qqname = "comp" then

	    % Allocation
  
	    if qqname = "oblit" then
	      const o <- view qq as oblit
	      self.pass["  Name = %s Id = %#x codeOID = %#x\n",
		{ o$name.asString, o$id, o$codeOID : Any}]
	      if o$id !== nil then
		const c <- CreateOne.create[o$codeOID, o$id]
		if self$executeNow then
		  vco(i) <- c
		else
		  myCP.CP[c]
		end if
d282 1
d284 39
a322 3


	    self.pass["Doing allocation ...\n", nil]
d324 8
a331 3
	    da <- view qq as hasDoAllocation
	    da.doAllocation
	    self.pass["Done allocation\n", nil]
d334 1
a334 1
		qq.print[stdout, 0]
d338 60
a397 8
  
	    % Code Generation
  
	    ct <- CTCode.create
	    self.pass["Doing code generation ...\n", nil]
	    if self$tracegenerate then qq.print[stdout, 0] end if
	    self$thisObject <- qq
	    junk <- qq.generate[ct]
d399 2
a400 2
	      theCT <- ct.generateBuiltin
	      vct(i) <- theCT
d402 75
a476 3
	    if self$tracegeneratedBuiltin then
	      if !self$generateBuiltin then
		theCT <- ct.generateBuiltin
d478 4
a481 7
	      self.printf["Generated code named %s, file %s, template %s\n",
		{theCT.getName, theCT.getFileName, theCT.getTemplate}]
	      for i : Integer <- 0 while i <= theCT.getOps.upperbound by i<-i+1
		const xx <- theCT.getOps(i)
		if xx !== nil then
		  self.printf["  Op %d is %s[%d]->[%d]\n",
		    { i, xx.getName, xx.getNArgs, xx.getNRess}]
d483 18
d502 14
d517 10
a526 16
	    self.pass["Done code generation\n", nil]
	  else
	    const a <- view qq as atlit
	    self.pass["  Name = %s Id = %#x\n",
	      { a$name.asString, a$id : Any}]
	    ct <- ATCode.create
	    self.pass["Doing abstracttype generation ...\n", nil]
	      if self$tracegenerate then qq.print[stdout, 0] end if
	    self$thisObject <- qq
	    junk <- qq.generate[ct]
	    self.pass["Done abstracttype generation\n", nil]
	  end if

	  if getnErrors[] > 0 then
	    if self$verbose then
	      qq.print[stdout, 0]
d528 1
a528 1
	    return
d530 10
a539 15
	  if !self$executeNow then
	    myCP.CP[ct]
	  end if
	end for
	if self$generateBuiltin then
	  for i : Integer <- 0 while i <= vco.upperbound by i <- i + 1
	    const theCO <- vco(i)
	    if theCO !== nil then
	      % We need to create one
	      var theObject : Any
	      const theCT <- vct(i)
	      const theID <- theCO$id
	      assert theCT !== nil
	      primitive "XCREATE" [theObject] <- [theCT, theObject]
	      primitive "INSTALLINOID" [] <- [theID, theObject]
d541 7
a547 13
	  end for
	  for i : Integer <- 0 while i <= vct.upperbound by i <- i + 1
	    const theCT <- vct(i)
	    if theCT !== nil then
	      % Fix its literals
	      const ops <- theCT.getOps
	      for i : Integer <- 0 while i <= ops.upperbound by i<-i+1
		const anop <- ops(i)
		if anop !== nil then
		  const code <- anop.getCode
		  primitive "DOLITERALS" [] <- [code]
		end if
	      end for
d549 18
a566 59
	  end for
	end if
	if self$executeNow then
	  % build the thing
	  const theCompilationCT <- vct(0)
	  var result : Any
	  if self$tracetoplevel then
	    printf["Executing %s\n", {self$fn}]
	  end if
	  primitive "XCREATE" [result] <- [theCompilationCT, result]
	else
	  myCP.finish
	end if
	self$thisObject <- nil
      end if
	% Environment Exports

	self.pass["Doing environment exports ...\n", nil]
	self$root.doEnvExports[nil]
	self.pass["Done environment exports\n", nil]
	if getnErrors[] > 0 then
	  if self$verbose then
	    self$root.print[stdout, 0]
	  end if
	  return
	end if

	if !self$exportTree then
	  self.pass["Trashing symbol tables ...\n", nil]
	  begin
	    (view self$root as Comp)$st.discard
	  end 
	  self.pass["Done trashing symbol tables\n", nil]
	end if

	self$root <- nil
      end done

      export function getln -> [r : Integer]
	r <- self$scan.lineNumber
      end getln

      export operation checkNames [a : Tree, b : Tree]
	const la <- view a as hasId
	const lb <- view b as hasId
	if la$id !== lb$id then
	  warningf["Name %s should be %s", { lb$id$name, la$id$name} ]
	end if
      end checkNames

      export operation distribute
	      [tm: TreeMaker, l : Tree, t : Tree, v :Tree] -> [r : Tree]
	if l.upperbound > 0 then
	  r <- seq.create[l$ln]
	end if
	for i : Integer <- l.lowerbound while i <= l.upperbound by i <- i + 1
	  begin
	    const elem <- l(i)
	    const temp <- tm.create[elem$ln, elem, t, v]
d568 1
a568 3
	      r.rcons[temp]
	    else
	      r <- temp
d570 26
a595 82
	  end
	end for
      end distribute
    end myenv

    % Set the environment
    myenv$itable <- it
    myenv$nextNumber <- 1
    myenv$nErrors <- 0
    % Set my process environment
    primitive var "SETENV" [] <- [myenv]
    inputfile <- stdin

    loop
      if inputfile == stdin and stdin.isatty then
	stdout.putString["Command: "]
	stdout.flush
      end if
      if inputfile.eos then
	inputfile.close
	if inputFiles.upperbound >= 0 then
	  inputFile <- inputFiles.removeUpper
	else
	  exit
	end if
      else
	input <- inputfile.getString
	input <- input.getSlice[0, input.length - 1]
	first, second, third <- self.Split[input]
	if first == nil then
	  % do nothing
	elseif first = "q" then 
	  stdin.close
	  exit
	elseif first = "set" then
	  if second = "verbose" or second = "v" then
	    myenv$verbose <- true
	  elseif second = "exporttree" then
	    myenv$exportTree <- true
	  elseif second = "perfile" then
	    myenv$perfile <- true
	  elseif second = "tracecode" then
	    myenv$tracecode <- true
	  elseif second = "docompilation" then
	    myenv$docompilation <- true
	  elseif second = "dogeneration" then
	    myenv$dogeneration <- true
	  elseif second = "generatebuiltin" then
	    myenv$generatebuiltin <- true
	  elseif second = "executenow" then
	    myenv$generatebuiltin <- true
	    myenv$executenow <- true
	  elseif second = "generateconcurrent" then
	    myenv$generateConcurrent <- true
	  elseif second = "tracegenerate" or second = "tg" then
	    myenv$tracegenerate <- true
	  elseif second = "tracegeneratedbuiltin" then
	    myenv$tracegeneratedbuiltin <- true
	  elseif second = "traceparse" then
	    myenv$traceparse <- true
	  elseif second = "traceassigntypes" then
	    myenv$traceassigntypes <- true
	  elseif second = "tracetypecheck" then
	    myenv$tracetypecheck <- true
	  elseif second = "tracetoplevel" then
	    myenv$tracetoplevel <- true
	  elseif second = "traceinline" then
	    myenv$traceinline <- true
	  elseif second = "dotypecheck" then
	    myenv$dotypecheck <- true
	  elseif second = "dumpassigntypes" then
	    myenv$dumpassigntypes <- true
	  elseif second = "tracesymbols" then
	    myenv$tracesymbols <- true
	  elseif second = "traceevaluatemanifests" or second = "tem" then
	    myenv$traceevaluatemanifests <- true
	  elseif second = "doselfs" then
	    myenv$doselfs <- true
	  elseif second = "tracepasses" then
	    myenv$tracepasses <- true
	  else
	    fstdout.printf["Undefined variable \"%s\"\n", {second}]
d597 6
a602 68
	elseif first = "unset" then
	  if second = "verbose" or second = "v" then
	    myenv$verbose <- false
	  elseif second = "exporttree" then
	    myenv$exportTree <- false
	  elseif second = "perfile" then
	    myenv$perfile <- false
	  elseif second = "tracecode" then
	    myenv$traceCode <- false
	  elseif second = "docompilation" then
	    myenv$docompilation <- false
	  elseif second = "dogeneration" then
	    myenv$dogeneration <- false
	  elseif second = "generatebuiltin" then
	    myenv$generatebuiltin <- false
	  elseif second = "executenow" then
	    myenv$generatebuiltin <- false
	    myenv$executenow <- false
	  elseif second = "generateconcurrent" then
	    myenv$generateConcurrent <- false
	  elseif second = "tracegenerate" or second = "tg" then
	    myenv$tracegenerate <- false
	  elseif second = "tracegeneratedbuiltin" then
	    myenv$tracegeneratedbuiltin <- false
	  elseif second = "traceparse" then
	    myenv$traceparse <- false
	  elseif second = "traceassigntypes" then
	    myenv$traceassigntypes <- false
	  elseif second = "tracetypecheck" then
	    myenv$tracetypecheck <- false
	  elseif second = "tracetoplevel" then
	    myenv$tracetoplevel <- false
	  elseif second = "traceinline" then
	    myenv$traceinline <- false
	  elseif second = "dotypecheck" then
	    myenv$dotypecheck <- false
	  elseif second = "dumpassigntypes" then
	    myenv$dumpassigntypes <- false
	  elseif second = "tracesymbols" then
	    myenv$tracesymbols <- false
	  elseif second = "traceevaluatemanifests" or second = "tem" then
	    myenv$traceevaluatemanifests <- false
	  elseif second = "doselfs" then
	    myenv$doselfs <- false
	  elseif second = "tracepasses" then
	    myenv$tracepasses <- false
	  else
	    fstdout.printf["Undefined variable \"%s\"\n", {second}]
	  end if
	elseif first = "load" then
	  myenv$namespacefile <- second
	  myenv$rootst <- builtinlit.init
	  xexport.load[second]
	  invoccache.load[second]
	elseif first = "source" then
	  const thefile <- InStream.fromUnix[second, 0, 0]
	  if thefile == nil then
	    fstdout.printf["Can't open \"%s\"\n", {second}]
	  else
	    inputFiles.addUpper[inputfile]
	    inputfile <- thefile
	  end if
	else
	  const f <- InStream.fromUnix[first, 0, 0666]
	  if f == nil then
	    fstdout.printf["Can't open \"%s\"\n", { first }]
	    if first(0) != '/' then
	      fstdout.printf["  You may want an absolute path name\n", nil]
d605 148
a752 6
	    const scan <- scanner.create[f, it]
	    var myparser : ParserCreator
	    var parseResult : Integer
  
	    if myenv$tracetoplevel then
	      fstdout.printf["Compiling %s\n", {first}]
a753 13
	    % Reset the environment
	    myenv$fileName <- stringlit.create[1, first]
	    myenv$nextNumber <- 1
	    myenv$nErrors <- 0
	    myenv$fn <- first
	    myenv$scan <- scan
  
	    myparser <- parsercreator.create[myenv]
  
	    myenv.pass["Parsing ...\n", nil]
	    parseresult <- myparser.parse[scan]
	    myenv$scan <- nil
	    f.close
d755 6
a760 6
	end if
      end if
    end loop
    stdout.close
  end doit
end parsertest
@


1.4
log
@Implemented executenow
@
text
@d350 1
a350 1
%	  self$root.typeCheck
d581 1
a581 1
    primitive 298 [] <- [myenv]
@


1.3
log
@Make generate return something (currently nothing interesting)
@
text
@d78 2
d88 1
d101 1
d214 4
d383 1
a383 1
	if ! self$doCompilation then
d386 3
a388 1
	myCP <- CP.create[self$fn, self$perfile]
d390 4
d412 5
a416 1
		myCP.CP[c]
d440 4
d445 3
a447 1
	      theCT <- ct.generateBuiltin
d477 3
a479 1
	  myCP.CP[ct]
d481 39
a519 1
	myCP.finish
d585 1
a585 1
      if inputfile == stdin then
d618 7
d635 2
d667 7
d684 2
d728 3
a730 1
	    fstdout.printf["Compiling %s\n", {first}]
@


1.2
log
@Get rid of builtins, and incorporate the functions in builtinlit
@
text
@d78 1
d215 1
d383 2
d418 17
d440 5
d446 1
a446 5
	  self.pass["Doing code generation ...\n", nil]
	  if self$tracegenerate then qq.print[stdout, 0] end if
	  self$thisObject <- qq
	  qq.generate[ct]
	  self.pass["Done code generation\n", nil]
d556 2
d596 2
@


1.1
log
@Initial revision
@
text
@a13 1
import Builtins from "Jekyll"
d252 1
a252 1
	  self$rootst <- builtins.init
d597 1
a597 1
	  myenv$rootst <- builtins.init
@
